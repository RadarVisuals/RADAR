# 📦 Full Codebase Dump

---
### `eslint.config.js`
```js
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import vitestPlugin from 'eslint-plugin-vitest'; // <--- Import the Vitest plugin

export default [
  { ignores: ["dist"] },
  { // General config for all JS/JSX files
    files: ["**/*.{js,jsx}"],
    languageOptions: {
      ecmaVersion: 2020, // This can often be 'latest' too, matching parserOptions
      globals: {
        ...globals.browser, // Keep browser globals
        // Add any other custom globals for your main app code if needed
      },
      parserOptions: {
        ecmaVersion: "latest",
        ecmaFeatures: { jsx: true },
        sourceType: "module",
      },
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      "no-unused-vars": ["error", { "varsIgnorePattern": "^[_A-Z]" }],
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      // Add any other general rules here
    },
  },
  { // Vitest specific configuration
    files: ['**/*.test.js', '**/*.test.jsx', '**/*.spec.js', '**/*.spec.jsx'], // Apply only to test files
    plugins: {
      vitest: vitestPlugin,
    },
    rules: {
      // You can include all recommended Vitest rules
      ...vitestPlugin.configs.recommended.rules,
      // Or pick specific rules if you prefer
      // e.g., 'vitest/expect-expect': 'error',

      // You might want to disable or adjust some general rules for test files
      // For example, if you use anonymous functions extensively in `it` blocks:
      // 'func-names': 'off',
    },
    languageOptions: {
      globals: {
        ...globals.browser, // It's good to keep browser globals if tests interact with DOM
        ...vitestPlugin.environments.globals.globals, // <--- Add Vitest globals
      }
    }
  }
];
```

---
### `index.html`
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
    <style>
      /* Ensure html and body take full height of the iframe's allocated space */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000000; /* Base background */
        color: #00f3ff; /* Base text color */
        font-family: Arial, sans-serif;
        display: block; /* Explicitly block */
        /* --- ADDED: Prevent scroll chaining to parent page --- */
        overscroll-behavior: contain;
        /* ---------------------------------------------------- */
      }

      /* Ensure #root takes full height of the body */
      #root {
        width: 100%;
        height: 100%;
        margin: 0; /* Reset margin */
        padding: 0; /* Reset padding */
        overflow: hidden; /* Prevent scrollbars on root */
        display: block; /* Ensure it behaves as a block */
        position: relative; /* Needed if children use absolute positioning relative to root */
      }

      /* Style for the portal target - ensure it doesn't interfere */
      #portal-container {
        position: fixed; /* Or absolute, depending on need */
        top: 0;
        left: 0;
        width: 0; /* Takes no space */
        height: 0; /* Takes no space */
        z-index: 10000; /* High z-index for overlays */
        pointer-events: none; /* Allow clicks through container */
      }
      /* Allow pointer events on direct children */
      #portal-container > * {
         pointer-events: auto;
      }

    </style>
  </head>
  <body>
    <div id="root"></div>
    <!-- Add a dedicated container for portals outside the main app root -->
    <div id="portal-container"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

---
### `package.json`
```json
{
  "name": "radar",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --open",
    "build": "vite build",
    "lint": "eslint . --ext .js,.jsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext .js,.jsx --fix",
    "format": "prettier --write \"src/**/*.{js,jsx,css,json,md}\" ./*.{js,json,md}",
    "preview": "vite preview",
    "audit": "npm audit --audit-level=high",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@erc725/erc725.js": "^0.27.2",
    "@heroicons/react": "^2.2.0",
    "@lukso/lsp-smart-contracts": "^0.16.3",
    "@lukso/up-provider": "^0.3.5",
    "@p5-wrapper/react": "^4.4.2",
    "buffer": "^6.0.3",
    "ethers": "^6.13.5",
    "lodash-es": "^4.17.21",
    "pixi.js": "^8.8.1",
    "prop-types": "^15.8.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "viem": "^2.27.0"
  },
  "devDependencies": {
    "@eslint/js": "^8.57.0",
    "@testing-library/jest-dom": "^6.4.6",
    "@testing-library/react": "^15.0.7",
    "@testing-library/user-event": "^14.5.2",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "@vitest/coverage-v8": "^1.6.0",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-react": "^7.34.2",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "eslint-plugin-vitest": "^0.5.4",
    "globals": "^15.4.0",
    "jsdom": "^24.1.0",
    "prettier": "^3.3.2",
    "vite": "^5.3.1",
    "vitest": "^1.6.0"
  }
}
```

---
### `README.md`
```md
# RADAR - Reactive Asset Driven Audio Receiver

<p align="center">
  <img src="./src/assets/branding/radarwordmarkblue.svg" alt="RADAR Logo" width="400"/>
</p>

**RADAR is determined to set the bar for NFT interaction on the LUKSO blockchain. It's a dynamic, multi-layer visual synthesizer that transforms your LSP8 NFTs into living art, reacting in real-time to audio, MIDI, and on-chain Universal Profile events. RADAR empowers you to move beyond passive collection and become an active creator and performer with your digital assets.**

---

<p align="center">
  <a href="https://www.youtube.com/watch?v=eFxECO9I888&t=327s" target="_blank" rel="noopener noreferrer">
    <img src="./src/assets/branding/radar_demo_thumbnail.png" alt="Watch the RADAR Demo Video!" width="600" style="max-width: 100%;">
  </a>
  <br/>
  <em>Click the image above to watch the RADAR demo video!</em>
</p>

---

## The RADAR Vision: From Collector to Creator

RADAR challenges the notion of NFTs as static collectibles and believe that true digital ownership, powered by LUKSO's Universal Profiles, unleashes a new universe of dynamic use-cases and ignites the imagination for what NFT 2.0 can truly become.

*   **Your NFTs, Your Engine:** Don't let your assets gather virtual dust. RADAR treats your LSP8 NFTs as visual engines, ready to be manipulated and brought to life.
*   **Ownership is Control & Creation:** Go beyond just holding. Layer, glitch, blend, and animate your assets. Save an infinite number of unique visual setups directly onto your Universal Profile.
*   **Decentralized & Composable:** All your creations—visual presets, MIDI mappings, custom color-coded event reactions—are stored on your UP using ERC725Y keys. Your data, ready for a future of shared, community-driven visual experiences.

## The RADAR Genesis Collection & The Future of Asset Utility

Following this hackathon and team feedback, the official **RADAR 1.0 Beta** will launch, headlined by the **RADAR Genesis Collection**: a massive 8,000-piece LSP8 NFT collection designed by RADAR's founder/creator, VXCTXR, specifically to showcase what NFT 2.0 can offer.

*   **Benchmark for Asset Design:** The RADAR Genesis Collection will set the standard for how assets should be prepared for optimal use within the visualizer.
*   **The Value of Artistic Preparation:**
    *   **Isolation & Whitespace:** Assets must be properly isolated within their "NFT canvas," not touching borders, which prevents undesirable straight lines during rotation and scaling.
    *   **Intentional Gaps:** Optimal designs incorporate "gaps" or negative space, allowing underlying layers to show through, creating depth and intricate visual interplay.
    *   **Championing Thoughtful Design:** RADAR inherently values meticulous artistry. Simplistic, mass-generated, or AI-created assets (e.g., fully colored squares) will appear as just that – rotating squares – offering little dynamic value and obscuring interaction with underlying layers. This encourages more intricate and consciously prepared designs.
*   **Redefining Value Beyond Traits:** RADAR shifts the focus from randomly allocated traits dictating perceived value to intrinsic artistic merit. For the first time, collect an asset for its color palette, an admired detail, or its potential within the RADAR engine, not just its "rarity score." **Making ART about the ART again.**
*   **Artistic Effort Rewarded:** In a space often dominated by mass-generated collections, RADAR champions the time, skill, and artistic vision invested in creating assets truly suited for dynamic visual experiences.
*   **New Perspectives on Creation:** While the technology is cool, perception and creativity often hold us back. RADAR is one piece of the puzzle. A quick glance at the "layer preparation grid" tab reveals how I plan to overhaul conceptual blockers: by providing asset owners with tools to deconstruct and reconstruct, the collector immediately becomes a creator. This opens entirely new perspectives on asset interaction, potentially making RADAR the largest community-driven visualizer in existence. See a few transformations in the "Room725" tab.

---

> **Important Note on Embedding/Permissions:**
> If you plan to embed RADAR ensure you grant the necessary permissions for full functionality. You will need to allow the following attributes:
> ```html
> <iframe src="https://radar725.netlify.app/" allow="microphone; midi; fullscreen"></iframe>
> ```
> Failure to include these `allow` attributes will prevent microphone access (for audio reactivity) and MIDI access (for controller input).

---

## Core Features & Technologies

RADAR integrates deeply with LUKSO's philosophy and innovative architecture:

*   **Dynamic NFT Visualization (3-Layer Engine):**
    *   Assign LSP8 NFTs (initially from 40 pre-loaded demo tokens, later from the RADAR Genesis collection and other whitelisted collections) to three distinct visual layers.
    *   Manipulate each layer's `Speed`, `Size`, `Opacity`, `X/Y Position`, `Drift`, `Angle`, `Direction`, and `Blend Mode`.
    *   **Note (Hackathon Scope):** For this hackathon, the on-chain whitelist management panel for adding new LSP7/LSP8 collections is temporarily disabled. To facilitate immediate experimentation, RADAR includes 40 pre-loaded demo tokens. The underlying ERC725Y data storage (`RADAR.WhitelistedCollections`) and retrieval mechanisms for whitelists are implemented and await feedback.

*   **Audio Reactivity (Web Audio API):**
    *   Layers pulsate and resize in response to audio frequencies (Bass -> Bottom Layer, Mid -> Middle Layer, Treble -> Top Layer) and overall beat detection.
    *   A custom Sawtooth-Sinewave hybrid algorithm smoothly blends audio-driven layer interactions.

*   **Tactile MIDI Control (Web MIDI API):**
    *   Intuitive **MIDI Learn** for all visual parameters.
    *   **Global MIDI Map:** Your controller mapping is saved to `RADAR.MIDI.ParameterMap` on your Universal Profile, ensuring consistent control across all presets.

*   **On-Chain Event Reactions (LSP1 UniversalReceiver):**
    *   Visual effects triggered by on-chain events on your UP (e.g., receiving LYX, tokens).
    *   **Global Event Reactions:** Rulesets stored on *your* UP via `RADAR.EventReactions`.

*   **Decentralized Configuration Storage (ERC725Y):**
    RADAR leverages your Universal Profile for true data ownership:
    1.  **Visual Presets (Map: `RADAR.NamedConfiguration:<nameHash>`):** Store infinite unique visual setups.
    2.  **Preset Index (Array: `RADAR.SavedConfigurationList[]`):** Lists your saved presets.
    3.  **Default Preset (Singleton: `RADAR.DefaultConfigurationName`):** Designates your profile's default RADAR experience.

## The Universal Profile as a Creative Hub

RADAR transforms the Universal Profile from a mere wallet or identity layer into a dynamic canvas and creative launchpad.

*   **Collector Becomes Creator:** By loading an asset into RADAR and manipulating its parameters, you become the artist. The visual configurations you save to your UP are new, derived creations—your unique way of "minting" new visual experiences from the assets you hold.
*   **Cross-Profile VJing & Spectating:** This is where the power of decentralized, on-chain configurations truly shines:
    *   Visit another user's Universal Profile running RADAR.
    *   Load their saved visual presets and witness their unique artistic interpretations of their assets.
    *   If you have a MIDI controller, *your* global MIDI map (from your UP) can control the parameters of *their* presets, enabling unprecedented live, cross-profile VJing.
    *   See their on-chain events trigger their personally configured visual reactions.
*   **Future of Whitelist & Community Curation:** Post-hackathon, activating the whitelist panel within RADAR.

This interplay of personal creation, shared experiences, and on-chain identity only scratches the surface of the possibilities achievable with LUKSO's architecture.

---

## Bonus: Creative Suite Extensions (Testable in Grid Tabs)

Beyond the core visualizer, RADAR is expanding with tools that further empower your creative journey:

*   **RADAR Layer Prep Tool:**
    *   **Concept:** Don't just use your NFTs as-is; transform them! This experimental tool (available under the "Grid" -> "RADAR Layer Prep" tab) allows you to load your existing NFTs and deconstruct/reconstruct them into new visual components optimized for RADAR's layering engine.
    *   **Become the Artist:** Manipulate, crop, and combine elements from your NFTs to create entirely new, unique assets ready to be fed back into the RADAR visualizer. This truly puts the power of asset creation into your hands.
    *   *(See example outcomes in the "Room 725" tab after prepping an asset!)*

*   **Room 725 - 3D Showroom:**
    *   **Concept:** Experience your original NFTs and your newly created "prepped" assets in an immersive, first-person 3D environment.
    *   **Walkable Gallery:** Navigate this virtual space (available under the "Grid" -> "Room 725" tab) to see your digital art come to life in a new dimension. It's a unique way to appreciate the transformation from original asset to RADAR-ready component and then to dynamic visual synthesis.

These experimental features showcase the ongoing commitment to making RADAR the most comprehensive platform for NFT interaction, creation, and exhibition. Dive into the "Grid" section of the app to explore these powerful additions!

---

## Roadmap Highlights

*   **Visual Effect Expansion:** More effects, parameter interpolation, "P-locking" concepts.
*   **Advanced MIDI:** Clock sync, value range mapping, toggle actions.
*   **LSP8 Collection Onboarding:** Streamlined community whitelisting, artist onboarding guidelines.
*   **Performance Optimization:** Custom 2D engine refinement.
*   **AR Integration:** QR / AR art marker overlay directly integrating the UP QR.
*   **Open Source Strategy:** Evaluate open-sourcing key components.
*   **Deeper LUKSO Integration:** Continuously explore and implement new LUKSO standards and features.
*   **The Vision:** RADAR is an extremely well-aimed and positioned first step with a clear artistic direction and an innovative mindset, poised to redefine interactive asset utility.

---

## Setup Guides

### MIDI Control Setup

RADAR offers intuitive MIDI control over its visual parameters, allowing for a tactile and expressive performance experience. Your MIDI mappings are saved globally to your Universal Profile.
For reference, I use a Novation Launchcontrol XL MIDI controller, set up my complete mapping (24 parameters) and save it once to the global MIDI key. This one is accessible for me across all other profiles.

**Steps to Map Your MIDI Controller:**

1.  **Connect Your MIDI Controller:**
    *   Plug your MIDI controller (keyboard, knob/fader controller, drum pads, etc.) into your computer, typically via USB.
    *   Most modern MIDI controllers are class-compliant and should be automatically detected by your operating system and browser.
2.  **Enable MIDI in RADAR:**
    *   Locate the **Global MIDI Status button** in the RADAR interface (usually in the bottom-right corner, often represented by a MIDI plug icon).
    *   Click this button. It should indicate a "Connected" state if your controller is detected.
    *   *If it says "Disconnected" or shows an error, ensure your controller is properly connected and recognized by your system. You may need to click it again to initiate the connection.*
3.  **Access Layer Controls:**
    *   Open the main **Controls Panel** (usually triggered by a sliders icon in the vertical toolbar).
    *   Select the visual layer (Top, Middle, or Bottom) you wish to map controls for.
4.  **Initiate MIDI Learn for a Parameter:**
    *   For each parameter you want to control (e.g., `Size`, `Speed`, `X Position`, `Opacity`), you'll see a small **'M' (MIDI Learn) button** next to its slider or value display.
    *   Click the 'M' button for the specific parameter you want to map. The button will typically change appearance (e.g., highlight, show "...") to indicate it's now "listening" for a MIDI message.
5.  **Assign Your MIDI Control:**
    *   On your connected MIDI controller, **move the physical knob, fader, or press the pad/key** you want to assign to the selected parameter.
    *   RADAR will detect the incoming MIDI message (e.g., a Control Change (CC) from a knob, or a Note On from a pad).
    *   The parameter will automatically be mapped to that MIDI control. The 'M' button should return to its normal state, and the UI might display the new mapping (e.g., "CC 21").
6.  **Repeat for All Desired Parameters & Layers:**
    *   Continue this process (Steps 3-5) for all other parameters you wish to control across all three visual layers.
7.  **Save Your Global MIDI Map:**
    *   Once you're satisfied with your mappings:
        *   Open the **Save Panel** (usually triggered by a write/disk icon).
        *   Look for an option like **"Save Global MIDI Map"** or an option to include MIDI settings when saving a visual preset.
        *   Click to save. This action writes your entire MIDI mapping configuration to the `RADAR.MIDI.ParameterMap` key on your Universal Profile.

**Key Benefits of RADAR's MIDI System:**

*   **Global & Persistent:** Your MIDI map is saved once to your UP and applies across *all* visual presets.
*   **Intuitive Learn Mode:** No manual entry of CC numbers or channels needed; just click and move.
*   **Cross-Profile Compatibility:** When viewing someone else's RADAR setup, *your* saved MIDI map controls *their* visual parameters.

Now your MIDI controller is your hands-on interface for sculpting visuals in RADAR!

### Audio Reactivity Setup (Using Virtual Audio Cable & Voicemeeter)

To make RADAR's visuals react to the audio playing on your computer (e.g., from your browser or music player), you can route your audio through Voicemeeter using a Virtual Audio Cable. This gives you fine-grained control.

**Prerequisites:**

*   **Voicemeeter** (Standard version or Banana/Potato) installed. Get it from [vb-audio.com/Voicemeeter/](https://vb-audio.com/Voicemeeter/).
*   **VB-CABLE Virtual Audio Cable** installed. Get it from [vb-audio.com/Cable/](https://vb-audio.com/Cable/).
*   **Restart your computer** after installing these.

**Steps:**

1.  **Route Desired Audio to Virtual Cable (Recommended for Browser/App Audio):**
    *   In Windows Sound settings ("Open Sound settings" -> "App volume and device preferences"):
        *   Find your web browser (or the specific application whose audio you want to capture).
        *   Change its **Output** device to **"CABLE Input (VB-Audio Virtual Cable)"**.
    *   *Alternatively, for simpler system-wide audio capture (less granular), set "CABLE Input" as your Default Playback Device in Windows Sound settings (Playback tab).*

2.  **Configure Voicemeeter:**
    *   Open Voicemeeter.
    *   **Hardware Input 1 (Stereo Input 1 or 2):** Click its name (e.g., "Hardware Input 1") and select **"CABLE Output (VB-Audio Virtual Cable)"**. This brings audio from the virtual cable *into* Voicemeeter.
        *   Ensure this channel strip is active (fader is up, not muted - check A/B buttons if using Banana/Potato). Enable its output route to **A1** (your main hardware out) if you want to monitor this source through Voicemeeter.
    *   **Hardware Out (A1):** Click "A1" (under Hardware Out section) and select your main speakers/headphones (e.g., "WDM: Speakers (Realtek Audio)").

3.  **Browser Permissions for RADAR:**
    *   When enabling Audio Reactivity in RADAR for the first time, your browser will ask for microphone permission.
    *   In the permission prompt, select **"Voicemeeter Output (VB-Audio Voicemeeter VAIO)"** (or similar, depending on Voicemeeter version) as the microphone source. **Do not select CABLE Output or your physical microphone here.**

**How it Works:** Your target application (e.g., browser) sends its sound output to the virtual "CABLE Input". The other end of this virtual cable, "CABLE Output", is selected as an *input* in Voicemeeter. Voicemeeter processes this audio and sends it to two places: your speakers/headphones (via Hardware Out A1) and its own internal virtual output, "Voicemeeter Output". RADAR then listens to this "Voicemeeter Output" as if it were a microphone, capturing the audio you routed into Voicemeeter.

This method allows selective audio routing for the visualizer without needing to capture *all* system sound or use a physical loopback.
```

---
### `src\App.jsx`
```jsx
// src/App.jsx
import React, { useEffect } from "react";
import MainView from "./components/Main/Mainview";
import { useUserSession } from "./context/UserSessionContext"; // Import useUserSession

// Component to handle URL parameters for pure visitor mode
const URLParameterHandler = () => {
  const { togglePreviewMode } = useUserSession(); // Use togglePreviewMode from UserSessionContext

  useEffect(
    () => {
      const urlParams = new URLSearchParams(window.location.search);
      const isPureFromUrl = urlParams.get("pure") === "true";
      if (isPureFromUrl && typeof togglePreviewMode === "function") {
        // NOTE: The actual call to togglePreviewMode() is currently disabled below.
        // If re-enabled, add togglePreviewMode to the dependency array.
        // togglePreviewMode();
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [] // If togglePreviewMode() is re-enabled, add it to deps: [togglePreviewMode]
  );

  return null;
};

function App() {
  return (
    <div className="app">
      <URLParameterHandler />
      <MainView />
    </div>
  );
}

export default App;
```

---
### `src\components\Audio\AudioAnalyzer.jsx`
```jsx
// src/components/Audio/AudioAnalyzer.jsx
import React, { useEffect, useRef, useCallback } from "react";
import PropTypes from "prop-types";

// Default values for layer parameters if not provided by layerConfigs
const DEFAULT_LAYER_VALUES = {
    size: 1.0, // Default base size for layers if not specified in their config
};
const DEFAULT_SMOOTHING = 0.6; // Default smoothing factor for the AnalyserNode
const FFT_SIZE = 2048; // Standard FFT size for frequency analysis

/**
 * @typedef {object} AudioAnalyzerProps
 * @property {(data: import('../../hooks/useAudioVisualizer').RawAudioAnalyzerData) => void} [onAudioData] - Callback function invoked with new audio analysis data (level, frequency bands, timestamp).
 * @property {boolean} [isActive=false] - If true, the component attempts to access the microphone and start audio analysis.
 * @property {import('../../context/VisualConfigContext').AllLayerConfigs} [layerConfigs] - Current configurations for all visual layers. Used to get base values for audio-reactive parameters.
 * @property {import('../../hooks/useAudioVisualizer').AudioVisualizerSettings} [audioSettings] - Current settings for audio processing and analysis (e.g., intensity multipliers, smoothing factor).
 * @property {number} [configLoadNonce] - A nonce that changes when a new global configuration (preset) is loaded. Used to detect preset changes and potentially reset or adjust audio reactivity baselines.
 * @property {React.RefObject<Object.<string, import('../../utils/CanvasManager').default>>} managerInstancesRef - Ref to the canvas manager instances, used to apply audio-driven visual modifications directly.
 */

/**
 * AudioAnalyzer: A non-visual component responsible for capturing microphone input,
 * analyzing the audio stream to extract level and frequency band data, and then
 * applying these data to visual layers via `CanvasManager` instances.
 * It also calls `onAudioData` with the processed information for other consumers.
 * The component manages the lifecycle of the `AudioContext` and `AnalyserNode`.
 *
 * @param {AudioAnalyzerProps} props - The component's props.
 * @returns {null} This component does not render any visible UI.
 */
const AudioAnalyzer = ({
  onAudioData,
  isActive = false,
  layerConfigs: layerConfigsProp,
  audioSettings: audioSettingsProp,
  configLoadNonce,
  managerInstancesRef,
}) => {
  /** @type {React.RefObject<import('../../hooks/useAudioVisualizer').AudioVisualizerSettings | undefined>} */
  const audioSettingsRef = useRef(audioSettingsProp);
  /** @type {React.RefObject<Object.<string, {size: number}>>} */
  const baseLayerValuesRef = useRef({ // Stores base 'size' for each layer before audio modulation
      '1': { size: DEFAULT_LAYER_VALUES.size },
      '2': { size: DEFAULT_LAYER_VALUES.size },
      '3': { size: DEFAULT_LAYER_VALUES.size },
  });
  /** @type {React.RefObject<number>} */
  const capturedNonceRef = useRef(-1); // Tracks the last processed configLoadNonce
  /** @type {React.RefObject<boolean>} */
  const isTransitioningRef = useRef(false); // Flag to dampen audio effects during preset transitions
  /** @type {React.RefObject<{bass: number, mid: number, treble: number}>} */
  const lastBandDataRef = useRef({ bass: 0, mid: 0, treble: 0 }); // For smoothing during transitions
  /** @type {React.RefObject<number>} */
  const lastLevelRef = useRef(0); // For smoothing during transitions

  /** @type {React.RefObject<AudioContext | null>} */
  const audioContextRef = useRef(null);
  /** @type {React.RefObject<AnalyserNode | null>} */
  const analyserRef = useRef(null);
  /** @type {React.RefObject<MediaStreamAudioSourceNode | null>} */
  const sourceRef = useRef(null);
  /** @type {React.RefObject<number | null>} */
  const animationFrameRef = useRef(null);
  /** @type {React.RefObject<Uint8Array | null>} */
  const dataArrayRef = useRef(null);
  /** @type {React.RefObject<MediaStream | null>} */
  const streamRef = useRef(null);
  /** @type {React.RefObject<boolean>} */
  const isCleanupScheduledRef = useRef(false); // Prevents redundant cleanup calls

  // Update audio settings ref and AnalyserNode smoothing when props change
  useEffect(() => {
    audioSettingsRef.current = audioSettingsProp;
    if (analyserRef.current && audioContextRef.current && audioContextRef.current.state === "running") {
        try {
            const smoothing = audioSettingsRef.current?.smoothingFactor ?? DEFAULT_SMOOTHING;
            analyserRef.current.smoothingTimeConstant = Math.max(0, Math.min(1, smoothing));
        }
        catch (e) {
            if (import.meta.env.DEV) console.warn("[AudioAnalyzer] Error setting smoothingTimeConstant:", e);
        }
    }
  }, [audioSettingsProp]);

  // Update base layer values and handle transition state when a new preset is loaded
  useEffect(() => {
    if (layerConfigsProp && configLoadNonce !== capturedNonceRef.current) {
        // --- START: TEMPORARILY DISABLED TRANSITION LOGIC ---
        // if (capturedNonceRef.current !== -1 && import.meta.env.DEV) { // If not the very first load
        //     // console.log("[AudioAnalyzer] New configLoadNonce detected, entering transition phase for audio reactivity.");
        //     isTransitioningRef.current = true;
        //     // Transition phase to smooth out audio reactivity changes
        //     setTimeout(() => {
        //         if (isTransitioningRef.current) {
        //             isTransitioningRef.current = false;
        //             // if (import.meta.env.DEV) console.log("[AudioAnalyzer] Audio reactivity transition phase ended.");
        //         }
        //     }, 1000); // Duration of the transition dampening
        // }
        // --- END: TEMPORARILY DISABLED TRANSITION LOGIC ---
        isTransitioningRef.current = false; // Explicitly set to false for testing responsiveness

        const newBaseValues = {};
        for (const layerIdStr of ['1', '2', '3']) { // Assuming fixed layer IDs
            const config = layerConfigsProp[layerIdStr] || {};
            newBaseValues[layerIdStr] = { size: config.size ?? DEFAULT_LAYER_VALUES.size };
        }
        baseLayerValuesRef.current = newBaseValues;
        capturedNonceRef.current = configLoadNonce;
    }
  }, [configLoadNonce, layerConfigsProp]);

  // Applies calculated audio data (bands, level) to canvas managers for visual effects
  const applyAudioToLayers = useCallback((bands, level) => {
    const managers = managerInstancesRef?.current;
    const currentSettings = audioSettingsRef.current;

    if (!managers || !currentSettings) {
        return;
    }

    // --- START: TEMPORARILY DISABLED TRANSITION LOGIC ---
    // Dampen effect intensity during preset transitions
    // const transitionFactor = isTransitioningRef.current ? 0.2 : 1.0;
    const transitionFactor = 1.0; // Force no dampening for testing responsiveness
    // --- END: TEMPORARILY DISABLED TRANSITION LOGIC ---
    const { bassIntensity = 1.0, midIntensity = 1.0, trebleIntensity = 1.0 } = currentSettings;

    // Apply bass frequency to layer 1 size
    const bassEffectMagnitude = bands.bass * 0.8 * bassIntensity * transitionFactor;
    const finalBassFactor = 1 + bassEffectMagnitude; // Multiplier around base size
    if (managers['1'] && typeof managers['1'].setAudioFrequencyFactor === 'function') {
        managers['1'].setAudioFrequencyFactor(Math.max(0.1, finalBassFactor));
    }

    // Apply mid frequency to layer 2 size
    const midEffectMagnitude = bands.mid * 1.0 * midIntensity * transitionFactor;
    const finalMidFactor = 1 + midEffectMagnitude;
    if (managers['2'] && typeof managers['2'].setAudioFrequencyFactor === 'function') {
        managers['2'].setAudioFrequencyFactor(Math.max(0.1, finalMidFactor));
    }

    // Apply treble frequency to layer 3 size
    const trebleEffectMagnitude = bands.treble * 2.0 * trebleIntensity * transitionFactor;
    const finalTrebleFactor = 1 + trebleEffectMagnitude;
    if (managers['3'] && typeof managers['3'].setAudioFrequencyFactor === 'function') {
        managers['3'].setAudioFrequencyFactor(Math.max(0.1, finalTrebleFactor));
    }

    // Trigger a beat pulse effect on all layers if conditions are met
    // --- START: TEMPORARILY DISABLED TRANSITION LOGIC in beat pulse ---
    // if (level > 0.4 && bands.bass > 0.6 && !isTransitioningRef.current) {
    if (level > 0.4 && bands.bass > 0.6) { // Always allow beat pulse if conditions met for testing
    // --- END: TEMPORARILY DISABLED TRANSITION LOGIC in beat pulse ---
      const pulseMultiplier = 1 + level * 0.8; // Stronger pulse for higher levels
      Object.keys(managers).forEach(layerIdStr => {
        const manager = managers[layerIdStr];
        if (manager && typeof manager.triggerBeatPulse === 'function') {
          manager.triggerBeatPulse(Math.max(0.1, pulseMultiplier), 80); // Short pulse duration
        }
      });
    }
  }, [managerInstancesRef]); // audioSettingsRef and isTransitioningRef are refs

  // Processes raw frequency data from AnalyserNode into level and bands
  const processAudioData = useCallback((dataArray) => {
    if (!dataArray || !analyserRef.current) return;

    const bufferLength = analyserRef.current.frequencyBinCount;
    if (bufferLength === 0) return; // Should not happen if analyser is set up

    let sum = 0; for (let i = 0; i < bufferLength; i++) { sum += dataArray[i]; }
    const averageLevel = sum / bufferLength / 255; // Normalize to 0-1 range

    // Define frequency band ranges (these can be tuned)
    const bassEndIndex = Math.floor(bufferLength * 0.08); // ~0-200Hz for 2048 FFT / 48kHz sample rate
    const midEndIndex = bassEndIndex + Math.floor(bufferLength * 0.35); // ~200Hz-1.8kHz

    let bassSum = 0, midSum = 0, trebleSum = 0;
    let bassCount = 0, midCount = 0, trebleCount = 0;

    for (let i = 0; i < bufferLength; i++) {
        if (i < bassEndIndex) { bassSum += dataArray[i]; bassCount++; }
        else if (i < midEndIndex) { midSum += dataArray[i]; midCount++; }
        else { trebleSum += dataArray[i]; trebleCount++; }
    }

    // Normalize band values to 0-1 range
    const bass = Math.min(1, bassCount > 0 ? (bassSum / bassCount / 255) : 0);
    const mid = Math.min(1, midCount > 0 ? (midSum / midCount / 255) : 0);
    const treble = Math.min(1, trebleCount > 0 ? (trebleSum / trebleCount / 255) : 0);

    let newBass = bass, newMid = mid, newTreble = treble, newLevel = averageLevel;

    // --- START: TEMPORARILY DISABLED TRANSITION LOGIC ---
    // Smooth values during transitions to avoid jarring visual changes
    // if (isTransitioningRef.current) {
    //     const blendFactor = 0.8; // How much of the previous value to keep
    //     newBass = lastBandDataRef.current.bass * blendFactor + bass * (1 - blendFactor);
    //     newMid = lastBandDataRef.current.mid * blendFactor + mid * (1 - blendFactor);
    //     newTreble = lastBandDataRef.current.treble * blendFactor + treble * (1 - blendFactor);
    //     newLevel = lastLevelRef.current * blendFactor + averageLevel * (1 - blendFactor);
    // }
    // --- END: TEMPORARILY DISABLED TRANSITION LOGIC ---
    // When transition logic is disabled, newBass, newMid, etc., will just be the raw band values

    lastBandDataRef.current = { bass: newBass, mid: newMid, treble: newTreble };
    lastLevelRef.current = newLevel;

    const newFrequencyBands = { bass: newBass, mid: newMid, treble: newTreble };

    applyAudioToLayers(newFrequencyBands, newLevel);

    if (typeof onAudioData === "function") {
      onAudioData({ level: newLevel, frequencyBands: newFrequencyBands, timestamp: Date.now() });
    }
  }, [onAudioData, applyAudioToLayers]); // isTransitioningRef, lastBandDataRef, lastLevelRef are refs

  // Main audio analysis loop using requestAnimationFrame
  const analyzeAudio = useCallback(() => {
    if (!analyserRef.current || !dataArrayRef.current || !isActive || !audioContextRef.current || audioContextRef.current.state !== 'running') {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      return;
    }
    try {
        analyserRef.current.getByteFrequencyData(dataArrayRef.current);
        processAudioData(dataArrayRef.current);
    } catch (e) {
        if (import.meta.env.DEV) console.error("[AudioAnalyzer analyzeAudio] Error in getByteFrequencyData or processAudioData:", e);
    }
    if (typeof requestAnimationFrame === 'function') {
        animationFrameRef.current = requestAnimationFrame(analyzeAudio);
    }
  }, [isActive, processAudioData]); // processAudioData is memoized

  // Sets up the AudioContext, AnalyserNode, and connects the microphone stream
  const setupAudioAnalyzer = useCallback(async (stream) => {
    if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] Attempting to set up audio analyzer...");
    try {
      if (!audioContextRef.current) {
        const AudioContextGlobal = window.AudioContext || window.webkitAudioContext;
        if (!AudioContextGlobal) {
            if (import.meta.env.DEV) console.error("[AudioAnalyzer setupAudioAnalyzer] AudioContext not supported!");
            return;
        }
        audioContextRef.current = new AudioContextGlobal();
        if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] AudioContext created. Sample rate:", audioContextRef.current.sampleRate);
      }

      if (audioContextRef.current.state === "suspended") {
        if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] AudioContext is suspended, attempting to resume...");
        await audioContextRef.current.resume();
        if (import.meta.env.DEV) console.log(`[AudioAnalyzer setupAudioAnalyzer] AudioContext resumed. State: ${audioContextRef.current.state}`);
      }
      if (audioContextRef.current.state !== "running") {
          if (import.meta.env.DEV) console.error(`[AudioAnalyzer setupAudioAnalyzer] AudioContext not running after resume attempt. State: ${audioContextRef.current.state}`);
          return;
      }

      if (!analyserRef.current) {
        analyserRef.current = audioContextRef.current.createAnalyser();
        if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] AnalyserNode created.");
      }

      const initialSmoothing = audioSettingsRef.current?.smoothingFactor ?? DEFAULT_SMOOTHING;
      analyserRef.current.fftSize = FFT_SIZE;
      analyserRef.current.smoothingTimeConstant = Math.max(0, Math.min(1, initialSmoothing));
      analyserRef.current.minDecibels = -90; // Typical range for audio analysis
      analyserRef.current.maxDecibels = -10;

      const bufferLength = analyserRef.current.frequencyBinCount;
      if (bufferLength === 0) {
          if (import.meta.env.DEV) console.error("[AudioAnalyzer setupAudioAnalyzer] Analyser frequencyBinCount is 0. FFT setup issue?");
          return;
      }
      dataArrayRef.current = new Uint8Array(bufferLength);
      if (import.meta.env.DEV) console.log(`[AudioAnalyzer setupAudioAnalyzer] Data array created with length: ${bufferLength}`);

      if (sourceRef.current) { // Disconnect previous source if exists
        try {
            sourceRef.current.disconnect();
            if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] Disconnected previous source.");
        } catch (disconnectError) {
            if (import.meta.env.DEV) console.warn("[AudioAnalyzer setupAudioAnalyzer] Error disconnecting previous source:", disconnectError);
        }
      }
      sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);
      sourceRef.current.connect(analyserRef.current); // Connect new stream to analyser
      if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] MediaStreamSource created and connected to analyser.");

      if (animationFrameRef.current) { // Cancel any existing animation loop
          cancelAnimationFrame(animationFrameRef.current);
      }
      if (typeof requestAnimationFrame === 'function') {
        animationFrameRef.current = requestAnimationFrame(analyzeAudio); // Start new loop
        if (import.meta.env.DEV) console.log("[AudioAnalyzer setupAudioAnalyzer] Audio analysis loop started.");
      }
      isCleanupScheduledRef.current = false; // Reset cleanup flag

    } catch (e) {
      if (import.meta.env.DEV) console.error("[AudioAnalyzer setupAudioAnalyzer] Error setting up audio analyzer:", e);
    }
  }, [analyzeAudio]); // analyzeAudio is memoized, audioSettingsRef is a ref

  // Requests microphone access from the user
  const requestMicrophoneAccess = useCallback(async () => {
    if (import.meta.env.DEV) console.log("[AudioAnalyzer requestMicrophoneAccess] Requesting microphone access...");
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      if (import.meta.env.DEV) console.error("[AudioAnalyzer requestMicrophoneAccess] Microphone access not supported by this browser.");
      return;
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { // Desired audio constraints
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
        },
        video: false, // No video needed
      });
      if (import.meta.env.DEV) console.log("[AudioAnalyzer requestMicrophoneAccess] Microphone access granted.");
      streamRef.current = stream;
      await setupAudioAnalyzer(stream);
    } catch (err) {
      if (import.meta.env.DEV) console.error("[AudioAnalyzer requestMicrophoneAccess] Error accessing microphone:", err.name, err.message);
      // Potentially update UI or notify user of permission denial
    }
  }, [setupAudioAnalyzer]); // setupAudioAnalyzer is memoized

  // Cleans up audio resources (stream, nodes, context)
  const cleanupAudio = useCallback(() => {
    if (isCleanupScheduledRef.current) return; // Prevent redundant cleanups
    isCleanupScheduledRef.current = true;
    if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] Initiating audio resources cleanup...");

    if (animationFrameRef.current && typeof cancelAnimationFrame === 'function') {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
      if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] Animation frame cancelled.");
    }

    const managers = managerInstancesRef?.current;
    if (managers) {
        Object.values(managers).forEach(manager => {
            if (manager && typeof manager.resetAudioModifications === 'function') {
                manager.resetAudioModifications();
            }
        });
        if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] Audio modifications reset on managers.");
    }

    if (sourceRef.current) {
      try {
        sourceRef.current.disconnect();
        if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] Source node disconnected.");
      } catch (e) {
        if (import.meta.env.DEV) console.warn("[AudioAnalyzer cleanupAudio] Error disconnecting source node:", e.message);
      }
      sourceRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => {
        track.stop(); // Stop each track in the stream
        if (import.meta.env.DEV) console.log(`[AudioAnalyzer cleanupAudio] MediaStreamTrack stopped: ${track.label || track.id}`);
      });
      streamRef.current = null;
    }

    // Suspend AudioContext instead of closing, to allow potential re-activation
    if (audioContextRef.current) {
        if (audioContextRef.current.state === "running") {
            audioContextRef.current.suspend().then(() => {
                if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] AudioContext suspended.");
                isCleanupScheduledRef.current = false; // Allow cleanup again if re-activated
            }).catch((e) => {
                if (import.meta.env.DEV) console.error("[AudioAnalyzer cleanupAudio] Error suspending AudioContext:", e);
                isCleanupScheduledRef.current = false;
            });
        } else {
            if (import.meta.env.DEV) console.log(`[AudioAnalyzer cleanupAudio] AudioContext not running (state: ${audioContextRef.current.state}), no suspend needed.`);
            isCleanupScheduledRef.current = false;
        }
    } else {
        isCleanupScheduledRef.current = false; // No context to suspend
    }
    if (import.meta.env.DEV) console.log("[AudioAnalyzer cleanupAudio] Cleanup process finished.");
  }, [managerInstancesRef]); // managerInstancesRef is a ref

  // Effect to manage audio setup/teardown based on `isActive` prop
  useEffect(() => {
    if (isActive) {
      if (import.meta.env.DEV) console.log("[AudioAnalyzer] isActive is true. Requesting microphone access.");
      requestMicrophoneAccess();
    } else {
      if (import.meta.env.DEV) console.log("[AudioAnalyzer] isActive is false. Cleaning up audio.");
      cleanupAudio();
    }
    // This return function is for when `isActive` changes from true to false,
    // or when the component unmounts while `isActive` was true.
    return () => {
        if (isActive) { // Only cleanup if it was active before this effect re-ran or unmounted
            cleanupAudio();
        }
    };
  }, [isActive, requestMicrophoneAccess, cleanupAudio]);

  // Final cleanup on component unmount
  useEffect(() => {
    return () => {
      if (import.meta.env.DEV) console.log("[AudioAnalyzer] Component unmounting. Performing final cleanup.");
      cleanupAudio(); // Ensure all resources are released
      // Close AudioContext fully on unmount
      if (audioContextRef.current) {
        audioContextRef.current.close().then(() => {
            if (import.meta.env.DEV) console.log("[AudioAnalyzer] AudioContext closed on unmount.");
        }).catch(e => {
            if (import.meta.env.DEV) console.error("[AudioAnalyzer] Error closing AudioContext on unmount:", e);
        });
        audioContextRef.current = null;
      }
    };
  }, [cleanupAudio]); // cleanupAudio is memoized

  return null; // This component does not render any visible UI
};

AudioAnalyzer.propTypes = {
  onAudioData: PropTypes.func,
  isActive: PropTypes.bool,
  layerConfigs: PropTypes.object,
  audioSettings: PropTypes.object,
  configLoadNonce: PropTypes.number,
  managerInstancesRef: PropTypes.object.isRequired, // Typically React.RefObject
};

export default AudioAnalyzer;
```

---
### `src\components\Audio\AudioAnalyzer.test.jsx`
```jsx
import React from 'react';
import { render, act, cleanup } from '@testing-library/react';
import AudioAnalyzer from './AudioAnalyzer'; // Adjust path as necessary

// --- Mocks ---
const mockGetByteFrequencyData = vi.fn();
const mockConnect = vi.fn();
const mockDisconnect = vi.fn();
const mockStop = vi.fn();
const mockResume = vi.fn();
const mockSuspend = vi.fn();
const mockClose = vi.fn();

const mockAnalyserNode = {
  connect: mockConnect,
  disconnect: mockDisconnect,
  getByteFrequencyData: mockGetByteFrequencyData,
  smoothingTimeConstant: 0.8,
  fftSize: 2048,
  minDecibels: -100,
  maxDecibels: -30,
  frequencyBinCount: 1024, 
};

const mockAudioSourceNode = {
  connect: mockConnect,
  disconnect: mockDisconnect,
};

const mockAudioContextInstance = {
  createAnalyser: vi.fn(() => mockAnalyserNode),
  createMediaStreamSource: vi.fn(() => mockAudioSourceNode),
  resume: mockResume,
  suspend: mockSuspend,
  close: mockClose,
  state: 'suspended', 
  sampleRate: 48000,
};

const mockMediaStream = {
  getTracks: vi.fn(() => [{ stop: mockStop, label: 'mockAudioTrack' }]),
};

vi.stubGlobal('AudioContext', vi.fn(() => mockAudioContextInstance));
vi.stubGlobal('webkitAudioContext', vi.fn(() => mockAudioContextInstance));

vi.stubGlobal('navigator', {
  mediaDevices: {
    getUserMedia: vi.fn(),
  },
});

let rafCallback = null;
vi.stubGlobal('requestAnimationFrame', vi.fn((cb) => {
  rafCallback = cb;
  return Date.now(); 
}));
vi.stubGlobal('cancelAnimationFrame', vi.fn());

const mockSetAudioFrequencyFactor = vi.fn();
const mockTriggerBeatPulse = vi.fn();
const mockResetAudioModifications = vi.fn();

const mockManagerInstancesRef = {
  current: {
    '1': {
      setAudioFrequencyFactor: mockSetAudioFrequencyFactor,
      triggerBeatPulse: mockTriggerBeatPulse,
      resetAudioModifications: mockResetAudioModifications,
    },
    '2': {
      setAudioFrequencyFactor: mockSetAudioFrequencyFactor,
      triggerBeatPulse: mockTriggerBeatPulse,
      resetAudioModifications: mockResetAudioModifications,
    },
    '3': {
      setAudioFrequencyFactor: mockSetAudioFrequencyFactor,
      triggerBeatPulse: mockTriggerBeatPulse,
      resetAudioModifications: mockResetAudioModifications,
    },
  },
};

const advanceRAF = () => {
  if (rafCallback) {
    const currentCb = rafCallback;
    rafCallback = null;
    act(() => {
      currentCb(performance.now());
    });
  }
};

describe('AudioAnalyzer', () => {
  let onAudioDataMock;

  beforeEach(() => {
    vi.useFakeTimers();
    onAudioDataMock = vi.fn();
    mockAudioContextInstance.state = 'suspended'; 

    mockGetByteFrequencyData.mockClear();
    mockGetByteFrequencyData.mockImplementation((array) => {
      for (let i = 0; i < array.length; i++) {
        array[i] = (i % 2 === 0) ? 128 : 64;
      }
    });
    mockConnect.mockClear();
    mockDisconnect.mockClear();
    mockStop.mockClear();

    mockResume.mockClear();
    mockResume.mockImplementation(async () => {
        mockAudioContextInstance.state = 'running';
    });

    mockSuspend.mockClear().mockResolvedValue(undefined);
    mockClose.mockClear().mockResolvedValue(undefined);

    mockAudioContextInstance.createAnalyser.mockClear();
    mockAudioContextInstance.createMediaStreamSource.mockClear();
    
    global.navigator.mediaDevices.getUserMedia.mockClear().mockResolvedValue(mockMediaStream);

    rafCallback = null;
    global.requestAnimationFrame.mockClear();
    global.cancelAnimationFrame.mockClear();

    mockSetAudioFrequencyFactor.mockClear();
    mockTriggerBeatPulse.mockClear();
    mockResetAudioModifications.mockClear();
  });

  afterEach(() => {
    cleanup();
    vi.clearAllTimers();
    vi.useRealTimers();
  });

  it('renders null', () => {
    const { container } = render(
      <AudioAnalyzer managerInstancesRef={mockManagerInstancesRef} />
    );
    expect(container.firstChild).toBeNull();
  });

  describe('Activation and Deactivation', () => {
    it('requests microphone access and sets up audio when isActive becomes true', async () => {
      const { rerender } = render(
        <AudioAnalyzer
          isActive={false}
          managerInstancesRef={mockManagerInstancesRef}
          onAudioData={onAudioDataMock}
        />
      );
      expect(navigator.mediaDevices.getUserMedia).not.toHaveBeenCalled();
      rerender(
        <AudioAnalyzer
          isActive={true}
          managerInstancesRef={mockManagerInstancesRef}
          onAudioData={onAudioDataMock}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      expect(navigator.mediaDevices.getUserMedia).toHaveBeenCalledWith({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
        },
        video: false,
      });
      expect(mockAudioContextInstance.createAnalyser).toHaveBeenCalled();
      expect(mockAudioContextInstance.createMediaStreamSource).toHaveBeenCalledWith(mockMediaStream);
      expect(mockAudioSourceNode.connect).toHaveBeenCalledWith(mockAnalyserNode);
      expect(mockResume).toHaveBeenCalled();
      expect(requestAnimationFrame).toHaveBeenCalled();
      advanceRAF();
      expect(mockGetByteFrequencyData).toHaveBeenCalled();
      expect(onAudioDataMock).toHaveBeenCalled();
    });

    it('cleans up audio when isActive becomes false', async () => {
      const { rerender } = render(
        <AudioAnalyzer
          isActive={true}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await Promise.resolve(); 
      });
      expect(requestAnimationFrame).toHaveBeenCalledTimes(1);
      rerender(
        <AudioAnalyzer
          isActive={false}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await vi.runOnlyPendingTimersAsync();
      });
      expect(cancelAnimationFrame).toHaveBeenCalled();
      expect(mockStop).toHaveBeenCalled();
      expect(mockAudioSourceNode.disconnect).toHaveBeenCalled();
      expect(mockSuspend).toHaveBeenCalled();
      expect(mockResetAudioModifications).toHaveBeenCalledTimes(3);
    });

    it('cleans up fully on unmount', async () => {
      const { unmount } = render(
        <AudioAnalyzer
          isActive={true}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      unmount();
      await act(async () => {
        await vi.runOnlyPendingTimersAsync();
      });
      expect(cancelAnimationFrame).toHaveBeenCalled();
      expect(mockStop).toHaveBeenCalled();
      expect(mockAudioSourceNode.disconnect).toHaveBeenCalled();
      expect(mockSuspend).toHaveBeenCalled();
      expect(mockClose).toHaveBeenCalled();
      expect(mockResetAudioModifications).toHaveBeenCalledTimes(3);
    });

    it('handles getUserMedia failure gracefully', async () => {
      const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
      global.navigator.mediaDevices.getUserMedia.mockRejectedValueOnce(new Error('Permission denied'));
      render(
        <AudioAnalyzer
          isActive={true}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      expect(navigator.mediaDevices.getUserMedia).toHaveBeenCalled();
      expect(mockAudioContextInstance.createAnalyser).not.toHaveBeenCalled();
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        expect.stringContaining("[AudioAnalyzer requestMicrophoneAccess] Error accessing microphone:"),
        "Error",
        "Permission denied"
      );
      consoleErrorSpy.mockRestore();
    });
  });

  describe('Audio Processing and Callbacks', () => {
    it('calls onAudioData with processed data and applies to layers', async () => {
      const audioSettings = {
        smoothingFactor: 0.5,
        bassIntensity: 1.2,
        midIntensity: 1.0,
        trebleIntensity: 0.8,
      };
      render(
        <AudioAnalyzer
          isActive={true}
          onAudioData={onAudioDataMock}
          audioSettings={audioSettings}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      expect(mockAnalyserNode.smoothingTimeConstant).toBe(0.5);
      advanceRAF();
      expect(mockGetByteFrequencyData).toHaveBeenCalled();
      expect(onAudioDataMock).toHaveBeenCalledTimes(1);
      const { level, frequencyBands, timestamp } = onAudioDataMock.mock.calls[0][0];
      expect(level).toBeGreaterThanOrEqual(0);
      expect(level).toBeLessThanOrEqual(1);
      expect(frequencyBands).toEqual(
        expect.objectContaining({
          bass: expect.closeTo(0.3780, 4), 
          mid: expect.any(Number),
          treble: expect.any(Number),
        })
      );
      expect(timestamp).toBeCloseTo(Date.now(), -2);
      expect(mockSetAudioFrequencyFactor).toHaveBeenCalledTimes(3);
      // Our calculation: 1 + (0.3780 * 0.8 * 1.2) = 1 + 0.36288 = 1.36288
      // Received: 1.3628990559186638. Adjusted closeTo for this.
      expect(mockSetAudioFrequencyFactor).toHaveBeenNthCalledWith(1, expect.closeTo(1.3629, 4));

      mockGetByteFrequencyData.mockImplementationOnce((array) => {
         for (let i = 0; i < array.length; i++) { array[i] = 200; }
      });
      advanceRAF();
      expect(mockTriggerBeatPulse).toHaveBeenCalled();
    });
  });

  describe('Prop Changes', () => {
    it('updates AnalyserNode smoothingTimeConstant when audioSettings prop changes', async () => {
      const initialAudioSettings = { smoothingFactor: 0.6 };
      const { rerender } = render(
        <AudioAnalyzer
          isActive={true}
          audioSettings={initialAudioSettings}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      expect(mockAnalyserNode.smoothingTimeConstant).toBe(0.6);
      const newAudioSettings = { smoothingFactor: 0.3 };
      rerender(
        <AudioAnalyzer
          isActive={true}
          audioSettings={newAudioSettings}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      expect(mockAnalyserNode.smoothingTimeConstant).toBe(0.3);
    });

    it('updates baseLayerValues and enters transition on configLoadNonce change', async () => {
      const layerConfigs1 = { '1': { size: 1.5 }, '2': { size: 0.8 } };
      const { rerender } = render(
        <AudioAnalyzer
          isActive={false}
          layerConfigs={layerConfigs1}
          configLoadNonce={1}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      const layerConfigs2 = { '1': { size: 2.0 }, '3': { size: 1.2 } };
      rerender(
        <AudioAnalyzer
          isActive={false}
          layerConfigs={layerConfigs2}
          configLoadNonce={2}
          managerInstancesRef={mockManagerInstancesRef}
        />
      );
      rerender(
        <AudioAnalyzer
          isActive={true}
          layerConfigs={layerConfigs2}
          configLoadNonce={2}
          managerInstancesRef={mockManagerInstancesRef}
          onAudioData={onAudioDataMock}
          audioSettings={{ bassIntensity: 1.0, midIntensity: 1.0, trebleIntensity: 1.0 }}
        />
      );
      await act(async () => {
        await Promise.resolve();
      });
      // During transition: smoothedBass = 0 * 0.8 + 0.3780 * 0.2 = 0.0756
      // Expected bass factor = 1 + (0.0756 * 0.8 * 1.0 * 0.2) = 1 + 0.012096 = 1.012096
      advanceRAF();
      expect(onAudioDataMock).toHaveBeenCalledTimes(1);
      const { frequencyBands: bandsTransition } = onAudioDataMock.mock.calls[0][0];
      expect(bandsTransition.bass).toBeCloseTo(0.0756, 4);
      expect(mockSetAudioFrequencyFactor).toHaveBeenNthCalledWith(1, expect.closeTo(1.0121, 4));

      act(() => {
        vi.advanceTimersByTime(1000);
      });

      // After transition: rawBass = 0.3780
      // Expected bass factor = 1 + (0.3780 * 0.8 * 1.0 * 1.0) = 1 + 0.3024 = 1.3024
      advanceRAF();
      expect(onAudioDataMock).toHaveBeenCalledTimes(2);
      const { frequencyBands: bandsAfter } = onAudioDataMock.mock.calls[1][0];
      expect(bandsAfter.bass).toBeCloseTo(0.3780, 4);
      expect(mockSetAudioFrequencyFactor).toHaveBeenNthCalledWith(4, expect.closeTo(1.3024, 4));
    });
  });
});
```

---
### `src\components\Audio\AudioControlPanel.jsx`
```jsx
// src/components/Audio/AudioControlPanel.jsx
import React, { useState, useEffect, useCallback } from "react";
import PropTypes from "prop-types";

import Panel from "../Panels/Panel"; // Local component

import "./AudioStyles/AudioControlPanel.css"; // Local styles

// Tunable parameters for meter display intensity (visual only, does not affect actual analysis)
const DISPLAY_LEVEL_AMPLIFICATION = 1.8;
const DISPLAY_TREBLE_AMPLIFICATION = 2.5;
const DEFAULT_SMOOTHING = 0.6; // Define locally for this component's use

/**
 * @typedef {object} AudioDevice
 * @property {string} deviceId - Unique identifier for the audio device.
 * @property {string} label - Human-readable label for the device.
 * @property {string} kind - Type of device (e.g., "audioinput").
 */

/**
 * @typedef {object} AudioControlPanelProps
 * @property {() => void} onClose - Callback function to close the panel.
 * @property {boolean} isAudioActive - Whether audio analysis is currently active.
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setIsAudioActive - Function to toggle the audio analysis state.
 * @property {import('../../hooks/useAudioVisualizer').AudioVisualizerSettings} audioSettings - Current settings for audio reactivity (intensities, smoothing factor).
 * @property {React.Dispatch<React.SetStateAction<import('../../hooks/useAudioVisualizer').AudioVisualizerSettings>>} setAudioSettings - Function to update audio settings.
 * @property {import('../../hooks/useAudioVisualizer').RawAudioAnalyzerData} analyzerData - Data from the audio analyzer (level, frequency bands).
 */

/**
 * AudioControlPanel provides UI controls for managing audio reactivity.
 * It allows users to toggle audio analysis, view detected audio input devices (display-only),
 * observe real-time audio levels (overall, bass, mid, treble), and adjust
 * parameters like intensity of audio impact on layers and the smoothing algorithm.
 *
 * @param {AudioControlPanelProps} props - Component props.
 * @returns {JSX.Element} The rendered AudioControlPanel component.
 */
const AudioControlPanel = React.memo(({
  onClose,
  isAudioActive,
  setIsAudioActive,
  audioSettings,
  setAudioSettings,
  analyzerData,
}) => {
  /** @type {[AudioDevice[], React.Dispatch<React.SetStateAction<AudioDevice[]>>]} */
  const [audioDevices, setAudioDevices] = useState([]);

  useEffect(() => {
    let isMounted = true;
    if (isAudioActive && navigator.mediaDevices && typeof navigator.mediaDevices.enumerateDevices === "function") {
      navigator.mediaDevices.enumerateDevices()
        .then((devices) => {
          if (!isMounted) return;
          const audioInputs = devices.filter((d) => d.kind === "audioinput");
          setAudioDevices(audioInputs);
        })
        .catch((err) => {
          if (import.meta.env.DEV) {
            console.warn("[AudioControlPanel] Error enumerating audio devices:", err);
          }
        });
    } else if (!isAudioActive) {
        setAudioDevices([]);
    }
    return () => { isMounted = false; };
  }, [isAudioActive]);

  const toggleAnalyzer = useCallback(() => {
    if (typeof setIsAudioActive === 'function') {
        setIsAudioActive((prev) => !prev);
    }
  }, [setIsAudioActive]);

  const handleSettingChange = useCallback((setting, value) => {
    if (typeof setAudioSettings === 'function') {
        setAudioSettings((prev) => ({
          ...prev,
          [setting]: parseFloat(value),
        }));
    }
  }, [setAudioSettings]);

  const handleStopListening = useCallback(() => {
    if (typeof setIsAudioActive === 'function') {
        setIsAudioActive(false);
    }
  }, [setIsAudioActive]);

  const displayLevel = Math.min(1, (analyzerData?.level || 0) * DISPLAY_LEVEL_AMPLIFICATION);
  const displayBass = analyzerData?.frequencyBands?.bass || 0;
  const displayMid = analyzerData?.frequencyBands?.mid || 0;
  const displayTreble = Math.min(1, (analyzerData?.frequencyBands?.treble || 0) * DISPLAY_TREBLE_AMPLIFICATION);

  const currentSmoothing = audioSettings?.smoothingFactor ?? DEFAULT_SMOOTHING;

  return (
    <Panel
      title="AUDIO VISUALIZER"
      onClose={onClose}
      className="panel-from-toolbar audio-control-panel"
    >
      <div className="audio-control-content">
        <div className="audio-toggle-section section-box">
          <div className="toggle-description">
            <h3>Audio Responsive Layers</h3>
            <p>
              Make the visual layers respond to audio playing through your
              device. Requires microphone access.
            </p>
          </div>
          <div className="toggle-switch-wrapper">
            <label className="toggle-switch" htmlFor="audio-active-toggle" aria-label="Toggle Audio Reactivity">
              <input type="checkbox" id="audio-active-toggle" checked={isAudioActive} onChange={toggleAnalyzer} />
              <span className="toggle-slider"></span>
            </label>
            <span className="toggle-state" aria-live="polite">{isAudioActive ? "ON" : "OFF"}</span>
          </div>
        </div>

        {isAudioActive && (
          <>
            <div className="device-selector-info section-box">
              <label htmlFor="audio-device-display">Detected Audio Inputs:</label>
              <select id="audio-device-display" disabled className="device-select custom-select">
                <option value="">System Default / Currently Granted Device</option>
                {audioDevices.map((device) => (
                  <option key={device.deviceId} value={device.deviceId}>
                    {device.label || `Input ${device.deviceId.substring(0, 8)}...`}
                  </option>
                ))}
              </select>
              <p className="device-note">Note: Actual input depends on browser permissions & system settings. This list is informational.</p>
            </div>

            <div className="audio-meters-display section-box">
              <div className="meters-header">
                <div className="listening-indicator">
                  <div className="signal-waves">
                    <span className="wave wave-1"></span>
                    <span className="wave wave-2"></span>
                    <span className="wave wave-3"></span>
                  </div>
                  <span>Listening to Audio</span>
                </div>
              </div>

              <div className="level-meter">
                <div className="meter-label">Level</div>
                <div className="meter-bar">
                  <div
                    className="meter-fill level"
                    style={{ width: `${Math.min(100, displayLevel * 100)}%` }}
                    aria-valuenow={Math.round(displayLevel * 100)}
                    aria-valuemin={0}
                    aria-valuemax={100}
                    role="meter"
                  ></div>
                </div>
              </div>

              <div className="frequency-meters">
                <div className="frequency-meter">
                  <div className="meter-label">Bass</div>
                  <div className="meter-bar">
                    <div
                      className="meter-fill bass"
                      style={{ width: `${Math.min(100, displayBass * 100)}%` }}
                      aria-valuenow={Math.round(displayBass * 100)} aria-valuemin={0} aria-valuemax={100} role="meter"
                    ></div>
                  </div>
                </div>
                <div className="frequency-meter">
                  <div className="meter-label">Mid</div>
                  <div className="meter-bar">
                    <div
                      className="meter-fill mid"
                      style={{ width: `${Math.min(100, displayMid * 100)}%` }}
                      aria-valuenow={Math.round(displayMid * 100)} aria-valuemin={0} aria-valuemax={100} role="meter"
                    ></div>
                  </div>
                </div>
                <div className="frequency-meter">
                  <div className="meter-label">Treble</div>
                  <div className="meter-bar">
                    <div
                      className="meter-fill treble"
                      style={{ width: `${Math.min(100, displayTreble * 100)}%` }}
                      aria-valuenow={Math.round(displayTreble * 100)} aria-valuemin={0} aria-valuemax={100} role="meter"
                    ></div>
                  </div>
                </div>
              </div>
               <button
                 className="stop-listening-button btn btn-secondary"
                 onClick={handleStopListening}
                 aria-label="Stop listening to audio"
               >
                 Stop Listening
               </button>
            </div>

            <div className="audio-settings-section section-box">
              <h4 className="config-section-title">Audio Reactivity Settings</h4>
              <div className="slider-group">
                <div className="slider-container">
                  <div className="slider-header">
                    <span className="slider-label">Bass Impact (L1 Size)</span>
                    <span className="slider-value">{(audioSettings?.bassIntensity || 1.0).toFixed(1)}x</span>
                  </div>
                  <input type="range" min="0.1" max="3.0" step="0.1" value={audioSettings?.bassIntensity || 1.0} onChange={(e) => handleSettingChange("bassIntensity", e.target.value)} className="bass-slider intensity-slider horizontal-slider" aria-label="Bass impact intensity"/>
                </div>
                <div className="slider-container">
                  <div className="slider-header">
                    <span className="slider-label">Mid Impact (L2 Size)</span>
                    <span className="slider-value">{(audioSettings?.midIntensity || 1.0).toFixed(1)}x</span>
                  </div>
                  <input type="range" min="0.1" max="3.0" step="0.1" value={audioSettings?.midIntensity || 1.0} onChange={(e) => handleSettingChange("midIntensity", e.target.value)} className="mid-slider intensity-slider horizontal-slider" aria-label="Mid-range impact intensity"/>
                </div>
                <div className="slider-container">
                  <div className="slider-header">
                    <span className="slider-label">Treble Impact (L3 Size)</span>
                    <span className="slider-value">{(audioSettings?.trebleIntensity || 1.0).toFixed(1)}x</span>
                  </div>
                  <input type="range" min="0.1" max="3.0" step="0.1" value={audioSettings?.trebleIntensity || 1.0} onChange={(e) => handleSettingChange("trebleIntensity", e.target.value)} className="treble-slider intensity-slider horizontal-slider" aria-label="Treble impact intensity"/>
                </div>
                <div className="slider-container">
                  <div className="slider-header">
                    <span className="slider-label">Smoothing Algorithm</span>
                    <span className="slider-value">{currentSmoothing.toFixed(2)}</span>
                  </div>
                  <input
                    type="range"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    value={currentSmoothing}
                    onChange={(e) => handleSettingChange("smoothingFactor", e.target.value)}
                    className="smoothness-slider intensity-slider horizontal-slider"
                    title="Adjust response smoothness (Left=Sharp/Sawtooth, Right=Smooth/Sine)"
                    aria-label="Audio response smoothing factor"
                  />
                   <div className="slider-labels">
                       <span>Sharp</span>
                       <span>Smooth</span>
                   </div>
                </div>
              </div>
            </div>
          </>
        )}

        {!isAudioActive && (
          <div className="inactive-state section-box">
            <div className="inactive-description">
              <div className="feature-description">
                <p>
                  Enable "Audio Responsive Layers" to make your visual configuration respond to music and onboard sound.
                </p>
                <ul>
                  <li>Bass influences the bottom layer's size.</li>
                  <li>Mid-range frequencies control the middle layer's size.</li>
                  <li>Treble affects the top layer's size.</li>
                  <li>A custom algorithm blends these influences for dynamic visuals.</li>
                </ul>
              </div>
              <div className="usage-note">
                <strong>Note:</strong> RADAR makes use of your microphone access
                to listen to the audio playing through your device. This is
                required for the visualizer to work. Please ensure you have
                granted microphone access to your browser for this site.
              </div>
            </div>
          </div>
        )}
      </div>
    </Panel>
  );
});

AudioControlPanel.displayName = 'AudioControlPanel';

AudioControlPanel.propTypes = {
  onClose: PropTypes.func.isRequired,
  isAudioActive: PropTypes.bool.isRequired,
  setIsAudioActive: PropTypes.func.isRequired,
  audioSettings: PropTypes.shape({
      bassIntensity: PropTypes.number,
      midIntensity: PropTypes.number,
      trebleIntensity: PropTypes.number,
      smoothingFactor: PropTypes.number,
  }),
  setAudioSettings: PropTypes.func,
  analyzerData: PropTypes.shape({
      level: PropTypes.number,
      frequencyBands: PropTypes.shape({
          bass: PropTypes.number,
          mid: PropTypes.number,
          treble: PropTypes.number,
      }),
  }),
};

AudioControlPanel.defaultProps = {
  audioSettings: {
    bassIntensity: 1.0,
    midIntensity: 1.0,
    trebleIntensity: 1.0,
    smoothingFactor: DEFAULT_SMOOTHING, // Use the defined constant
  },
  setAudioSettings: () => {
    if (import.meta.env.DEV) console.warn("setAudioSettings called on default AudioControlPanel prop");
  },
  analyzerData: { level: 0, frequencyBands: { bass: 0, mid: 0, treble: 0 } },
};

export default AudioControlPanel;
```

---
### `src\components\Audio\AudioControlPanel.test.jsx`
```jsx
import React from 'react';
import { render, screen, fireEvent, act, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import AudioControlPanel from './AudioControlPanel';

vi.mock('../Panels/Panel', () => ({
  __esModule: true,
  default: ({ title, onClose, className, children }) => (
    <div data-testid="mock-panel" className={className}>
      <h2 data-testid="panel-title">{title}</h2>
      <button data-testid="panel-close-button" onClick={onClose}>Close Panel</button>
      {children}
    </div>
  ),
}));

const mockEnumerateDevices = vi.fn();
vi.stubGlobal('navigator', {
  mediaDevices: {
    enumerateDevices: mockEnumerateDevices,
  },
});

describe('AudioControlPanel', () => {
  let mockOnClose;
  let mockSetIsAudioActive;
  let mockSetAudioSettings;
  let baseProps; // Renamed from defaultProps to avoid confusion with component's defaultProps

  const mockAudioDevicesList = [ // Renamed for clarity
    { deviceId: 'dev1', label: 'Microphone 1', kind: 'audioinput' },
    { deviceId: 'dev2', label: 'Microphone 2', kind: 'audioinput' },
    { deviceId: 'dev3', label: 'Webcam Mic', kind: 'audioinput' },
    { deviceId: 'video1', label: 'Webcam Video', kind: 'videoinput' },
  ];

  beforeEach(() => {
    mockOnClose = vi.fn();
    mockSetIsAudioActive = vi.fn();
    mockSetAudioSettings = vi.fn();
    mockEnumerateDevices.mockClear();

    baseProps = {
      onClose: mockOnClose,
      isAudioActive: false,
      setIsAudioActive: mockSetIsAudioActive,
      // For tests checking defaults, audioSettings & analyzerData will be omitted
      // For other tests, they will be spread in or overridden
    };
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  const getFullProps = (overrides = {}) => ({
    ...baseProps,
    audioSettings: {
      bassIntensity: 1.0,
      midIntensity: 1.2,
      trebleIntensity: 0.8,
      smoothingFactor: 0.6,
      ...(overrides.audioSettings || {}),
    },
    setAudioSettings: mockSetAudioSettings,
    analyzerData: {
      level: 0,
      frequencyBands: { bass: 0, mid: 0, treble: 0 },
      ...(overrides.analyzerData || {}),
    },
    ...overrides, // General overrides for isAudioActive, etc.
  });


  test('renders correctly when audio is inactive', () => {
    render(<AudioControlPanel {...getFullProps({ isAudioActive: false })} />);
    // ... assertions remain the same
    expect(screen.getByTestId('panel-title')).toHaveTextContent('AUDIO VISUALIZER');
    expect(screen.getByRole('heading', { name: /Audio Responsive Layers/i })).toBeInTheDocument();
    expect(screen.getByRole('checkbox', { name: /Toggle Audio Reactivity/i })).not.toBeChecked();
    expect(screen.getByText('OFF')).toBeInTheDocument();
    expect(screen.getByText(/Enable "Audio Responsive Layers" to make your visual configuration respond/i)).toBeInTheDocument();
    expect(screen.queryByLabelText(/Detected Audio Inputs:/i)).not.toBeInTheDocument();
    expect(screen.queryByText(/Listening to Audio/i)).not.toBeInTheDocument();
    expect(screen.queryByRole('heading', {name: /Audio Reactivity Settings/i})).not.toBeInTheDocument();
  });

  test('calls onClose when panel close button is clicked', () => {
    render(<AudioControlPanel {...getFullProps()} />);
    fireEvent.click(screen.getByTestId('panel-close-button'));
    expect(mockOnClose).toHaveBeenCalledTimes(1);
  });

  test('toggles audio active state when switch is clicked', () => {
    render(<AudioControlPanel {...getFullProps()} />);
    const toggle = screen.getByRole('checkbox', { name: /Toggle Audio Reactivity/i });
    fireEvent.click(toggle);
    expect(mockSetIsAudioActive).toHaveBeenCalledTimes(1);
  });

  describe('when audio is active', () => {
    beforeEach(() => {
      mockEnumerateDevices.mockResolvedValue(mockAudioDevicesList);
    });

    test('renders correctly and fetches devices', async () => {
      render(<AudioControlPanel {...getFullProps({ isAudioActive: true })} />);
      expect(screen.getByRole('checkbox', { name: /Toggle Audio Reactivity/i })).toBeChecked();
      expect(screen.getByText('ON')).toBeInTheDocument();
      expect(screen.getByLabelText(/Detected Audio Inputs:/i)).toBeInTheDocument();
      expect(screen.getByText(/Listening to Audio/i)).toBeInTheDocument();
      expect(screen.getByRole('heading', {name: /Audio Reactivity Settings/i})).toBeInTheDocument();
      expect(screen.queryByText(/Enable "Audio Responsive Layers" to make your visual configuration respond/i)).not.toBeInTheDocument();
      expect(mockEnumerateDevices).toHaveBeenCalledTimes(1);
      expect(await screen.findByRole('option', { name: /Microphone 1/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /Microphone 2/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /Webcam Mic/i })).toBeInTheDocument();
      expect(screen.queryByRole('option', { name: /Webcam Video/i })).not.toBeInTheDocument();
    });

    test('handles error during device enumeration', async () => {
      const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
      mockEnumerateDevices.mockRejectedValueOnce(new Error('Device enumeration failed'));
      render(<AudioControlPanel {...getFullProps({ isAudioActive: true })} />);
      await waitFor(() => expect(consoleWarnSpy).toHaveBeenCalledWith(
        expect.stringContaining("[AudioControlPanel] Error enumerating audio devices:"),
        expect.any(Error)
      ));
      expect(screen.getByLabelText(/Detected Audio Inputs:/i).querySelectorAll('option').length).toBe(1);
      consoleWarnSpy.mockRestore();
    });

    test('clears devices when audio is toggled off', async () => {
        const { rerender } = render(<AudioControlPanel {...getFullProps({ isAudioActive: true })} />);
        expect(await screen.findByRole('option', { name: /Microphone 1/i })).toBeInTheDocument();
        rerender(<AudioControlPanel {...getFullProps({ isAudioActive: false })} />);
        expect(screen.queryByLabelText(/Detected Audio Inputs:/i)).not.toBeInTheDocument();
    });

    test('displays audio meters based on analyzerData', () => {
      const testAnalyzerData = {
        level: 0.5,
        frequencyBands: { bass: 0.8, mid: 0.4, treble: 0.3 },
      };
      render(<AudioControlPanel {...getFullProps({ isAudioActive: true, analyzerData: testAnalyzerData })} />);
      const levelMeter = screen.getAllByRole('meter').find(m => m.classList.contains('level'));
      const bassMeter = screen.getAllByRole('meter').find(m => m.classList.contains('bass'));
      const midMeter = screen.getAllByRole('meter').find(m => m.classList.contains('mid'));
      const trebleMeter = screen.getAllByRole('meter').find(m => m.classList.contains('treble'));
      expect(levelMeter).toHaveStyle('width: 90%');
      expect(bassMeter).toHaveStyle('width: 80%');
      expect(midMeter).toHaveStyle('width: 40%');
      expect(trebleMeter).toHaveStyle('width: 75%');
    });

    test('updates settings when sliders are changed', async () => {
      const initialSettings = {
        bassIntensity: 1.0, midIntensity: 1.2, trebleIntensity: 0.8, smoothingFactor: 0.6,
      };
      render(<AudioControlPanel {...getFullProps({ isAudioActive: true, audioSettings: initialSettings })} />);
      const bassSlider = screen.getByRole('slider', { name: /Bass impact intensity/i });
      const smoothingSlider = screen.getByRole('slider', { name: /Audio response smoothing factor/i });
      fireEvent.change(bassSlider, { target: { value: '2.5' } });
      expect(mockSetAudioSettings).toHaveBeenCalledWith(expect.any(Function));
      let lastCallUpdater = mockSetAudioSettings.mock.calls.pop()[0];
      expect(lastCallUpdater(initialSettings)).toEqual({ ...initialSettings, bassIntensity: 2.5 });

      fireEvent.change(smoothingSlider, { target: { value: '0.25' } });
      expect(mockSetAudioSettings).toHaveBeenCalledWith(expect.any(Function));
      lastCallUpdater = mockSetAudioSettings.mock.calls.pop()[0];
      expect(lastCallUpdater(initialSettings)).toEqual({ ...initialSettings, smoothingFactor: 0.25 });
    });
    
    test('calls setIsAudioActive(false) when "Stop Listening" button is clicked', () => {
        render(<AudioControlPanel {...getFullProps({ isAudioActive: true })} />);
        const stopButton = screen.getByRole('button', { name: /Stop listening to audio/i });
        fireEvent.click(stopButton);
        expect(mockSetIsAudioActive).toHaveBeenCalledWith(false);
    });
  });

  test('uses default smoothingFactor if not in audioSettings provided as prop', () => {
    // Simulating audioSettings prop being passed but without smoothingFactor
    const partialAudioSettings = { bassIntensity: 1.5 };
    render(<AudioControlPanel {...getFullProps({ isAudioActive: true, audioSettings: partialAudioSettings })} />);
    const smoothingSlider = screen.getByRole('slider', { name: /Audio response smoothing factor/i });
    // The component's default for smoothingFactor (0.6) should merge with provided partialAudioSettings
    expect(smoothingSlider.value).toBe("0.6"); 
    expect(screen.getByText("0.60")).toBeInTheDocument();
  });

  test('handles missing audioSettings and analyzerData gracefully with JS defaults', () => {
    // Here, audioSettings and analyzerData props are NOT passed to AudioControlPanel
    // So, it should use its internal JS default parameters
    render(
      <AudioControlPanel
        onClose={mockOnClose}
        isAudioActive={true} // Activate to show settings and meters
        setIsAudioActive={mockSetIsAudioActive}
        // audioSettings prop is omitted
        // setAudioSettings prop is omitted (will use default function from component)
        // analyzerData prop is omitted
      />
    );
    const bassSlider = screen.getByRole('slider', { name: /Bass impact intensity/i });
    expect(bassSlider.value).toBe("1"); // Corrected: 1.0 becomes "1"

    const levelMeter = screen.getAllByRole('meter').find(m => m.classList.contains('level'));
    expect(levelMeter).toHaveStyle('width: 0%');
  });
});
```

---
### `src\components\Audio\AudioStatusIcon.jsx`
```jsx
// src/components/Audio/AudioStatusIcon.jsx
import React from "react";
import PropTypes from "prop-types";

import "./AudioStyles/AudioStatusIcon.css"; // Local styles

/**
 * @typedef {object} AudioStatusIconProps
 * @property {boolean} [isActive=false] - If true, the icon is displayed and indicates that audio visualization is active.
 * @property {() => void} [onClick] - Optional callback function invoked when the icon is clicked. Typically used to open the audio control panel.
 */

/**
 * AudioStatusIcon: A small visual indicator, usually placed in a corner or toolbar,
 * to show that audio visualization/reactivity is currently active.
 * It only renders when `isActive` is true. Clicking the icon can trigger an action,
 * such as opening the audio control panel.
 *
 * @param {AudioStatusIconProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered AudioStatusIcon button, or null if `isActive` is false.
 */
const AudioStatusIcon = ({ isActive = false, onClick }) => {
  // If audio visualization is not active, do not render the icon.
  if (!isActive) {
    return null;
  }

  return (
    <button
      className={`audio-status-icon ${isActive ? "active" : ""}`} // 'active' class can be used for specific styling when active
      onClick={onClick}
      aria-label="Audio Visualizer Active" // Accessibility: Label for screen readers
      title="Audio Visualizer is Active - Click to open settings" // Tooltip for mouse users
    >
      <div className="audio-icon"> {/* Container for the visual wave elements */}
        <div className="wave-container">
          {/* These spans are typically styled with CSS to create the animated wave effect */}
          <span className="audio-wave"></span>
          <span className="audio-wave"></span>
          <span className="audio-wave"></span>
        </div>
      </div>
    </button>
  );
};

AudioStatusIcon.propTypes = {
  /** If true, the icon is displayed and indicates that audio visualization is active. */
  isActive: PropTypes.bool,
  /** Optional callback function invoked when the icon is clicked. */
  onClick: PropTypes.func,
};

AudioStatusIcon.defaultProps = {
  isActive: false,
  onClick: () => {}, // Default to a no-op function to prevent errors if not provided
};

// Default export is standard for React components.
// React.memo can be considered if onClick is stable and isActive changes don't always warrant re-render,
// but for a small component like this, it's often not critical.
export default AudioStatusIcon;
```

---
### `src\components\Audio\AudioStatusIcon.test.jsx`
```jsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import AudioStatusIcon from './AudioStatusIcon'; // Adjust path if necessary

describe('AudioStatusIcon', () => {
  it('should not render when isActive is false (default behavior)', () => {
    // Arrange: Render with default isActive (which is false)
    render(<AudioStatusIcon />);

    // Act & Assert
    // queryBy* returns null if not found, good for asserting absence
    const button = screen.queryByRole('button', { name: /Audio Visualizer Active/i });
    expect(button).not.toBeInTheDocument();
  });

  it('should not render when isActive is explicitly false', () => {
    // Arrange: Render with isActive explicitly false
    render(<AudioStatusIcon isActive={false} />);

    // Act & Assert
    const button = screen.queryByRole('button', { name: /Audio Visualizer Active/i });
    expect(button).not.toBeInTheDocument();
  });

  it('should render when isActive is true', () => {
    // Arrange: Render with isActive true
    render(<AudioStatusIcon isActive={true} />);

    // Act & Assert
    // getBy* throws an error if not found, good for asserting presence
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });
    expect(button).toBeInTheDocument();
  });

  it('should have the "active" class when isActive is true', () => {
    // Arrange
    render(<AudioStatusIcon isActive={true} />);
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });

    // Assert
    expect(button).toHaveClass('active');
  });

  it('should call onClick prop when clicked if isActive is true', () => {
    // Arrange
    const handleClickMock = vi.fn(); // Vitest's mock function
    render(<AudioStatusIcon isActive={true} onClick={handleClickMock} />);
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });

    // Act
    fireEvent.click(button);

    // Assert
    expect(handleClickMock).toHaveBeenCalledTimes(1);
  });

  it('should have correct ARIA label and title when rendered', () => {
    // Arrange
    render(<AudioStatusIcon isActive={true} />);
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });

    // Assert
    expect(button).toHaveAttribute('aria-label', 'Audio Visualizer Active');
    expect(button).toHaveAttribute('title', 'Audio Visualizer is Active - Click to open settings');
  });

  it('should render the inner wave elements when active', () => {
    // Arrange
    render(<AudioStatusIcon isActive={true} />);
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });

    // Act
    const waveContainer = button.querySelector('.wave-container');
    const waves = button.querySelectorAll('.audio-wave');

    // Assert
    expect(waveContainer).toBeInTheDocument();
    expect(waves.length).toBe(3); // Assuming 3 wave spans as per your CSS
  });

  it('should use default onClick prop (no-op) if none is provided and not throw error', () => {
    // Arrange
    render(<AudioStatusIcon isActive={true} />); // No onClick prop passed
    const button = screen.getByRole('button', { name: /Audio Visualizer Active/i });

    // Act & Assert
    // We expect no error to be thrown when clicking
    expect(() => fireEvent.click(button)).not.toThrow();
  });
});
```

---
### `src\components\Audio\AudioStyles\AudioAnalyzer.css`
```css
/* Styles removed as AudioAnalyzer.jsx no longer renders UI elements. */
/* UI elements are now handled in AudioControlPanel.jsx and its corresponding CSS. */

.audio-analyzer {
  padding: 10px;
  border-radius: 6px;
  background-color: rgba(0, 0, 0, 0.05);
  margin-bottom: 10px;
}

.mic-permission-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 15px;
  border: 1px solid rgba(0, 200, 200, 0.3);
  border-radius: 6px;
  background-color: rgba(0, 0, 0, 0.2);
  margin: 10px 0;
}

.mic-permission-heading {
  font-size: 16px;
  font-weight: bold;
  color: #00ced1;
  margin-bottom: 10px;
}

.mic-permission-button {
  padding: 10px 20px;
  background-color: #00ced1;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  margin: 10px 0;
  width: 100%;
  transition: background-color 0.2s;
}

.mic-permission-button:hover {
  background-color: #00b8bb;
}

.mic-permission-text {
  font-size: 14px;
  color: #ccc;
  text-align: center;
  margin-bottom: 10px;
}

.device-selector {
  width: 100%;
  margin: 10px 0;
  display: flex;
  flex-direction: column;
}

.device-selector label {
  color: #ccc;
  margin-bottom: 5px;
  font-size: 14px;
}

.device-select {
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(0, 200, 200, 0.3);
  color: white;
  padding: 8px;
  border-radius: 4px;
  width: 100%;
  margin-bottom: 10px;
}

.audio-meters {
  width: 100%;
}

.meters-header {
  margin-bottom: 10px;
}

.listening-indicator {
  display: flex;
  align-items: center;
  color: #00ced1;
}

.signal-waves {
  display: flex;
  align-items: center;
  margin-right: 10px;
}

.wave {
  display: inline-block;
  width: 3px;
  background-color: #00ced1;
  margin-right: 2px;
  animation: wave 1s infinite ease-in-out;
}

.wave-1 {
  height: 10px;
  animation-delay: 0s;
}
.wave-2 {
  height: 16px;
  animation-delay: 0.2s;
}
.wave-3 {
  height: 12px;
  animation-delay: 0.4s;
}

@keyframes wave {
  0%,
  100% {
    transform: scaleY(1);
  }
  50% {
    transform: scaleY(0.5);
  }
}

.meter-bar {
  height: 15px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  margin-bottom: 12px;
  overflow: hidden;
}

.meter-fill {
  height: 100%;
  background-color: #00ced1;
  transition: width 0.1s ease;
}

.meter-fill.bass {
  background-color: #e53935;
}
.meter-fill.mid {
  background-color: #ffa000;
}
.meter-fill.treble {
  background-color: #00ced1;
}

.meter-label {
  font-size: 12px;
  margin-bottom: 5px;
  color: #ccc;
}

.stop-listening-button {
  padding: 8px 16px;
  background-color: #f44336;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 10px;
}

.stop-listening-button:hover {
  background-color: #d32f2f;
}

.analyzer-error {
  margin-top: 10px;
  padding: 10px;
  background-color: rgba(244, 67, 54, 0.1);
  border-left: 4px solid #f44336;
  color: #f44336;
  border-radius: 3px;
}

.retry-button {
  padding: 5px 10px;
  background-color: #f44336;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  margin-top: 5px;
  margin-left: 10px;
}

.analyzer-inactive {
  color: #999;
  text-align: center;
  padding: 10px;
}

```

---
### `src\components\Audio\AudioStyles\AudioControlPanel.css`
```css
@import "../../../styles/variables.css";

.audio-control-panel .panel-content {
  /* Optional: Override default panel padding if needed */
}

.audio-control-content {
  padding: var(--space-sm);
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.audio-toggle-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--color-primary-a05);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  border: 1px solid var(--color-primary-a15);
}

.toggle-description h3 {
  font-size: var(--font-size-md);
  margin-bottom: var(--space-xs);
  color: var(--color-primary);
}

.toggle-description p {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  margin: 0;
  max-width: 300px; /* Prevent text from pushing toggle too far */
}

.toggle-switch-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-xxs);
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--color-bg-light);
  border: 1px solid var(--color-primary-a30);
  transition: var(--transition-normal);
  border-radius: 34px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 2px;
  bottom: 2px;
  background-color: var(--color-text);
  transition: var(--transition-normal);
  border-radius: 50%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

input:checked + .toggle-slider {
  background-color: var(--color-primary-a30);
  border-color: var(--color-primary-a50);
}

input:checked + .toggle-slider:before {
  transform: translateX(24px);
  background-color: var(--color-primary);
}

.toggle-state {
  font-size: var(--font-size-xs);
  color: var(--color-primary);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.device-selector-info {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
  padding: var(--space-sm);
  background: var(--color-bg-inset);
  border-radius: var(--radius-sm);
  border: 1px solid var(--color-border-subtle);
}

.device-selector-info label {
  font-size: var(--font-size-xs);
  font-weight: 500;
  color: var(--color-text-muted);
}

.device-select {
  width: 100%;
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-sm);
  border: 1px solid var(--color-border);
  background-color: var(--color-bg-light);
  color: var(--color-text-muted);
  font-size: var(--font-size-sm);
  cursor: not-allowed;
  opacity: 0.7;
}

.device-note {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  margin: 0;
  line-height: 1.4;
}

.audio-meters-display {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
  padding: var(--space-sm);
  background: var(--color-bg-inset);
  border-radius: var(--radius-sm);
  border: 1px solid var(--color-border-subtle);
}

.meters-header {
  margin-bottom: var(--space-xs);
}

.listening-indicator {
  display: flex;
  align-items: center;
  color: var(--color-primary);
}

.signal-waves {
  display: flex;
  align-items: flex-end;
  margin-right: var(--space-sm);
  height: 16px;
}

.wave {
  display: inline-block;
  width: 3px;
  background-color: var(--color-primary);
  margin-right: 2px;
  animation: wave 1s infinite ease-in-out;
  border-radius: 1px;
}

.wave-1 { height: 60%; animation-delay: 0s; }
.wave-2 { height: 100%; animation-delay: 0.2s; }
.wave-3 { height: 80%; animation-delay: 0.4s; }

@keyframes wave {
  0%, 100% { transform: scaleY(0.5); opacity: 0.7; }
  50% { transform: scaleY(1); opacity: 1; }
}

.level-meter {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

/* --- THIS RULE IS KEY FOR THE LEVEL METER BAR --- */
.level-meter .meter-bar {
  flex-grow: 1; 
  min-width: 50px; 
}
/* --------------------------------------------- */

.frequency-meters {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-md);
}

.frequency-meter {
  display: flex;
  flex-direction: column;
  gap: var(--space-xxs);
}

.meter-label {
  font-size: var(--font-size-xs);
  font-weight: 500;
  color: var(--color-text-muted);
  text-align: left;
  text-transform: uppercase;
}

.meter-bar {
  width: 100%; 
  height: 10px;
  background-color: var(--color-primary-a05);
  border-radius: var(--radius-xs);
  overflow: hidden;
  border: 1px solid var(--color-primary-a15);
  position: relative; 
}

.meter-fill {
  height: 100%;
  background-color: var(--color-primary);
  border-radius: var(--radius-xs);
  transition: width 0.05s linear;
  will-change: width;
}

.meter-fill.level { background-color: var(--color-accent); }
.meter-fill.bass { background-color: var(--color-bass); }
.meter-fill.mid { background-color: var(--color-mid); }
.meter-fill.treble { background-color: var(--color-treble); }

.stop-listening-button {
  padding: var(--space-xs) var(--space-sm);
  background-color: var(--color-error-a30);
  color: var(--color-error-a90);
  border: 1px solid var(--color-error-a50);
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-size: var(--font-size-sm);
  font-weight: bold;
  margin-top: var(--space-sm);
  transition: all var(--transition-fast);
  text-transform: uppercase;
}

.stop-listening-button:hover {
  background-color: var(--color-error-a50);
  color: var(--color-text);
}

.slider-group {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs); 
}

.slider-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px; 
}
.slider-label {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: 500;
}
.slider-value {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  background-color: var(--color-bg-inset);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  font-family: monospace;
}

.slider-labels {
    display: flex;
    justify-content: space-between;
    font-size: var(--font-size-xs);
    color: var(--color-text-muted);
    padding: 0 2px;
    margin-top: 2px; 
}

.intensity-slider {
  width: 100%;
  cursor: pointer;
  height: 6px;
  background: var(--color-primary-a15);
  border-radius: 3px;
  -webkit-appearance: none;
  appearance: none;
}
.intensity-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.5);
}
.intensity-slider::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.5);
}

.inactive-state {
  background: var(--color-glass-bg);
  border-radius: var(--radius-md);
  padding: var(--space-lg);
  border: 1px solid var(--color-border-subtle);
}

.inactive-description {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  line-height: 1.6;
}

.inactive-description h4 {
    font-size: var(--font-size-md);
    color: var(--color-text);
    margin-bottom: var(--space-sm);
}

.feature-description {
  margin-top: var(--space-sm);
}

.feature-description p {
    margin-bottom: var(--space-md);
    color: var(--color-text);
}

.feature-description ul {
  list-style: disc;
  padding-left: var(--space-lg);
  margin-bottom: var(--space-md);
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
}

.feature-description li strong {
    color: var(--color-primary);
}

.usage-note {
  margin-top: var(--space-lg);
  background: var(--color-primary-a05);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-sm);
  border-left: 3px solid var(--color-primary-a30);
  font-size: var(--font-size-xs);
}
.usage-note strong {
    color: var(--color-text);
}
```

---
### `src\components\Audio\AudioStyles\AudioStatusIcon.css`
```css
@import "../../../styles/variables.css";

.audio-status-icon {
  appearance: none; border: none; padding: 0; margin: 0; font-family: inherit;
  cursor: pointer; outline: none;
  width: var(--toolbar-button-size, 35px);
  height: var(--toolbar-button-size, 35px);
  display: flex; align-items: center; justify-content: center;
  background: var(--color-button-secondary-a80);
  backdrop-filter: blur(var(--blur-amount));
  -webkit-backdrop-filter: blur(var(--blur-amount));
  border: 1px solid var(--color-primary-a50);
  border-radius: var(--radius-sm);
  color: var(--color-primary);
  transition: all var(--transition-fast);
  overflow: hidden;
  flex-shrink: 0;
  position: relative;
}

.audio-status-icon:hover {
  background: var(--color-primary-a15);
  border-color: var(--color-primary);
  transform: translateY(-1px);
}
.audio-status-icon:active {
  background: var(--color-primary-a20);
  transform: translateY(0px);
}

@keyframes icon-active-pulse {
  0%, 100% { transform: scale(1); opacity: 0.8; filter: drop-shadow(0 0 4px var(--color-primary-a30)); }
  50% { transform: scale(1.08); opacity: 1; filter: drop-shadow(0 0 7px var(--color-primary-a70)); }
}

.audio-icon {
  width: 60%;
  height: 60%;
  display: flex;
  align-items: center;
  justify-content: center;
  filter: drop-shadow(0 0 2px var(--color-primary-a15));
  transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
}

.audio-status-icon.active .audio-icon {
  animation: icon-active-pulse 1.8s infinite ease-in-out;
}

.wave-container {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
}

.audio-wave {
  display: inline-block;
  width: 5px;
  background-color: currentColor;
  margin: 0 1px;
  border-radius: 1px;
  animation: wave 1.5s infinite ease-in-out;
}
.audio-wave:first-child { margin-left: 0; }
.audio-wave:last-child { margin-right: 0; }

.audio-wave:nth-child(1) { height: 80%; animation-delay: 0s; }
.audio-wave:nth-child(2) { height: 95%; animation-delay: 0.2s; }
.audio-wave:nth-child(3) { height: 65%; animation-delay: 0.4s; }

@keyframes wave {
  0%, 100% {
    transform: scaleY(0.6);
  }
  50% {
    transform: scaleY(1.2);
  }
}
```

---
### `src\components\ErrorBoundary.jsx`
```jsx
// src/components/ErrorBoundary.jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * ErrorBoundary: A React component that catches JavaScript errors anywhere
 * in its child component tree, logs those errors, and displays a fallback UI
 * instead of the crashed component tree.
 */
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error: error };
  }

  componentDidCatch(error, errorInfo) {
    // Log the error to the console (or send to an error reporting service)
    console.error("ErrorBoundary caught an error:", error, errorInfo);
    this.setState({ errorInfo: errorInfo });
  }

  render() {
    if (this.state.hasError) {
      // Render a user-friendly fallback UI
      return (
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "100vh",
            width: "100vw",
            padding: "20px",
            boxSizing: "border-box",
            backgroundColor: "#1a1a2e", // Match background
            color: "#ff5555", // Error color
            fontFamily: "Arial, sans-serif",
            textAlign: "center",
            border: "2px solid #ff5555",
          }}
        >
          <h1 style={{ color: "#ff5555", marginBottom: "15px" }}>
            Application Error
          </h1>
          <p style={{ color: "rgba(255,255,255,0.8)", marginBottom: "20px" }}>
            Sorry, something went wrong while rendering the application. Please
            try refreshing the page.
          </p>
          {/* Optionally show error details in development environments */}
          {import.meta.env.DEV && this.state.error && (
            <details
              style={{
                marginTop: "20px",
                padding: "15px",
                background: "rgba(0,0,0,0.2)",
                borderRadius: "5px",
                border: "1px solid #555",
                color: "rgba(255,255,255,0.7)",
                maxWidth: "80%",
                overflow: "auto",
              }}
            >
              <summary
                style={{
                  cursor: "pointer",
                  fontWeight: "bold",
                  color: "#ffa500",
                }}
              >
                Error Details (Development Mode)
              </summary>
              <pre
                style={{
                  whiteSpace: "pre-wrap",
                  marginTop: "10px",
                  textAlign: "left",
                  fontSize: "12px",
                  fontFamily: "monospace",
                  wordBreak: "break-all",
                }}
              >
                {this.state.error.toString()}
                {this.state.errorInfo &&
                  this.state.errorInfo.componentStack &&
                  `\n\nComponent Stack:\n${this.state.errorInfo.componentStack}`}
              </pre>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

ErrorBoundary.propTypes = {
  children: PropTypes.node.isRequired,
};

export default ErrorBoundary;
```

---
### `src\components\LayerConfiguration\LayerConfiguration.jsx`
```jsx
// src/components/LayerConfiguration.jsx
import React, { useEffect, useRef, useMemo, useCallback } from "react";
import PropTypes from "prop-types";

import { useProfileSessionState } from "../../hooks/configSelectors"; // Local hook
import { useMIDI } from "../../context/MIDIContext"; // Local context

// Import sliderParams from EnhancedControlPanel or a shared constants file
import { sliderParams } from "./EnhancedControlPanel"; // Assuming it's exported from here or a shared util

import { midiIcon, rotateIcon } from "../../assets"; // Local assets

import "./LayerConfigurationStyles/LayerConfiguration.css"; // Local styles

/**
 * Formats a numerical value to a string with a specified number of decimal places.
 * Returns a default string if the input is not a valid number.
 * @param {number|string|null|undefined} value - The value to format.
 * @param {number} [decimals=1] - The number of decimal places to use.
 * @returns {string} The formatted string representation of the value.
 */
const formatValue = (value, decimals = 1) => {
  const numValue = Number(value);
  if (value === undefined || value === null || isNaN(numValue)) {
    return "0".padEnd(decimals > 0 ? decimals + 2 : 1, "0");
  }
  return numValue.toFixed(decimals);
};


/**
 * @typedef {object} LayerConfigValue
 * @property {number|string|boolean|object} [enabled] - Whether the layer is enabled.
 * @property {string} [blendMode] - CSS mix-blend-mode.
 * @property {number} [opacity] - Layer opacity (0-1).
 * @property {number} [size] - Size multiplier.
 * @property {number} [speed] - Animation speed.
 * @property {number} [drift] - Drift magnitude.
 * @property {number} [driftSpeed] - Drift oscillation speed.
 * @property {number} [angle] - Rotation angle in degrees.
 * @property {number} [xaxis] - X-axis offset.
 * @property {number} [yaxis] - Y-axis offset.
 * @property {number} [direction] - Animation direction (-1 or 1).
 * @property {object} [driftState] - Internal state for drift effect.
 */

/**
 * @typedef {object} LayerConfigurationProps
 * @property {Object.<string|number, LayerConfigValue>} layerConfigs - An object containing configurations for all layers, keyed by layer ID.
 * @property {(layerId: number, key: string, value: any) => void} onLayerConfigChange - Callback to update a layer's configuration property.
 * @property {string[]} [blendModes=[]] - Array of available blend mode strings for the blend mode selector.
 * @property {number} [activeLayer=1] - The ID of the currently active layer being controlled (e.g., 1, 2, or 3).
 * @property {boolean} [readOnly=false] - Prop to explicitly set read-only mode. This can be overridden by session state (e.g., if user is not owner or in preview mode).
 * @property {boolean} [showMidiConnect=true] - Whether to show the MIDI connection status and related controls.
 */

/**
 * LayerConfiguration component provides UI controls for manipulating parameters
 * of a single visual layer.
 *
 * @param {LayerConfigurationProps} props - Component props.
 * @returns {JSX.Element} The rendered LayerConfiguration panel.
 */
const LayerConfiguration = ({
  layerConfigs,
  onLayerConfigChange,
  blendModes = [],
  activeLayer = 1,
  readOnly: propReadOnly = false,
  showMidiConnect = true,
}) => {
  // isPreviewMode is not directly used, canInteract already considers it.
  const { isVisitor, isParentAdmin, canInteract } = useProfileSessionState();
  const {
    isConnected: midiConnected,
    connectMIDI,
    midiMap,
    layerMappings,
    midiLearning,
    learningLayer,
    selectedChannel,
    midiMonitorData,
    showMidiMonitor: displayMidiMonitor,
    setShowMidiMonitor,
    startMIDILearn,
    stopMIDILearn,
    startLayerMIDILearn,
    stopLayerMIDILearn,
    setChannelFilter,
    clearMIDIMonitor,
    clearAllMappings,
  } = useMIDI();

  /** @type {React.RefObject<HTMLDivElement | null>} */
  const midiMonitorRef = useRef(null);

  const effectiveReadOnly = useMemo(() => {
    if (!canInteract) return true;
    return propReadOnly;
  }, [canInteract, propReadOnly]);

  const config = useMemo(() => layerConfigs[activeLayer] || {}, [layerConfigs, activeLayer]);

  useEffect(() => {
    if (midiMonitorRef.current && displayMidiMonitor) {
      midiMonitorRef.current.scrollTop = midiMonitorRef.current.scrollHeight;
    }
  }, [midiMonitorData, displayMidiMonitor]);

  const handleSliderChange = useCallback((e) => {
    if (effectiveReadOnly) return;
    const { name, value } = e.target;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, name, parseFloat(value));
    } else if (import.meta.env.DEV) {
      console.warn("[LayerConfiguration] onLayerConfigChange is not a function.");
    }
  }, [effectiveReadOnly, onLayerConfigChange, activeLayer]);

  const handleBlendModeChange = useCallback((e) => {
    if (effectiveReadOnly) return;
    const { value } = e.target;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, "blendMode", value);
    } else if (import.meta.env.DEV) {
      console.warn("[LayerConfiguration] onLayerConfigChange is not a function.");
    }
  }, [effectiveReadOnly, onLayerConfigChange, activeLayer]);

  const handleDirectionToggle = useCallback(() => {
    if (effectiveReadOnly) return;
    const currentDirection = config.direction || 1;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, "direction", -currentDirection);
    } else if (import.meta.env.DEV) {
      console.warn("[LayerConfiguration] onLayerConfigChange is not a function.");
    }
  }, [effectiveReadOnly, config.direction, onLayerConfigChange, activeLayer]);

  const enterMIDILearnMode = useCallback((paramName) => {
    if (effectiveReadOnly) return;
    if (!midiConnected) {
      alert("Please connect your MIDI device first using the 'Connect MIDI' button.");
      return;
    }
    if (typeof startMIDILearn === 'function') {
      startMIDILearn(paramName, activeLayer);
    }
  }, [effectiveReadOnly, midiConnected, startMIDILearn, activeLayer]);

  const enterLayerMIDILearnMode = useCallback((layer) => {
    if (effectiveReadOnly) return;
    if (!midiConnected) {
      alert("Please connect your MIDI device first using the 'Connect MIDI' button.");
      return;
    }
    if (typeof startLayerMIDILearn === 'function') {
      startLayerMIDILearn(layer);
    }
  }, [effectiveReadOnly, midiConnected, startLayerMIDILearn]);

  const connectMidiCb = useCallback(() => {
    if (typeof connectMIDI === 'function') {
      connectMIDI().catch((err) => {
        alert(`Failed to access MIDI devices: ${err.message}`);
      });
    }
  }, [connectMIDI]);

  const handleMidiChannelChangeCb = useCallback((e) => {
    if (typeof setChannelFilter === 'function') {
      setChannelFilter(parseInt(e.target.value, 10));
    }
  }, [setChannelFilter]);

  const clearMidiMonitorDataCb = useCallback(() => {
    if (typeof clearMIDIMonitor === 'function') {
      clearMIDIMonitor();
    }
  }, [clearMIDIMonitor]);

  const resetAllMappingsDataCb = useCallback(() => {
    if (effectiveReadOnly) return;
    if (typeof clearAllMappings === 'function') {
      clearAllMappings();
    }
  }, [effectiveReadOnly, clearAllMappings]);

  const formatMidiMappingDisplay = useCallback((mapping) => {
    if (!mapping) return "None";
    const channelText = mapping.channel !== undefined ? ` (Ch ${mapping.channel + 1})` : "";
    if (mapping.type === "cc") return `CC ${mapping.number}${channelText}`;
    if (mapping.type === "note") return `Note ${mapping.number}${channelText}`;
    if (mapping.type === "pitchbend") return `Pitch${channelText}`;
    return "Unknown";
  }, []);

  const currentParamMidiMappings = useMemo(() => midiMap[activeLayer] || {}, [midiMap, activeLayer]);

  const visitorOnShowcaseMessage = isVisitor && isParentAdmin && !effectiveReadOnly && (
    <div className="visitor-message info">
      As an admin visitor, you can experiment with all controls on this demo page.
      Changes won't be saved permanently.
    </div>
  );

  return (
    <div className="layer-configuration">
      {showMidiConnect && (
        <div className="midi-status-section">
          <div className="midi-status-row">
            <span>MIDI: {midiConnected ? "Connected" : "Not Connected"}</span>
            {!midiConnected ? (
              <button type="button" className="midi-connect-btn" onClick={connectMidiCb} aria-label="Connect MIDI device">
                <img src={midiIcon} alt="" className="midi-icon" />
                Connect MIDI
              </button>
            ) : (
              <div className="midi-buttons">
                <button
                  type="button"
                  className="midi-tool-button"
                  onClick={() => setShowMidiMonitor && setShowMidiMonitor(!displayMidiMonitor)}
                >
                  {displayMidiMonitor ? "Hide Monitor" : "Show Monitor"}
                </button>
                <button
                  type="button"
                  className="midi-tool-button midi-reset-btn"
                  onClick={resetAllMappingsDataCb}
                  title="Reset all MIDI mappings for current controller"
                  disabled={effectiveReadOnly}
                  aria-label="Reset all MIDI mappings"
                >
                  Reset Mappings
                </button>
                <select
                  className="midi-channel-select custom-select"
                  value={selectedChannel}
                  onChange={handleMidiChannelChangeCb}
                  title="Filter MIDI messages by channel"
                  aria-label="Select MIDI channel filter"
                >
                  <option value="0">All Channels</option>
                  {[...Array(16)].map((_, i) => (
                    <option key={i + 1} value={i + 1}>
                      Channel {i + 1}
                    </option>
                  ))}
                </select>
              </div>
            )}
          </div>

          {midiLearning && midiLearning.layer === activeLayer && (
            <div className="midi-learning-container">
              <span className="midi-learning-text">
                Mapping: {midiLearning.param.toUpperCase()}
              </span>
              <div className="midi-learning-instructions">
                Move a knob or press a button/pad on your MIDI controller
                <button
                  type="button"
                  className="midi-cancel-btn"
                  onClick={() => stopMIDILearn && stopMIDILearn()}
                  aria-label="Cancel MIDI learning for parameter"
                >
                  Cancel
                </button>
              </div>
            </div>
          )}

          {learningLayer !== null && (
            <div className="midi-learning-container layer-learning">
              <span className="midi-learning-text">
                Mapping: LAYER {learningLayer}
              </span>
              <div className="midi-learning-instructions">
                Press a key/pad on your MIDI controller
                <button
                  type="button"
                  className="midi-cancel-btn"
                  onClick={() => stopLayerMIDILearn && stopLayerMIDILearn()}
                  aria-label="Cancel MIDI learning for layer selection"
                >
                  Cancel
                </button>
              </div>
            </div>
          )}
        </div>
      )}

      {displayMidiMonitor && midiConnected && (
        <div className="midi-monitor" ref={midiMonitorRef}>
          <div className="midi-monitor-header">
            <h4>MIDI Monitor</h4>
            <button type="button" className="midi-clear-btn small-action-button" onClick={clearMidiMonitorDataCb} aria-label="Clear MIDI Monitor">
              Clear
            </button>
          </div>
          <div className="midi-monitor-content">
            {midiMonitorData.length === 0 ? (
              <div className="midi-monitor-empty">
                No MIDI messages received yet. Try moving controls on your MIDI device.
              </div>
            ) : (
              midiMonitorData.map((msg, index) => (
                <div key={`${msg.timestamp}-${index}`} className="midi-monitor-msg">
                  <span className="midi-monitor-time">{msg.timestamp}</span>
                  <span className="midi-monitor-type">{msg.type}</span>
                  <span className="midi-monitor-channel">Ch{msg.channel}</span>
                  <span className="midi-monitor-data">D1:{msg.data1}</span>
                  <span className="midi-monitor-data">D2:{msg.data2}</span>
                </div>
              ))
            )}
          </div>
        </div>
      )}

      <div className="layer-mappings">
        <h4 className="section-title">LAYER SELECTION MAPPINGS</h4>
        <div className="layer-mapping-grid">
          {[1, 2, 3].map((layerNum) => (
            <div
              key={`layer_select_mapping_${layerNum}`}
              className={`layer-mapping-item ${learningLayer === layerNum ? "learning-active" : ""}`}
            >
              <div className="layer-mapping-label">Layer {layerNum}</div>
              <div className="layer-mapping-controls">
                <span className="layer-mapping-text" title={`Current MIDI mapping for Layer ${layerNum} selection`}>
                  {layerMappings[layerNum]?.layerSelect
                    ? formatMidiMappingDisplay(layerMappings[layerNum].layerSelect)
                    : "Not mapped"}
                </span>
                <button
                  type="button"
                  className={`midi-learn-btn small-action-button ${learningLayer === layerNum ? "learning" : ""}`}
                  onClick={() => enterLayerMIDILearnMode(layerNum)}
                  disabled={effectiveReadOnly || !midiConnected || (learningLayer !== null && learningLayer !== layerNum)}
                  aria-label={`Map MIDI to select Layer ${layerNum}`}
                >
                  {learningLayer === layerNum ? "..." : "Map"}
                </button>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="slider-group-container">
        {sliderParams.map(({prop, label, min, max, step, formatDecimals, defaultValue = 0}) => (
            <div className="slider-container" key={`${activeLayer}-${prop}`}>
                <div className="slider-header">
                    <span className="slider-label">{label}</span>
                    <span className="slider-value">
                        {formatValue(config[prop] !== undefined ? config[prop] : defaultValue, formatDecimals)}
                    </span>
                    {showMidiConnect && midiConnected && (
                        <div className="midi-mapping-info">
                            <span className="midi-mapping-text" title={`Current MIDI mapping for ${label}`}>
                                {formatMidiMappingDisplay(currentParamMidiMappings[prop])}
                            </span>
                            <button
                                type="button"
                                className={`midi-learn-btn small-action-button ${midiLearning?.param === prop && midiLearning?.layer === activeLayer ? "learning" : ""}`}
                                onClick={() => enterMIDILearnMode(prop)}
                                disabled={effectiveReadOnly || !midiConnected || (midiLearning !== null && !(midiLearning?.param === prop && midiLearning?.layer === activeLayer))}
                                title={`Click to map ${label} to a MIDI controller`}
                                aria-label={`Map MIDI to ${label}`}
                            >
                                {midiLearning?.param === prop && midiLearning?.layer === activeLayer ? "..." : "Map"}
                            </button>
                        </div>
                    )}
                </div>
                <input
                    type="range"
                    name={prop}
                    min={min}
                    max={max}
                    step={step}
                    value={config[prop] !== undefined ? config[prop] : defaultValue}
                    onChange={handleSliderChange}
                    disabled={effectiveReadOnly || (midiLearning?.param === prop && midiLearning?.layer === activeLayer)}
                    className="horizontal-slider"
                    aria-label={`${label} slider`}
                />
            </div>
        ))}
      </div>


      <div className="controls-footer">
        <div className="blendmode-container">
          <label htmlFor={`blendMode-${activeLayer}`}>BLEND MODE</label>
          <select
            id={`blendMode-${activeLayer}`}
            className="custom-select blend-mode-select"
            name="blendMode"
            value={config.blendMode || "normal"}
            onChange={handleBlendModeChange}
            disabled={effectiveReadOnly}
            aria-label="Select Blend Mode"
          >
            {blendModes.map((mode) => (
              <option key={mode} value={mode}>
                {mode.split("-").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ")}
              </option>
            ))}
          </select>
        </div>

        <button
          type="button"
          className="changerotation-btn icon-button"
          onClick={handleDirectionToggle}
          disabled={effectiveReadOnly}
          title="Change Rotation Direction"
          aria-label="Change Rotation Direction"
        >
          <img
            src={rotateIcon}
            alt="Change Rotation Direction"
            className="direction-icon"
          />
        </button>
      </div>
      {visitorOnShowcaseMessage}
    </div>
  );
};

LayerConfiguration.propTypes = {
  layerConfigs: PropTypes.object.isRequired,
  onLayerConfigChange: PropTypes.func.isRequired,
  blendModes: PropTypes.array,
  activeLayer: PropTypes.number,
  readOnly: PropTypes.bool,
  showMidiConnect: PropTypes.bool,
};

export default LayerConfiguration;
```

---
### `src\components\LayerConfiguration\LayerConfigurationStyles\LayerConfiguration.css`
```css
.slider-container {
  margin-bottom: var(--space-md);
}

.slider-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-xs);
}

.slider-label {
  font-weight: bold;
  color: var(--color-text);
}

.slider-value {
  font-family: monospace;
  color: var(--color-primary);
}

.midi-status {
  background: var(--color-bg-alt);
  padding: var(--space-sm);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-md);
  display: flex;
  flex-direction: column;
}

.midi-status-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-sm);
}

.midi-buttons {
  display: flex;
  gap: var(--space-xs);
  align-items: center;
}

.midi-connect-btn,
.midi-monitor-btn,
.midi-clear-btn,
.midi-cancel-btn,
.midi-reset-btn {
  background: var(--color-primary-a15);
  color: var(--color-primary);
  border: 1px solid var(--color-primary-a30);
  border-radius: var(--radius-sm);
  padding: 4px 8px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.midi-connect-btn:hover,
.midi-monitor-btn:hover,
.midi-clear-btn:hover,
.midi-cancel-btn:hover,
.midi-reset-btn:hover {
  background: var(--color-primary-a25);
  transform: translateY(-1px);
}

.midi-reset-btn {
  background: var(--color-warning-a15);
  color: var(--color-warning);
  border-color: var(--color-warning-a30);
}

.midi-reset-btn:hover {
  background: var(--color-warning-a25);
}

.midi-cancel-btn {
  background: var(--color-error-a15);
  color: var(--color-error);
  border-color: var(--color-error-a30);
  margin-left: var(--space-sm);
}

.midi-cancel-btn:hover {
  background: var(--color-error-a25);
}

.midi-channel-select {
  padding: 4px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--color-border);
  background: var(--color-bg);
  color: var(--color-text);
  font-size: var(--font-size-xs);
}

.midi-learning-container {
  display: flex;
  flex-direction: column;
  margin-top: var(--space-xs);
  padding: var(--space-sm);
  background: var(--color-accent-a05);
  border: 1px solid var(--color-accent-a15);
  border-radius: var(--radius-md);
}

.midi-learning-container.layer-learning {
  background: var(--color-warning-a05);
  border: 1px solid var(--color-warning-a15);
}

.midi-learning {
  color: var(--color-accent);
  font-weight: bold;
  animation: blink 1s infinite;
}

.layer-learning .midi-learning {
  color: var(--color-warning);
}

.midi-learning-instructions {
  margin-top: var(--space-xs);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: var(--font-size-sm);
  color: var(--color-text-dim);
}

.midi-mapping-info {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}

.midi-mapping-text {
  font-size: var(--font-size-xs);
  color: var(--color-text-dim);
  background: var(--color-bg-alt);
  padding: 2px 4px;
  border-radius: var(--radius-sm);
}

.midi-learn-btn {
  padding: 2px 6px;
  font-size: var(--font-size-xs);
  background: var(--color-primary-a10);
  border: 1px solid var(--color-primary-a20);
  border-radius: var(--radius-sm);
  color: var(--color-primary);
  cursor: pointer;
}

.midi-learn-btn:hover:not(:disabled) {
  background: var(--color-primary-a20);
}

.midi-learn-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.midi-monitor {
  margin-bottom: var(--space-md);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
  max-height: 150px;
  display: flex;
  flex-direction: column;
}

.midi-monitor-header {
  background: var(--color-bg-alt);
  padding: var(--space-xs) var(--space-sm);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--color-border);
}

.midi-monitor-header h4 {
  margin: 0;
  font-size: var(--font-size-sm);
  color: var(--color-text);
}

.midi-monitor-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-xs);
  font-size: var(--font-size-xs);
  font-family: monospace;
  background: var(--color-bg);
}

.midi-monitor-empty {
  padding: var(--space-sm);
  text-align: center;
  color: var(--color-text-dim);
}

.midi-monitor-msg {
  padding: 2px 0;
  display: flex;
  border-bottom: 1px solid var(--color-border-light);
}

.midi-monitor-time {
  width: 70px;
  color: var(--color-text-dim);
}

.midi-monitor-type {
  width: 100px;
  color: var(--color-primary);
}

.midi-monitor-channel {
  width: 60px;
  color: var(--color-accent);
}

.midi-monitor-data {
  width: 40px;
  text-align: right;
  color: var(--color-text);
  margin-right: var(--space-sm);
}

.layer-mappings {
  margin-bottom: var(--space-md);
  background: var(--color-bg-alt);
  padding: var(--space-sm);
  border-radius: var(--radius-md);
}

.section-title {
  margin: 0 0 var(--space-sm) 0;
  font-size: var(--font-size-md);
  color: var(--color-primary);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
}

.layer-mapping-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-sm);
}

.layer-mapping-item {
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-xs);
}

.layer-mapping-item.active {
  border-color: var(--color-primary-a50);
  background: var(--color-primary-a10);
}

.layer-mapping-label {
  font-weight: bold;
  margin-bottom: var(--space-xs);
  font-size: var(--font-size-sm);
}

.layer-mapping-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.layer-mapping-text {
  font-size: var(--font-size-xs);
  color: var(--color-text-dim);
}

.visitor-message {
  margin-top: var(--space-md);
  padding: var(--space-sm);
  background: var(--color-primary-a05);
  border: 1px solid var(--color-primary-a15);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  color: var(--color-primary-a90);
  text-align: center;
}

@keyframes blink {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
  100% {
    opacity: 1;
  }
}

```

---
### `src\components\Main\Mainview.jsx`
```jsx
// src/components/Main/Mainview.jsx
import React, { useRef, useEffect, useMemo, useState, useCallback } from "react";
import PropTypes from "prop-types";

// Custom Hooks
import { useUpProvider } from "../../context/UpProvider";
import { useMIDI } from "../../context/MIDIContext";
import { useCoreApplicationStateAndLifecycle } from '../../hooks/useCoreApplicationStateAndLifecycle';
import { useAppInteractions } from '../../hooks/useAppInteractions';
import {
  useVisualLayerState,
  useInteractionSettingsState,
  useProfileSessionState,
  useConfigStatusState,
  usePresetManagementState,
} from "../../hooks/configSelectors";

// UI Components
import ToastContainer from "../Notifications/ToastContainer";
import UIOverlay from '../UI/UIOverlay';
import CanvasContainerWrapper from '../MainViewParts/CanvasContainerWrapper';
import FpsDisplay from '../MainViewParts/FpsDisplay';
import StatusIndicator from '../MainViewParts/StatusIndicator';
import AudioAnalyzerWrapper from '../MainViewParts/AudioAnalyzerWrapper';
import CriticalErrorDisplay from '../MainViewParts/CriticalErrorDisplay';

// Config & Assets
import { BLEND_MODES } from "../../config/global-config";
import { PING_COLOR, PING_STROKE_WIDTH, NO_PING_SELECTORS } from "../../config/uiConstants";

// Styles
import "./MainviewStyles/Mainview.css";

const portalContainerNode = typeof document !== 'undefined' ? document.getElementById('portal-container') : null;
const TOKEN_OVERLAY_ANIMATION_LOCK_DURATION = 500;

/**
 * @typedef {object} MainViewProps
 * @property {string[]} [blendModes] - Array of available blend mode strings. Defaults to BLEND_MODES from global config.
 */
const MainView = ({ blendModes = BLEND_MODES }) => {
  const { publicClient, walletClient } = useUpProvider();

  const {
    layerConfigs: currentActiveLayerConfigs,
    tokenAssignments: currentActiveTokenAssignments,
    updateLayerConfig,
    updateTokenAssignment,
  } = useVisualLayerState();

  const { savedReactions, updateSavedReaction, deleteSavedReaction } = useInteractionSettingsState();
  const { currentProfileAddress, isProfileOwner, canSave, isPreviewMode, isParentAdmin, isVisitor } = useProfileSessionState();
  const { isInitiallyResolved, configLoadNonce, loadError, upInitializationError, upFetchStateError, configServiceRef, isLoading: isConfigLoading } = useConfigStatusState();

  const {
    loadNamedConfig,
    currentConfigName,
    savedConfigList: presetSavedConfigList,
    loadedLayerConfigsFromPreset,
    loadedTokenAssignmentsFromPreset,
  } = usePresetManagementState();

  const { pendingLayerSelect, pendingParamUpdate, clearPendingActions } = useMIDI();

  const rootRef = useRef(null);
  const canvasRef1 = useRef(null);
  const canvasRef2 = useRef(null);
  const canvasRef3 = useRef(null);
  const canvasRefs = useMemo(() => ({ "1": canvasRef1, "2": canvasRef2, "3": canvasRef3 }), []);

  const [localAnimatingPanel, setLocalAnimatingPanel] = useState(null);
  const [localIsBenignOverlayActive, setLocalIsBenignOverlayActive] = useState(false);
  const [animationLockForTokenOverlay, setAnimationLockForTokenOverlay] = useState(false);
  const animationLockTimerRef = useRef(null);

  const coreApp = useCoreApplicationStateAndLifecycle({
    canvasRefs,
    configServiceRef,
    configLoadNonce,
    currentActiveLayerConfigs,
    currentActiveTokenAssignments,
    loadedLayerConfigsFromPreset,
    loadedTokenAssignmentsFromPreset,
    loadError,
    upInitializationError,
    upFetchStateError,
    isConfigLoading,
    isInitiallyResolved,
    currentConfigName,
    currentProfileAddress,
    animatingPanel: localAnimatingPanel,
    isBenignOverlayActive: localIsBenignOverlayActive,
    animationLockForTokenOverlay,
  });

  const {
    containerRef, managerInstancesRef, audioState,
    renderState, loadingStatusMessage, isStatusFadingOut, showStatusDisplay,
    showRetryButton, isTransitioning, outgoingLayerIdsOnTransitionStart,
    makeIncomingCanvasVisible, isAnimating, handleManualRetry,
    managersReady, defaultImagesLoaded,
    setCanvasLayerImage,
    hasValidDimensions, isContainerObservedVisible, isFullscreenActive, enterFullscreen,
    isMountedRef,
  } = coreApp;
  const { isAudioActive, audioSettings, handleAudioDataUpdate } = audioState;

  const appInteractions = useAppInteractions({
    updateLayerConfig,
    currentProfileAddress,
    savedReactions,
    managerInstancesRef,
    setCanvasLayerImage,
    updateTokenAssignment,
    configServiceRef,
    pendingParamUpdate,
    pendingLayerSelect,
    clearPendingActions,
    isMountedRef,
  });

  const {
    uiStateHook,
    notificationData,
    handleTokenApplied,
    processEffect,
    handleLayerPropChange,
  } = appInteractions;

  /**
   * Callback to handle the generated snapshot. It applies the snapshot image
   * to the target layer and updates the application state accordingly.
   * @param {string} dataUrl - The base64 data URL of the snapshot image.
   * @param {string} targetLayerId - The ID of the layer to apply the snapshot to ('1', '2', or '3').
   */
  const handleSnapshotReady = useCallback((dataUrl, targetLayerId) => {
    // 1. Apply the new composite image directly to the target canvas layer.
    setCanvasLayerImage(targetLayerId, dataUrl);

    // 2. Update the global token assignment state so this change can be saved in presets.
    updateTokenAssignment(targetLayerId, dataUrl);

    // 3. For a better user experience, disable the other two layers to focus on the new composite.
    const allLayers = ['1', '2', '3'];
    const otherLayerIds = allLayers.filter(id => id !== targetLayerId);
    for (const layerId of otherLayerIds) {
      updateLayerConfig(layerId, 'enabled', false);
    }

  }, [setCanvasLayerImage, updateTokenAssignment, updateLayerConfig]);

  useEffect(() => {
    setLocalAnimatingPanel(uiStateHook.animatingPanel);
    const newIsBenign = uiStateHook.animatingPanel === 'tokens' ||
                        uiStateHook.activePanel === 'tokens' ||
                        uiStateHook.infoOverlayOpen;
    setLocalIsBenignOverlayActive(newIsBenign);
  }, [
    uiStateHook.animatingPanel,
    uiStateHook.activePanel,
    uiStateHook.infoOverlayOpen
  ]);

  useEffect(() => {
    if (localAnimatingPanel === 'tokens') {
      setAnimationLockForTokenOverlay(true);
      if (animationLockTimerRef.current) clearTimeout(animationLockTimerRef.current);
      animationLockTimerRef.current = setTimeout(() => {
        if (isMountedRef.current) setAnimationLockForTokenOverlay(false);
        animationLockTimerRef.current = null;
      }, TOKEN_OVERLAY_ANIMATION_LOCK_DURATION);
    } else if (animationLockForTokenOverlay && localAnimatingPanel !== 'tokens') {
      setAnimationLockForTokenOverlay(false);
      if (animationLockTimerRef.current) {
        clearTimeout(animationLockTimerRef.current);
        animationLockTimerRef.current = null;
      }
    }
    return () => {
      if (animationLockTimerRef.current) clearTimeout(animationLockTimerRef.current);
    };
  }, [localAnimatingPanel, animationLockForTokenOverlay, isMountedRef]);

  const criticalErrorContent = (
    <CriticalErrorDisplay
      initializationError={upInitializationError}
      fetchStateError={upFetchStateError}
      publicClient={publicClient}
      walletClient={walletClient}
    />
  );

  if (criticalErrorContent.props.initializationError || (criticalErrorContent.props.fetchStateError && !criticalErrorContent.props.publicClient && !criticalErrorContent.props.walletClient)) {
    return criticalErrorContent;
  }

  const showFpsCounter = useMemo(() => renderState === 'rendered' && isContainerObservedVisible, [renderState, isContainerObservedVisible]);

  const configDataForUIOverlay = useMemo(() => ({
    layerConfigs: currentActiveLayerConfigs, tokenAssignments: currentActiveTokenAssignments,
    savedReactions, currentConfigName, isConfigLoading,
    canSave, isPreviewMode, isParentAdmin, isProfileOwner, isVisitor, currentProfileAddress,
    blendModes,
    notifications: notificationData.notifications,
    unreadCount: notificationData.unreadCount,
    isTransitioning,
    isBaseReady: (managersReady && defaultImagesLoaded && isInitiallyResolved && hasValidDimensions && isContainerObservedVisible),
    renderState,
  }), [
    currentActiveLayerConfigs, currentActiveTokenAssignments, savedReactions, currentConfigName, isConfigLoading,
    canSave, isPreviewMode, isParentAdmin, isProfileOwner, isVisitor, currentProfileAddress,
    blendModes, notificationData.notifications, notificationData.unreadCount, isTransitioning,
    managersReady, defaultImagesLoaded, isInitiallyResolved, hasValidDimensions, isContainerObservedVisible,
    renderState,
  ]);

  const actionsForUIOverlay = useMemo(() => ({
    onLayerConfigChange: handleLayerPropChange,
    onSaveReaction: updateSavedReaction,
    onRemoveReaction: deleteSavedReaction,
    onPresetSelect: loadNamedConfig,
    onEnhancedView: enterFullscreen,
    onMarkNotificationRead: notificationData.markAsRead,
    onClearAllNotifications: notificationData.clearAll,
    onPreviewEffect: processEffect,
    onTokenApplied: handleTokenApplied
  }), [
    handleLayerPropChange, updateSavedReaction, deleteSavedReaction, loadNamedConfig,
    enterFullscreen, notificationData.markAsRead, notificationData.clearAll, processEffect, handleTokenApplied
  ]);

  const displayConfigsForClassLogic = isTransitioning ? loadedLayerConfigsFromPreset : currentActiveLayerConfigs;

  const getCanvasClasses = (layerIdStr) => {
    let classes = `canvas layer-${layerIdStr}`;
    const isThisLayerOutgoing = isTransitioning && outgoingLayerIdsOnTransitionStart && outgoingLayerIdsOnTransitionStart.has(layerIdStr);
    const isThisLayerIncomingAndReady = isTransitioning && makeIncomingCanvasVisible && displayConfigsForClassLogic?.[layerIdStr]?.enabled;
    const isThisLayerStableAndVisible = !isTransitioning && renderState === 'rendered' && currentActiveLayerConfigs?.[layerIdStr]?.enabled;

    if (isThisLayerOutgoing) {
      classes += ' is-fading-out';
    } else if (isThisLayerIncomingAndReady || isThisLayerStableAndVisible) {
      classes += ' visible';
      if (isThisLayerIncomingAndReady) {
        classes += ' is-fading-in';
      }
    }
    return classes;
  };

  const canvas1Class = getCanvasClasses('1');
  const canvas2Class = getCanvasClasses('2');
  const canvas3Class = getCanvasClasses('3');
  const containerClass = `canvas-container ${isTransitioning ? 'transitioning-active' : ''}`;

  return (
    <>
      <div id="fullscreen-root" ref={rootRef} className="main-view radar-cursor">
        <CanvasContainerWrapper
          containerRef={containerRef}
          canvasRef1={canvasRef1} canvasRef2={canvasRef2} canvasRef3={canvasRef3}
          containerClass={containerClass}
          canvas1Class={canvas1Class} canvas2Class={canvas2Class} canvas3Class={canvas3Class}
          pingColor={PING_COLOR} pingStrokeWidth={PING_STROKE_WIDTH} noPingSelectors={NO_PING_SELECTORS}
        />
        <FpsDisplay showFpsCounter={showFpsCounter} isFullscreenActive={isFullscreenActive} portalContainer={portalContainerNode} />
        <ToastContainer />
        <UIOverlay
          uiState={uiStateHook}
          audioState={audioState}
          configData={configDataForUIOverlay}
          actions={actionsForUIOverlay}
          passedSavedConfigList={presetSavedConfigList}
        />
        <StatusIndicator
            showStatusDisplay={showStatusDisplay}
            isStatusFadingOut={isStatusFadingOut}
            renderState={renderState}
            loadingStatusMessage={loadingStatusMessage}
            showRetryButton={showRetryButton}
            onManualRetry={handleManualRetry}
        />
        <AudioAnalyzerWrapper
          isAudioActive={isAudioActive}
          managersReady={managersReady}
          handleAudioDataUpdate={handleAudioDataUpdate}
          layerConfigs={currentActiveLayerConfigs}
          audioSettings={audioSettings}
          configLoadNonce={configLoadNonce}
          managerInstancesRef={managerInstancesRef}
        />
        
        {/* Render the snapshot generator button and pass it the manager instances and the callback */}
        <CompositeAssetGenerator
          managerInstancesRef={managerInstancesRef}
          onSnapshotReady={handleSnapshotReady}
        />
      </div>
    </>
  );
};

MainView.propTypes = {
  blendModes: PropTypes.arrayOf(PropTypes.string),
};

export default MainView;
```

---
### `src\components\Main\MainviewStyles\FpsCounter.css`
```css
.fps-counter {
  position: fixed;
  bottom: var(--space-md, 16px);
  left: var(--space-md, 16px);
  background-color: rgba(0, 0, 0, 0.7);
  color: #00f3ff;
  padding: var(--space-xs, 8px) var(--space-sm, 12px);
  border-radius: var(--radius-sm, 4px);
  font-size: var(--font-size-lg, 16px);
  font-family: monospace;
  z-index: 10001;
  pointer-events: none;
  opacity: 0.9;
  border: 1px solid var(--color-primary-a30, rgba(0, 243, 255, 0.3));
}
```

---
### `src\components\Main\MainviewStyles\Mainview.css`
```css
/* src/components/Main/MainviewStyles/Mainview.css */
@import "../../../styles/variables.css";

.main-view {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background-color: #000000;
}

.canvas-container {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  display: block;
  transform: translateZ(0);
  will-change: opacity;
  opacity: 1;
  visibility: visible;
  background: radial-gradient( circle at center, var(--color-bg-light) 0%, #000000 100% );
  z-index: 1;
  transition: opacity 0.15s linear; /* For dimming when overlay-animating is removed */
}

.main-view.overlay-animating .canvas-container {
  opacity: 0.6;
  transition: opacity 0.05s linear; /* Fast dim when overlay appears */
}

.grid-overlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  background-image:
    linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
  background-size: 20px 20px;
  z-index: 2;
  pointer-events: none;
}

.canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100% !important;
  height: 100% !important;
  display: block;
  backface-visibility: hidden;
  will-change: transform, opacity;

  /* Default state: hidden, ready for transition-in */
  opacity: 0;
  visibility: hidden; /* Start hidden, JS will make it visible for transition */
  transform: scale(1.15) translateY(-15px); /* Initial transform for transition */

  /* Base z-index, JS will override for the active/topmost layer during transition */
}
.canvas.layer-1 { z-index: 3; }
.canvas.layer-2 { z-index: 4; }
.canvas.layer-3 { z-index: 5; }


/*
  Core transition applied when opacity or transform changes.
  This is the master duration for preset fades.
*/
.canvas {
  transition-property: opacity, transform;
  /* --- MODIFIED DURATION --- */
  transition-duration: 500ms; /* Example: 0.5 seconds */
  /* ------------------------- */
  transition-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
}

/*
  .visible class is added by JS to set the final visible state.
  The transition to these properties is governed by the base .canvas transition.
*/
.canvas.visible {
  opacity: 1;
  visibility: visible;
  transform: translateY(0) scale(1);
}

/*
  JS-Controlled Transition Classes (for Strategy 1 - Z-index management)
  These are dynamically added and removed by MainView.jsx based on useRenderLifecycle state.
*/

/* Applied to the canvas that is FADING OUT */
.canvas.is-fading-out {
  /* The opacity and transform targets are implicitly opacity:0 and the initial transform */
  /* because this class is added to an element that was .visible (opacity:1, transform: initial) */
  /* and then JS will remove .visible, causing it to transition to the base .canvas styles. */
  z-index: 100 !important; /* CRITICAL: Keep on top during its fade out */
}

/* Applied to the canvas that is FADING IN */
.canvas.is-fading-in {
  /* This class is added to a canvas that starts with base .canvas styles (opacity:0, transform: initial-offscreen) */
  /* Then JS will also add .visible to it, triggering the transition to opacity:1 and transform: final-onscreen. */
  /* z-index should be lower than .is-fading-out, e.g., its default or a value like 90 */
  /* The default z-index from .layer-N should suffice if the outgoing has a higher z-index. */
  visibility: visible !important; /* Ensure it's visible to start its animation if JS hasn't added .visible yet */
}


/* Entity Logo */
.entity-logo {
  position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
  height: 40px; z-index: 150; /* Ensure logo is above all transitioning canvases */
  opacity: 1; visibility: visible;
}

/* Status Display, FPS Counter, etc. (styles remain the same) */
.status-display {
  position: fixed;
  top: 75%; 
  left: 50%;
  transform: translate(-50%, -50%); 
  z-index: var(--z-top);
  backdrop-filter: blur(var(--blur-amount, 3px));
  -webkit-backdrop-filter: blur(var(--blur-amount, 3px));
  box-shadow: var(--shadow-md);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-md);
  font-size: var(--font-size-md);
  font-weight: 500;
  text-align: center;
  min-width: 250px;
  transition: opacity 1000ms cubic-bezier(0.2, 0.8, 0.2, 1); 
  opacity: 1;
  pointer-events: none;
}

.status-display.info-state {
  background: rgba(var(--color-warning-rgb), 0.25);
  border: 1px solid var(--color-warning-a50, rgba(255, 165, 0, 0.5));
  color: var(--color-warning, #ffa500);
  box-shadow: 0 0 12px rgba(var(--color-warning-rgb), 0.4);
}

.status-display.error-state {
  background: rgba(var(--color-error-rgb), 0.25);
  border: 1px solid var(--color-error-a50, rgba(255, 85, 85, 0.5));
  color: var(--color-error, #ff5555);
  box-shadow: 0 0 12px rgba(var(--color-error-rgb), 0.4);
}

.status-display.fade-out {
  opacity: 0;
}

.status-display .retry-render-button {
  display: block;
  margin: var(--space-sm) auto 0;
  padding: var(--space-xs) var(--space-md);
  background: var(--color-error-a30);
  color: var(--color-text);
  border: 1px solid var(--color-error-a50, rgba(255, 85, 85, 0.5));
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background var(--transition-fast);
  pointer-events: auto;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  font-weight: bold;
  text-transform: uppercase;
}
.status-display .retry-render-button:hover:not(:disabled) {
  background: var(--color-error-a50, rgba(255, 165, 0, 0.5));
}
.status-display .retry-render-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.hidden-audio-analyzer {
  position: absolute; left: -9999px; top: -9999px;
  opacity: 0; width: 0; height: 0; overflow: hidden; pointer-events: none;
}

.fps-counter {
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.5);
  color: #00ff99;
  padding: 5px 10px;
  font-size: 12px;
  font-family: monospace;
  border-radius: 4px;
  z-index: 1000;
  pointer-events: none;
}

.maximize-button {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 10000;
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
  backdrop-filter: blur(4px);
  transition: all 0.3s ease;
}
.maximize-button:hover {
  background: rgba(255, 255, 255, 0.2);
}

#fullscreen-root.radar-cursor {
  cursor: url('/assets/cursors/radar-dot.svg') 8 8, auto;
}

.click-ping-svg-container {
  position: fixed;
  transform: translate(-50%, -50%);
  width: 40px; 
  height: 40px;
  pointer-events: none;
  z-index: 10001;
  opacity: 1; 
  display: flex;
  justify-content: center;
  align-items: center;
}

.click-ping-svg {
  width: 100%;
  height: 100%;
  overflow: visible !important; 
}

.click-ping-svg circle {
  stroke-opacity: 1; 
  transform-origin: center; 
}

.ping-svg-animation .click-ping-svg circle {
  animation: ping-circle-anim-simple 0.7s linear forwards;
}

@keyframes ping-circle-anim-simple {
  0% {
    r: 2;
    stroke-opacity: 1;
    transform: scale(0.1);
  }
  100% {
    r: 30; 
    stroke-opacity: 0;
    transform: scale(2.5); 
  }
}
```

---
### `src\components\MainViewParts\AudioAnalyzerWrapper.jsx`
```jsx
// src/components/Audio/AudioAnalyzerWrapper.jsx (Assuming path based on context)
import React from 'react';
import PropTypes from 'prop-types';

import AudioAnalyzer from '../Audio/AudioAnalyzer'; // Local component

// Assuming styles for "hidden-audio-analyzer" are defined elsewhere or globally,
// or that this class primarily serves as a semantic hook rather than for direct styling.
// e.g., import './AudioStyles.css';

/**
 * @typedef {object} AudioAnalyzerWrapperProps
 * @property {boolean} isAudioActive - If true, the audio analysis process is active and the `AudioAnalyzer` component will be rendered.
 * @property {boolean} managersReady - Indicates if the canvas managers (which might consume audio data for visual effects) are ready. The wrapper might choose not to render the analyzer if managers aren't ready.
 * @property {(data: import('../../hooks/useAudioVisualizer').RawAudioAnalyzerData) => void} handleAudioDataUpdate - Callback function invoked by `AudioAnalyzer` with new audio analysis data (e.g., level, frequency bands).
 * @property {import('../../context/VisualConfigContext').AllLayerConfigs} layerConfigs - Current configurations for all visual layers, potentially used by `AudioAnalyzer` if it needs to adapt analysis based on layer settings.
 * @property {import('../../hooks/useAudioVisualizer').AudioVisualizerSettings} audioSettings - Current settings for audio processing and analysis (e.g., intensity, smoothing).
 * @property {number} configLoadNonce - A nonce that changes when a new global configuration (preset) is loaded. This can be used by `AudioAnalyzer` to reset or re-initialize if its behavior depends on preset data.
 * @property {React.RefObject<Object.<string, import('../../utils/CanvasManager').default>>} managerInstancesRef - Ref to the canvas manager instances, potentially for direct interaction if `AudioAnalyzer` needs it (though typically data flows via `handleAudioDataUpdate`).
 */

/**
 * AudioAnalyzerWrapper: A simple wrapper component that conditionally renders the `AudioAnalyzer`.
 * It only renders the `AudioAnalyzer` if audio processing is active (`isAudioActive`) and
 * if the canvas managers are ready (`managersReady`), ensuring that audio analysis
 * doesn't run unnecessarily or before its consumers are prepared.
 * The wrapper itself is styled to be hidden, as `AudioAnalyzer` is typically a non-visual,
 * data-processing component.
 *
 * @param {AudioAnalyzerWrapperProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered AudioAnalyzer within a hidden div, or null if conditions are not met.
 */
const AudioAnalyzerWrapper = ({
  isAudioActive,
  managersReady,
  handleAudioDataUpdate,
  layerConfigs,
  audioSettings,
  configLoadNonce,
  managerInstancesRef,
}) => {
  // Do not render the AudioAnalyzer if audio is not active or managers are not ready.
  // This prevents unnecessary processing.
  if (!isAudioActive || !managersReady) {
    return null;
  }

  return (
    // The "hidden-audio-analyzer" class suggests this wrapper is not meant to be visible.
    // Its purpose is to conditionally mount/unmount the AudioAnalyzer component.
    <div className="hidden-audio-analyzer" aria-hidden="true">
      <AudioAnalyzer
        isActive={isAudioActive} // Pass down the active state
        onAudioData={handleAudioDataUpdate} // Callback for processed audio data
        layerConfigs={layerConfigs} // Current layer configurations
        audioSettings={audioSettings} // Settings for the audio analysis
        configLoadNonce={configLoadNonce} // To react to preset changes
        managerInstancesRef={managerInstancesRef} // Ref to canvas managers
      />
    </div>
  );
};

AudioAnalyzerWrapper.propTypes = {
  /** If true, audio analysis is active and the analyzer is rendered. */
  isAudioActive: PropTypes.bool.isRequired,
  /** If true, indicates that canvas managers (consumers of audio data) are ready. */
  managersReady: PropTypes.bool.isRequired,
  /** Callback function invoked with new audio analysis data. */
  handleAudioDataUpdate: PropTypes.func.isRequired,
  /** Current configurations for all visual layers. */
  layerConfigs: PropTypes.object.isRequired, // More specific shape can be added if known
  /** Current settings for audio processing and analysis. */
  audioSettings: PropTypes.object.isRequired, // More specific shape can be added if known
  /** A nonce that changes when a new preset is loaded. */
  configLoadNonce: PropTypes.number.isRequired,
  /** Ref to the canvas manager instances. */
  managerInstancesRef: PropTypes.object.isRequired, // Typically a React.RefObject
};

// Default export is standard for React components.
// Consider React.memo if props are complex and might not change frequently,
// though for a simple wrapper like this, it might be unnecessary unless AudioAnalyzer itself is expensive.
export default AudioAnalyzerWrapper;
```

---
### `src\components\MainViewParts\CanvasContainerWrapper.jsx`
```jsx
// src/components/MainViewParts/CanvasContainerWrapper.jsx (Assuming path based on context)
import React, { useCallback } from 'react';
import PropTypes from 'prop-types';

// Assuming styles are imported by a parent or a dedicated CSS file for this component.
// e.g., import './CanvasContainerWrapper.css';
// The original mentioned Mainview.css, so ensure relevant styles are accessible.

/**
 * @typedef {object} CanvasContainerWrapperProps
 * @property {React.RefObject<HTMLDivElement>} containerRef - Ref for the main container div that holds the canvases and grid overlay.
 * @property {React.RefObject<HTMLCanvasElement>} canvasRef1 - Ref for the first canvas element (bottom layer).
 * @property {React.RefObject<HTMLCanvasElement>} canvasRef2 - Ref for the second canvas element (middle layer).
 * @property {React.RefObject<HTMLCanvasElement>} canvasRef3 - Ref for the third canvas element (top layer).
 * @property {string} containerClass - CSS class name(s) for the main container div.
 * @property {string} canvas1Class - CSS class name(s) for the first canvas element.
 * @property {string} canvas2Class - CSS class name(s) for the second canvas element.
 * @property {string} canvas3Class - CSS class name(s) for the third canvas element.
 * @property {string} pingColor - CSS color string for the click ping animation stroke.
 * @property {number} pingStrokeWidth - Stroke width for the click ping animation circle.
 * @property {string} noPingSelectors - A CSS selector string. Clicks on elements matching these selectors (or their children) within the container will not trigger the ping animation.
 */

/**
 * CanvasContainerWrapper: A component that sets up the main visual area,
 * containing three canvas layers for visual rendering and a grid overlay.
 * It also implements a "click ping" animation effect that appears at the
 * mouse click location, unless the click target matches `noPingSelectors`.
 *
 * @param {CanvasContainerWrapperProps} props - The component's props.
 * @returns {JSX.Element} The rendered canvas container with its layers and click ping functionality.
 */
const CanvasContainerWrapper = ({
  containerRef,
  canvasRef1,
  canvasRef2,
  canvasRef3,
  containerClass,
  canvas1Class,
  canvas2Class,
  canvas3Class,
  pingColor,
  pingStrokeWidth,
  noPingSelectors, // e.g., ".toolbar-icon, .panel, button"
}) => {

  /**
   * Handles click events on the canvas container to create a "ping" animation
   * at the click location, unless the click target is within an element matching
   * `noPingSelectors`.
   */
  const handleCanvasClick = useCallback((event) => {
    // Prevent ping if the click target or its ancestor matches any of the noPingSelectors
    if (noPingSelectors && typeof noPingSelectors === 'string' && event.target.closest(noPingSelectors)) {
      return;
    }

    const containerElement = containerRef.current;
    if (!containerElement) {
      if (import.meta.env.DEV) {
        console.warn("[CanvasContainerWrapper] Container ref not available for ping effect.");
      }
      return;
    }

    // Get click coordinates relative to the viewport
    const x = event.clientX;
    const y = event.clientY;

    // Create the SVG container for the ping animation
    const pingContainer = document.createElement('div');
    pingContainer.className = 'click-ping-svg-container'; // For CSS targeting and positioning
    // Position the ping at the click coordinates
    pingContainer.style.left = `${x}px`;
    pingContainer.style.top = `${y}px`;

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "click-ping-svg");
    svg.setAttribute("viewBox", "0 0 20 20"); // ViewBox for a 20x20 coordinate system
    svg.style.overflow = "visible"; // Ensure animation (expanding circle) is not clipped by SVG bounds

    const circle = document.createElementNS(svgNS, "circle");
    circle.setAttribute("cx", "10"); // Center of the 20x20 viewBox
    circle.setAttribute("cy", "10");
    circle.setAttribute("r", "5"); // Initial radius
    circle.setAttribute("stroke", pingColor);
    circle.setAttribute("stroke-width", String(pingStrokeWidth)); // Ensure it's a string
    circle.setAttribute("fill", "none"); // No fill, just a stroke

    svg.appendChild(circle);
    pingContainer.appendChild(svg);

    try {
      containerElement.appendChild(pingContainer);
      // Trigger CSS animation by adding a class.
      // requestAnimationFrame ensures the element is in the DOM before class is added, allowing transition/animation to trigger.
      requestAnimationFrame(() => {
        pingContainer.classList.add('ping-svg-animation'); // Assumes CSS defines this animation
      });

      // Clean up the ping element after its animation completes.
      pingContainer.addEventListener('animationend', () => {
        if (pingContainer.parentElement) { // Check if still in DOM before removing
            pingContainer.remove();
        }
      }, { once: true }); // Listener automatically removed after first trigger

    } catch (e) {
      if (import.meta.env.DEV) {
        console.error("[CanvasContainerWrapper] Error creating or animating click ping:", e);
      }
      // Ensure cleanup even if append fails or other error occurs before animationend
      if (pingContainer.parentElement) {
        pingContainer.remove();
      }
    }
  }, [containerRef, noPingSelectors, pingColor, pingStrokeWidth]); // Dependencies for the click handler

  return (
    <div ref={containerRef} className={containerClass} onClick={handleCanvasClick}>
      <div className="grid-overlay"></div> {/* For visual grid, styled via CSS */}
      <canvas ref={canvasRef1} className={canvas1Class} />
      <canvas ref={canvasRef2} className={canvas2Class} />
      <canvas ref={canvasRef3} className={canvas3Class} />
    </div>
  );
};

CanvasContainerWrapper.propTypes = {
  /** Ref for the main container div. */
  containerRef: PropTypes.oneOfType([
    PropTypes.func, // For callback refs
    PropTypes.shape({ current: PropTypes.instanceOf(Element) }) // For object refs
  ]).isRequired,
  /** Ref for the first canvas element (bottom layer). */
  canvasRef1: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.shape({ current: PropTypes.instanceOf(HTMLCanvasElement) })
  ]).isRequired,
  /** Ref for the second canvas element (middle layer). */
  canvasRef2: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.shape({ current: PropTypes.instanceOf(HTMLCanvasElement) })
  ]).isRequired,
  /** Ref for the third canvas element (top layer). */
  canvasRef3: PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.shape({ current: PropTypes.instanceOf(HTMLCanvasElement) })
  ]).isRequired,
  /** CSS class name(s) for the main container div. */
  containerClass: PropTypes.string.isRequired,
  /** CSS class name(s) for the first canvas element. */
  canvas1Class: PropTypes.string.isRequired,
  /** CSS class name(s) for the second canvas element. */
  canvas2Class: PropTypes.string.isRequired,
  /** CSS class name(s) for the third canvas element. */
  canvas3Class: PropTypes.string.isRequired,
  /** CSS color string for the click ping animation stroke. */
  pingColor: PropTypes.string.isRequired,
  /** Stroke width for the click ping animation circle. */
  pingStrokeWidth: PropTypes.number.isRequired,
  /** A CSS selector string to identify elements where clicks should NOT trigger the ping. */
  noPingSelectors: PropTypes.string.isRequired,
};

// Default export is standard for React components.
export default CanvasContainerWrapper;
```

---
### `src\components\MainViewParts\CriticalErrorDisplay.jsx`
```jsx
// src/components/MainViewParts/CriticalErrorDisplay.jsx
import React from 'react';
import PropTypes from 'prop-types';

// Assuming Viem types might be used for prop validation, though not strictly necessary for runtime.
// import { PublicClient, WalletClient } from 'viem';

/**
 * @typedef {object} CriticalErrorDisplayProps
 * @property {Error | null} initializationError - Error from Universal Profile Provider initialization.
 * @property {Error | null} fetchStateError - Error from blockchain client fetching state.
 * @property {object | null} publicClient - Viem PublicClient instance.
 * @property {object | null} walletClient - Viem WalletClient instance.
 */

/**
 * Displays a critical application error message if UP provider or Viem client issues occur.
 * If an error is displayed, this component renders the error UI. Otherwise, it renders null.
 * @param {CriticalErrorDisplayProps} props
 * @returns {JSX.Element | null}
 */
const CriticalErrorDisplay = ({ initializationError, fetchStateError, publicClient, walletClient }) => {
  if (initializationError || (fetchStateError && !publicClient && !walletClient)) {
    const errorSource = initializationError ? "Universal Profile Provider" : "Blockchain Client";
    const errorMessage = initializationError?.message || fetchStateError?.message || `Unknown critical error initialising ${errorSource}.`;

    return (
      <div id="fullscreen-root" className="main-view error-boundary-display" style={{ width: '100%', height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', backgroundColor: '#1a1a1a', color: '#fff' }}>
        <div className="error-content" style={{ textAlign: 'center', padding: '20px', border: '1px solid #555', borderRadius: '8px', backgroundColor: '#2a2a2a' }}>
          <p style={{ fontSize: '1.2em', fontWeight: 'bold', color: '#ff6b6b' }}>Critical Application Error</p>
          <p style={{ wordBreak: 'break-word', maxWidth: '400px', margin: '10px auto', color: '#ccc' }}>{errorMessage}</p>
          <p style={{ color: '#aaa' }}>Please ensure your Universal Profile browser extension is enabled and configured correctly, then try refreshing the page.</p>
        </div>
      </div>
    );
  }

  return null; // Render nothing if no critical error condition is met
};

CriticalErrorDisplay.propTypes = {
  initializationError: PropTypes.instanceOf(Error),
  fetchStateError: PropTypes.instanceOf(Error),
  publicClient: PropTypes.object,
  walletClient: PropTypes.object,
};

export default CriticalErrorDisplay;
```

---
### `src\components\MainViewParts\FpsDisplay.css`
```css
/* src/components/MainViewParts/FpsDisplay.css */
.fps-counter {
    position: absolute;
    bottom: 10px; /* Changed from top */
    left: 10px;   /* Changed from right */
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    padding: 5px 10px;
    border-radius: 3px;
    font-size: 12px;
    z-index: 10000; /* Ensure it's above most things */
    pointer-events: none; /* Allow clicks to pass through */
  }
  
  /* Specific styling for when FPS counter is in the portal-container (fullscreen) */
  #portal-container .fps-counter {
    position: fixed; /* Use fixed if #portal-container is at body level */
    bottom: 10px; /* Changed from top */
    left: 10px;   /* Changed from right */
  }
```

---
### `src\components\MainViewParts\FpsDisplay.jsx`
```jsx
// src/components/MainViewParts/FpsDisplay.jsx (Assuming path based on context)
import React, { useState, useEffect, useRef } from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';

import './FpsDisplay.css'; // Assuming specific styles for the FPS counter

/**
 * @typedef {object} FpsDisplayProps
 * @property {boolean} showFpsCounter - If true, the FPS counter is rendered and active.
 * @property {boolean} isFullscreenActive - Indicates if the application is currently in fullscreen mode. This is used to determine if the FPS counter should be portalled.
 * @property {Element | null} [portalContainer] - Optional DOM element to which the FPS counter should be portalled when in fullscreen mode. If null or not provided, the counter renders inline.
 */

/**
 * FpsDisplay: A component that calculates and displays the current frames per second (FPS)
 * of the application's rendering loop. It uses `requestAnimationFrame` for accurate FPS calculation.
 * When `isFullscreenActive` is true and a `portalContainer` is provided, it uses a React Portal
 * to render the FPS counter into the specified container, allowing it to overlay fullscreen content.
 *
 * @param {FpsDisplayProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered FPS counter (either inline or portalled), or null if `showFpsCounter` is false.
 */
const FpsDisplay = ({ showFpsCounter, isFullscreenActive, portalContainer }) => {
  const [currentFps, setCurrentFps] = useState(0);
  /** @type {React.RefObject<number>} */
  const fpsFrameCountRef = useRef(0);
  /** @type {React.RefObject<number>} */
  const fpsLastTimeRef = useRef(performance.now());
  /** @type {React.RefObject<number | null>} */
  const fpsRafId = useRef(null);

  useEffect(() => {
    /**
     * Calculates FPS based on frame counts over time.
     * This function is called recursively via `requestAnimationFrame`.
     */
    const updateFps = () => {
      const now = performance.now();
      const delta = now - fpsLastTimeRef.current;
      fpsFrameCountRef.current++;

      if (delta >= 1000) { // Update FPS display approximately every second
        const fps = Math.round((fpsFrameCountRef.current * 1000) / delta);
        setCurrentFps(fps);
        fpsFrameCountRef.current = 0; // Reset frame count for the next second
        fpsLastTimeRef.current = now; // Reset time for the next second
      }
      // Continue the loop
      if (typeof requestAnimationFrame === 'function') {
        fpsRafId.current = requestAnimationFrame(updateFps);
      }
    };

    if (showFpsCounter) {
      // Start FPS calculation if it's not already running
      if (!fpsRafId.current && typeof requestAnimationFrame === 'function') {
        fpsLastTimeRef.current = performance.now(); // Reset timer before starting
        fpsFrameCountRef.current = 0;
        fpsRafId.current = requestAnimationFrame(updateFps);
      }
    } else {
      // Stop FPS calculation if `showFpsCounter` becomes false
      if (fpsRafId.current && typeof cancelAnimationFrame === 'function') {
        cancelAnimationFrame(fpsRafId.current);
        fpsRafId.current = null;
      }
      setCurrentFps(0); // Reset displayed FPS when counter is hidden
    }

    // Cleanup function: stop the animation frame loop when the component unmounts
    // or when `showFpsCounter` changes, to prevent memory leaks.
    return () => {
      if (fpsRafId.current && typeof cancelAnimationFrame === 'function') {
        cancelAnimationFrame(fpsRafId.current);
        fpsRafId.current = null; // Ensure ref is cleared
      }
    };
  }, [showFpsCounter]); // Effect dependencies: only re-run if `showFpsCounter` changes

  // If the FPS counter is not meant to be shown, render nothing.
  if (!showFpsCounter) {
    return null;
  }

  const fpsCounterElement = (
    <div className="fps-counter" aria-live="off"> {/* aria-live="off" as it updates too frequently for assertive/polite */}
      FPS: {currentFps}
    </div>
  );

  // Use React Portal if a portalContainer is provided and fullscreen is active.
  // This allows the FPS counter to be rendered outside its normal DOM hierarchy,
  // useful for overlaying it on fullscreen content.
  if (portalContainer && isFullscreenActive && typeof ReactDOM.createPortal === 'function') {
    return ReactDOM.createPortal(fpsCounterElement, portalContainer);
  }

  // Otherwise, render the FPS counter inline.
  return fpsCounterElement;
};

FpsDisplay.propTypes = {
  /** If true, the FPS counter is rendered and active. */
  showFpsCounter: PropTypes.bool.isRequired,
  /** Indicates if the application is currently in fullscreen mode. */
  isFullscreenActive: PropTypes.bool.isRequired,
  /** Optional DOM element to which the FPS counter should be portalled when in fullscreen mode. */
  portalContainer: PropTypes.instanceOf(Element), // Element is the base type for DOM elements
};

FpsDisplay.defaultProps = {
  // portalContainer defaults to null if not provided, which is fine.
  // No explicit default needed here as the conditional logic handles null.
};

// Default export is standard for React components.
export default FpsDisplay;
```

---
### `src\components\MainViewParts\StatusIndicator.jsx`
```jsx
// src/components/MainViewParts/StatusIndicator.jsx (Assuming path based on context)
import React from 'react';
import PropTypes from 'prop-types';

// Assuming common styles for status display are in a shared or component-specific CSS file.
// For example: import './StatusIndicator.css';
// Or, if styles are in Mainview.css as hinted, ensure that's loaded by the parent.

/**
 * @typedef {'initializing' | 'waiting_layout' | 'initializing_managers' | 'loading_defaults' | 'resolving_initial_config' | 'fading_out' | 'applying_config' | 'rendered' | 'error' | 'prompt_connect'} RenderStateValue - Possible states of the render lifecycle, influencing the indicator's appearance.
 */

/**
 * @typedef {object} StatusIndicatorProps
 * @property {boolean} showStatusDisplay - Determines if the status indicator should be visible at all.
 * @property {boolean} isStatusFadingOut - If true, applies a fade-out animation class to the indicator.
 * @property {RenderStateValue} renderState - The current rendering lifecycle state, used to determine specific styling (e.g., for errors).
 * @property {string} loadingStatusMessage - The message to display within the indicator (e.g., "Loading...", "Error...", "Connecting...").
 * @property {boolean} showRetryButton - If true, a "Retry Render" button is displayed alongside the status message, typically in recoverable error states.
 * @property {() => void} onManualRetry - Callback function invoked when the "Retry Render" button is clicked.
 */

/**
 * StatusIndicator: A component that displays the current loading status, error messages,
 * or other informational messages related to the application's rendering lifecycle.
 * It can show a retry button in certain error states and supports fade-out animations.
 *
 * @param {StatusIndicatorProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered StatusIndicator component, or null if `showStatusDisplay` is false.
 */
const StatusIndicator = ({
  showStatusDisplay,
  isStatusFadingOut,
  renderState,
  loadingStatusMessage,
  showRetryButton,
  onManualRetry,
}) => {
  // If the indicator should not be shown at all, render nothing.
  if (!showStatusDisplay) {
    return null;
  }

  /**
   * Determines the appropriate CSS class for the status display based on the renderState.
   * @returns {string} CSS class name (e.g., 'error-state', 'prompt-connect-state', 'info-state').
   */
  const getStatusDisplayClass = () => {
    if (renderState === 'error') return 'error-state'; // Specific styling for critical errors
    if (renderState === 'prompt_connect') return 'prompt-connect-state'; // Styling for connection prompts
    return 'info-state'; // Default styling for other informational messages
  };

  /**
   * Renders the content of the status display, which can include the status message
   * and an optional retry button.
   * @returns {JSX.Element} The content to be rendered inside the status display.
   */
  const renderStatusContent = () => {
    if (showRetryButton) {
      return (
        <>
          <span>{loadingStatusMessage}</span> {/* Wrap message in span for better structure */}
          <button onClick={onManualRetry} className="retry-render-button">
            Retry Render
          </button>
        </>
      );
    }
    return <span>{loadingStatusMessage}</span>; // Wrap message in span
  };

  return (
    <div
      className={`status-display ${getStatusDisplayClass()} ${
        isStatusFadingOut ? 'fade-out' : '' // Apply fade-out class for animations
      }`}
      role="status" // Accessibility: Indicates this region's content may change and is a status message
      aria-live="polite" // Accessibility: Announce changes politely
      aria-atomic="true" // Accessibility: Announce the entire region when it changes
    >
      {renderStatusContent()}
    </div>
  );
};

StatusIndicator.propTypes = {
  /** Determines if the status indicator should be visible. */
  showStatusDisplay: PropTypes.bool.isRequired,
  /** If true, applies a fade-out animation class. */
  isStatusFadingOut: PropTypes.bool.isRequired,
  /** The current rendering lifecycle state, influencing styling. */
  renderState: PropTypes.string.isRequired,
  /** The message to display. */
  loadingStatusMessage: PropTypes.string.isRequired,
  /** If true, a "Retry Render" button is displayed. */
  showRetryButton: PropTypes.bool.isRequired,
  /** Callback for the "Retry Render" button. */
  onManualRetry: PropTypes.func.isRequired,
};

// Default export is standard for React components.
export default StatusIndicator;
```

---
### `src\components\MIDI\GlobalMIDIStatus.jsx`
```jsx
// src/components/MIDI/GlobalMIDIStatus.jsx
import React from 'react';
import { useMIDI } from '../../context/MIDIContext';
import './MIDIStyles/GlobalMIDIStatus.css';
import { midiIcon } from '../../assets';

/**
 * GlobalMIDIStatus: Displays the current MIDI connection status.
 * Allows initiating connection, disconnecting, or retrying on error.
 * Also shows a small indicator when MIDI learn mode is active.
 */
const GlobalMIDIStatus = () => {
  const {
    isConnected,
    isConnecting,
    connectMIDI,
    disconnectMIDI, // Get disconnectMIDI from context
    error: midiError,
    midiLearning,
    learningLayer,
  } = useMIDI();

  const hasCriticalError = !!midiError;

  const handleConnectionClick = () => {
    if (isConnected) {
      // If connected, disconnect MIDI entirely
      disconnectMIDI(true); // Pass true for a user-initiated full disconnect
    } else if (!isConnecting) {
      // If disconnected and not currently connecting, try to connect
      connectMIDI()
        .catch(err => {
          console.error("[GlobalMIDIStatus] connectMIDI promise rejected:", err);
        });
    }
    // If isConnecting, do nothing (connection already in progress)
  };

  const buttonTitle = hasCriticalError ? `MIDI Error: ${midiError?.message || 'Click to retry connection'}`
                     : isConnecting ? "Connecting MIDI..."
                     : isConnected ? "MIDI Connected - Click to Disconnect"
                     : "MIDI Disconnected - Click to Connect";

  const buttonClass = `toolbar-icon ${hasCriticalError ? 'error' : isConnected ? 'connected' : 'disconnected'} ${isConnecting ? 'connecting' : ''}`;

  return (
    <div className="global-midi-status">
      <button
        className={buttonClass}
        onClick={handleConnectionClick}
        disabled={isConnecting && !isConnected} // Disable only if connecting and not yet connected
        title={buttonTitle}
      >
        {hasCriticalError ? (
           <span style={{color: 'var(--color-error, red)', fontSize: '1.2em', fontWeight: 'bold'}}>!</span>
        ) : isConnecting ? (
           <div className="connecting-spinner"></div>
        ) : (
          <img src={midiIcon} alt="MIDI" className="midi-icon" />
        )}
      </button>

      {(midiLearning || learningLayer !== null) && (
        <div className="midi-learning-indicator">
          {midiLearning ? (
            <span>Mapping: {midiLearning.param}</span>
          ) : (
            <span>Mapping: Layer {learningLayer}</span>
          )}
        </div>
      )}
    </div>
  );
};

export default GlobalMIDIStatus;
```

---
### `src\components\MIDI\MIDIStyles\GlobalMIDIStatus.css`
```css
.global-midi-status {
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  position: relative;
}

.global-midi-status .toolbar-icon {
  width: 35px;
  height: 35px;
  padding: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background: var(--color-primary-a15);
  border: 1px solid var(--color-primary-a30);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all var(--transition-normal);
  box-shadow: var(--shadow-sm);
  flex-shrink: 0;
}

.global-midi-status .toolbar-icon:hover {
  background: var(--color-primary-a25);
  transform: translateY(-1px);
  box-shadow: var(--shadow-primary-md);
}

.global-midi-status .toolbar-icon.disconnected {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
}
.global-midi-status .toolbar-icon.disconnected .midi-icon {
   opacity: 0.6;
   filter: grayscale(80%);
   animation: none;
}

.global-midi-status .toolbar-icon.connected {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a30);
}

.global-midi-status .toolbar-icon.connecting .connecting-spinner {
  display: block;
}
.global-midi-status .toolbar-icon.connecting .midi-icon {
    display: none;
}

.global-midi-status .toolbar-icon.error {
  background: var(--color-error-a10);
  border-color: var(--color-error-a30);
  color: var(--color-error);
  animation: error-pulse 1.5s infinite ease-in-out;
}
.global-midi-status .toolbar-icon.error .midi-icon {
    display: none;
}

.connecting-spinner {
  display: none;
  width: 20px;
  height: 20px;
  border: 3px solid var(--color-primary-a30);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

@keyframes midi-active-pulse {
  0%, 100% { transform: scale(1); opacity: 0.8; filter: drop-shadow(0 0 4px var(--color-primary-a30)); }
  50% { transform: scale(1.08); opacity: 1; filter: drop-shadow(0 0 7px var(--color-primary-a70)); }
}

.global-midi-status .toolbar-icon.connected .midi-icon {
  animation: midi-active-pulse 1.8s infinite ease-in-out;
}

.midi-learning-indicator {
  position: absolute;
  bottom: calc(100% + 4px);
  right: 0;
  background: var(--color-accent-a20);
  color: var(--color-accent);
  border: 1px solid var(--color-accent-a30);
  border-radius: var(--radius-sm);
  padding: 3px 8px;
  font-size: var(--font-size-xs);
  white-space: nowrap;
  animation: blink 1s infinite;
  box-shadow: var(--shadow-sm);
  z-index: 1;
}

.mini-midi-monitor {
  position: absolute;
  bottom: calc(100% + 4px);
  right: 0;
  width: 220px;
  background: var(--color-glass-bg-dark);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  z-index: 0;
}

.monitor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 10px;
  background: var(--color-primary-a05);
  border-bottom: 1px solid var(--color-border);
}

.monitor-header h4 {
  margin: 0;
  font-size: var(--font-size-sm);
  color: var(--color-primary);
}

.close-monitor {
  background: none; border: none;
  color: var(--color-primary-a70);
  font-size: 16px; cursor: pointer; padding: 0; line-height: 1;
  transition: color var(--transition-fast);
}
.close-monitor:hover { color: var(--color-primary); }

.monitor-content {
  max-height: 150px; overflow-y: auto; padding: 5px;
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
}
.monitor-content::-webkit-scrollbar { width: 6px; height: 6px; }
.monitor-content::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; }
.monitor-content::-webkit-scrollbar-thumb { background: var(--color-primary-a30); border-radius: 3px; }
.monitor-content::-webkit-scrollbar-thumb:hover { background: var(--color-primary-a50); }

.no-activity {
  padding: 5px; color: var(--color-text-muted);
  text-align: center; font-size: var(--font-size-xs);
  font-style: italic;
}

.midi-message {
  display: flex; justify-content: space-between; font-family: monospace;
  font-size: 10px; padding: 2px 5px;
  border-bottom: 1px solid var(--color-border-light);
  white-space: nowrap;
}

.msg-type { color: var(--color-primary-a90); width: 70px; overflow: hidden; text-overflow: ellipsis; }
.msg-channel { color: var(--color-accent); width: 35px; }
.msg-data { color: var(--color-text); flex-grow: 1; text-align: right; }

@keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
@keyframes error-pulse { 0%, 100% { box-shadow: 0 0 3px var(--color-error-a30); } 50% { box-shadow: 0 0 8px var(--color-error-a70); } }

.midi-icon {
  width: 20px;
  height: 20px;
  object-fit: contain;
  pointer-events: none;
  transition: opacity 0.3s ease, filter 0.3s ease;
}
```

---
### `src\components\Notifications\Toast.jsx`
```jsx
// src/components/Toast/Toast.jsx
import React, { useEffect, useState, useCallback } from 'react'; // Added useCallback
import PropTypes from 'prop-types';

import './ToastStyles.css'; // Local styles

/**
 * @typedef {'info' | 'success' | 'warning' | 'error'} ToastType - The type of the toast, influencing its appearance.
 */

/**
 * @typedef {object} ToastProps
 * @property {string|number} id - Unique identifier for the toast message.
 * @property {React.ReactNode} content - The content of the toast message. Can be a string or a React node.
 * @property {ToastType} [type='info'] - The type of the toast (e.g., 'info', 'success').
 * @property {number | null} [duration] - Optional: The duration in milliseconds for which the toast should be visible.
 *                                     If provided and positive, the toast will start fading out before this duration ends.
 *                                     If null or 0, it remains until manually dismissed.
 * @property {(id: string|number) => void} onDismiss - Callback function invoked when the toast requests to be dismissed, either manually or after its duration. It receives the toast's `id`.
 */

/**
 * Toast: Displays a single notification message.
 * It manages its own visibility state for fade-in/fade-out animations.
 * It can be dismissed manually via a close button or automatically after a specified `duration`.
 * The actual removal from the list of active toasts is handled by the `onDismiss` callback,
 * which is typically provided by a `ToastProvider` or a similar state management system.
 *
 * @param {ToastProps} props - The component's props.
 * @returns {JSX.Element} The rendered Toast component.
 */
const Toast = ({ id, content, type = 'info', duration, onDismiss }) => {
  // `isVisible` controls the CSS class for fade-in/fade-out animations.
  const [isVisible, setIsVisible] = useState(false);

  // Effect for managing the toast's lifecycle (fade-in and timed fade-out)
  useEffect(() => {
    // Trigger fade-in animation shortly after mount
    const fadeInTimer = setTimeout(() => {
      setIsVisible(true);
    }, 10); // Small delay to ensure CSS transition applies

    let fadeOutTimer = null;
    let dismissTimer = null;

    // If a positive duration is provided, set up automatic fade-out and dismissal
    if (duration && duration > 0) {
      // Start fade-out animation slightly before the full duration to allow for CSS transition
      const fadeOutStartTime = Math.max(0, duration - 300); // Ensure non-negative

      fadeOutTimer = setTimeout(() => {
        setIsVisible(false); // Trigger fade-out animation
      }, fadeOutStartTime);

      // Set timer to call onDismiss after the full duration (allowing fade-out to complete)
      dismissTimer = setTimeout(() => {
        if (typeof onDismiss === 'function') {
          onDismiss(id);
        }
      }, duration);
    }

    // Cleanup function: clear all timers when the component unmounts
    // or if `id` or `duration` changes (which would re-run this effect).
    return () => {
      clearTimeout(fadeInTimer);
      if (fadeOutTimer) clearTimeout(fadeOutTimer);
      if (dismissTimer) clearTimeout(dismissTimer);
    };
  }, [id, duration, onDismiss]); // `onDismiss` is included as it's part of the effect's logic flow

  /**
   * Handles manual dismissal of the toast via the close button.
   * It first triggers the fade-out animation and then calls the `onDismiss` callback
   * after the animation duration.
   */
  const handleDismiss = useCallback(() => {
    setIsVisible(false); // Start fade-out animation
    // Call the actual removal function (onDismiss) after the fade animation (300ms) completes.
    setTimeout(() => {
      if (typeof onDismiss === 'function') {
        onDismiss(id);
      }
    }, 300); // This duration should match the CSS transition duration for opacity/transform
  }, [id, onDismiss]); // `id` and `onDismiss` are dependencies

  return (
    <div
      className={`toast toast-${type} ${isVisible ? 'visible' : 'hidden'}`}
      role="alert" // Accessibility: Indicates it's an alert
      aria-live="assertive" // Accessibility: Announce changes assertively
      aria-atomic="true"
    >
      <div className="toast-content">{content}</div>
      <button
        onClick={handleDismiss}
        className="toast-dismiss-button"
        aria-label="Dismiss notification" // Accessibility
        title="Dismiss" // Tooltip
      >
        × {/* Standard multiplication sign for 'close' */}
      </button>
    </div>
  );
};

Toast.propTypes = {
  /** Unique identifier for the toast message. */
  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
  /** The content of the toast message. Can be a string or any renderable React node. */
  content: PropTypes.node.isRequired,
  /** The type of the toast, influencing its visual style (e.g., 'info', 'success', 'warning', 'error'). */
  type: PropTypes.oneOf(['info', 'success', 'warning', 'error']),
  /**
   * Optional duration in milliseconds for the toast to be visible.
   * If provided and positive, the toast will auto-dismiss.
   * If null, 0, or not provided, it remains until manually dismissed.
   */
  duration: PropTypes.number,
  /** Callback function invoked when the toast requests to be dismissed (receives toast `id`). */
  onDismiss: PropTypes.func.isRequired,
};

// Default export is standard for React components.
export default Toast;
```

---
### `src\components\Notifications\Toast.test.jsx`
```jsx
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import Toast from './Toast'; // Adjust path if necessary

describe('Toast Component', () => {
  // Setup fake timers before each test to control setTimeout
  beforeEach(() => {
    vi.useFakeTimers();
  });

  // Restore real timers after each test
  afterEach(() => {
    vi.restoreAllMocks(); // This also clears all timers
  });

  it('should render the toast content correctly', () => {
    const testContent = "This is a test toast message.";
    render(<Toast id="toast1" content={testContent} onDismiss={() => {}} />);
    expect(screen.getByText(testContent)).toBeInTheDocument();
  });

  it('should apply the default "info" class if no type is provided', () => {
    render(<Toast id="toast2" content="Info toast" onDismiss={() => {}} />);
    const toastElement = screen.getByRole('alert');
    expect(toastElement).toHaveClass('toast-info');
  });

  it('should apply the correct class based on the "type" prop (e.g., "error")', () => {
    render(<Toast id="toast3" content="Error toast" type="error" onDismiss={() => {}} />);
    const toastElement = screen.getByRole('alert');
    expect(toastElement).toHaveClass('toast-error');
  });

  it('should apply the "success" class for type "success"', () => {
    render(<Toast id="toast-success" content="Success!" type="success" onDismiss={() => {}} />);
    expect(screen.getByRole('alert')).toHaveClass('toast-success');
  });

  it('should apply the "warning" class for type "warning"', () => {
    render(<Toast id="toast-warning" content="Warning!" type="warning" onDismiss={() => {}} />);
    expect(screen.getByRole('alert')).toHaveClass('toast-warning');
  });

  it('should call onDismiss with the correct id when the dismiss button is clicked', () => {
    const mockOnDismiss = vi.fn();
    const toastId = "toast4";
    render(<Toast id={toastId} content="Dismiss me" onDismiss={mockOnDismiss} />);

    const dismissButton = screen.getByRole('button', { name: /Dismiss notification/i });
    fireEvent.click(dismissButton);

    // The Toast component has a 300ms setTimeout before calling onDismiss
    // We need to advance the timers for that setTimeout to execute
    act(() => {
      vi.advanceTimersByTime(300);
    });

    expect(mockOnDismiss).toHaveBeenCalledTimes(1);
    expect(mockOnDismiss).toHaveBeenCalledWith(toastId);
  });

  it('should call onDismiss after the specified duration if duration is positive', () => {
    const mockOnDismiss = vi.fn();
    const toastId = "toast5";
    const duration = 1500; // 1.5 seconds
    render(<Toast id={toastId} content="Auto dismiss" duration={duration} onDismiss={mockOnDismiss} />);

    // Check it hasn't been called immediately
    expect(mockOnDismiss).not.toHaveBeenCalled();

    // Advance timers by the full duration
    act(() => {
      vi.advanceTimersByTime(duration);
    });

    expect(mockOnDismiss).toHaveBeenCalledTimes(1);
    expect(mockOnDismiss).toHaveBeenCalledWith(toastId);
  });

  it('should NOT call onDismiss automatically if duration is null', () => {
    const mockOnDismiss = vi.fn();
    render(<Toast id="toast6" content="Manual dismiss (duration null)" duration={null} onDismiss={mockOnDismiss} />);

    // Advance timers by a long time, it shouldn't be called
    act(() => {
      vi.advanceTimersByTime(10000); // 10 seconds
    });

    expect(mockOnDismiss).not.toHaveBeenCalled();
  });

  it('should NOT call onDismiss automatically if duration is 0', () => {
    const mockOnDismiss = vi.fn();
    render(<Toast id="toast7" content="Manual dismiss (duration 0)" duration={0} onDismiss={mockOnDismiss} />);

    // Advance timers
    act(() => {
      vi.advanceTimersByTime(10000);
    });

    expect(mockOnDismiss).not.toHaveBeenCalled();
  });

  it('should apply "visible" class after a short delay for fade-in animation', () => {
    render(<Toast id="toast8" content="Fade in test" onDismiss={() => {}} />);
    const toastElement = screen.getByRole('alert');

    // Initially, it might not have 'visible' immediately due to the 10ms setTimeout in Toast.jsx
    // Depending on how fast the test runs, it might already be visible.
    // A more robust check is to advance time slightly.
    expect(toastElement).not.toHaveClass('visible'); // Or check opacity if styles are set up for it

    act(() => {
      vi.advanceTimersByTime(20); // Advance past the 10ms fadeInTimer
    });

    expect(toastElement).toHaveClass('visible');
  });

  it('should remove "visible" class when dismiss button is clicked (for fade-out animation)', () => {
    render(<Toast id="toast9" content="Fade out test" onDismiss={() => {}} />);
    const toastElement = screen.getByRole('alert');

    // Make it visible first
    act(() => {
      vi.advanceTimersByTime(20);
    });
    expect(toastElement).toHaveClass('visible');

    // Click dismiss
    const dismissButton = screen.getByRole('button', { name: /Dismiss notification/i });
    fireEvent.click(dismissButton);

    // The 'visible' class should be removed immediately to start the fade-out CSS transition
    expect(toastElement).not.toHaveClass('visible');
    expect(toastElement).toHaveClass('hidden'); // Assuming 'hidden' is the opposite of 'visible'
  });

  it('should remove "visible" class when auto-dismissing (for fade-out animation)', () => {
    const duration = 500;
    render(<Toast id="toast10" content="Auto fade out" duration={duration} onDismiss={() => {}} />);
    const toastElement = screen.getByRole('alert');

    // Make it visible
    act(() => {
      vi.advanceTimersByTime(20);
    });
    expect(toastElement).toHaveClass('visible');

    // Advance time to just before full duration (when fade-out starts)
    // fadeOutStartTime = Math.max(0, duration - 300); -> 500 - 300 = 200ms
    act(() => {
      vi.advanceTimersByTime(200);
    });

    expect(toastElement).not.toHaveClass('visible');
    expect(toastElement).toHaveClass('hidden');
  });
});
```

---
### `src\components\Notifications\ToastContainer.jsx`
```jsx
// src/components/Toast/ToastContainer.jsx
import React from 'react';
// Removed PropTypes as it's not used in this specific file

import { useToast } from '../../context/ToastContext'; // Local context
import Toast from './Toast'; // Local component

import './ToastStyles.css'; // Local styles

/**
 * ToastContainer: A component responsible for rendering a list of active toast notifications.
 * It retrieves the current list of toasts and the `removeToast` function from the `ToastContext`.
 * Each toast is rendered using the `Toast` component. If there are no active toasts,
 * the container itself is not rendered to avoid an empty DOM element.
 *
 * @returns {JSX.Element | null} The rendered ToastContainer with active toasts, or null if no toasts are present.
 */
const ToastContainer = () => {
  const { toasts, removeToast } = useToast(); // Consume from ToastContext

  // Don't render the container at all if there are no toasts to display.
  // This keeps the DOM cleaner.
  if (!toasts || toasts.length === 0) {
    return null;
  }

  return (
    <div className="toast-container" role="status" aria-live="polite" aria-atomic="true">
      {/*
        Map over the active toasts and render a Toast component for each.
        - `key` is essential for React's list rendering.
        - `onDismiss` is passed down to allow individual toasts to trigger their removal.
      */}
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          id={toast.id} // Pass id for the Toast component to use with onDismiss
          content={toast.content}
          type={toast.type}
          duration={toast.duration} // Duration is for information or if Toast handles its own timer
          onDismiss={removeToast} // Pass the removeToast function from context
        />
      ))}
    </div>
  );
};

// No PropTypes needed for ToastContainer itself as it takes no props.
// Default export is standard for React components.
export default ToastContainer;
```

---
### `src\components\Notifications\ToastContainer.test.jsx`
```jsx
import React from 'react';
import PropTypes from 'prop-types';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { ToastProvider, useToast } from '../../context/ToastContext'; // Adjust path if necessary
import ToastContainer from './ToastContainer';
// Toast component is implicitly tested as it's rendered by ToastContainer

// Helper component to add toasts for testing purposes
const ToastTrigger = ({ id, content, type, duration }) => {
  const { addToast } = useToast();

  // Use a button to trigger adding a toast so we can control when it happens in tests
  return (
    <button
      data-testid={`add-toast-${id}`}
      onClick={() => addToast(content, type, duration)}
    >
      Add Toast {id}
    </button>
  );
};

// PropTypes for the helper component
ToastTrigger.propTypes = {
  id: PropTypes.string.isRequired,
  content: PropTypes.node.isRequired,
  type: PropTypes.string,
  duration: PropTypes.number,
};


describe('ToastContainer Component', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should render nothing if there are no toasts', () => {
    render(
      <ToastProvider>
        <ToastContainer />
      </ToastProvider>
    );
    // The container itself should not be in the document if no toasts
    expect(screen.queryByRole('status')).not.toBeInTheDocument();
    expect(screen.queryAllByRole('alert').length).toBe(0); // No individual toast alerts
  });

  it('should render a single toast when one is added', () => {
    render(
      <ToastProvider>
        <ToastTrigger id="t1" content="Single Toast Message" />
        <ToastContainer />
      </ToastProvider>
    );

    // Click the button to add the toast
    const addButton = screen.getByTestId('add-toast-t1');
    fireEvent.click(addButton);

    // Advance timers for the Toast component's internal fadeIn
    act(() => {
      vi.advanceTimersByTime(50);
    });

    expect(screen.getByText('Single Toast Message')).toBeInTheDocument();
    expect(screen.getAllByRole('alert').length).toBe(1);
    expect(screen.getByRole('alert')).toHaveClass('toast-info'); // Default type
  });

  it('should render multiple toasts when multiple are added', () => {
    render(
      <ToastProvider>
        <ToastTrigger id="t1" content="First Toast" type="success" />
        <ToastTrigger id="t2" content="Second Toast" type="error" />
        <ToastContainer />
      </ToastProvider>
    );

    fireEvent.click(screen.getByTestId('add-toast-t1'));
    fireEvent.click(screen.getByTestId('add-toast-t2'));

    act(() => {
      vi.advanceTimersByTime(50);
    });

    expect(screen.getByText('First Toast')).toBeInTheDocument();
    expect(screen.getByText('Second Toast')).toBeInTheDocument();
    expect(screen.getAllByRole('alert').length).toBe(2);

    const firstToastElement = screen.getByText('First Toast').closest('.toast');
    const secondToastElement = screen.getByText('Second Toast').closest('.toast');

    expect(firstToastElement).toHaveClass('toast-success');
    expect(secondToastElement).toHaveClass('toast-error');
  });

  it('should remove a toast when its dismiss button is clicked', () => {
    render(
      <ToastProvider>
        <ToastTrigger id="t1" content="Toast to dismiss" />
        <ToastContainer />
      </ToastProvider>
    );

    fireEvent.click(screen.getByTestId('add-toast-t1'));
    act(() => { vi.advanceTimersByTime(50); }); // For fade-in

    let toastElement = screen.getByText('Toast to dismiss');
    expect(toastElement).toBeInTheDocument();

    const dismissButton = screen.getByRole('button', { name: /Dismiss notification/i });
    fireEvent.click(dismissButton);

    // Advance timers for the Toast component's internal onDismiss setTimeout
    act(() => {
      vi.advanceTimersByTime(300);
    });

    expect(screen.queryByText('Toast to dismiss')).not.toBeInTheDocument();
    expect(screen.queryAllByRole('alert').length).toBe(0);
  });

  it('should remove a toast automatically after its duration', () => {
    const shortDuration = 500;
    render(
      <ToastProvider>
        <ToastTrigger id="t1" content="Auto-dismissing toast" duration={shortDuration} />
        <ToastContainer />
      </ToastProvider>
    );

    fireEvent.click(screen.getByTestId('add-toast-t1'));
    act(() => { vi.advanceTimersByTime(50); }); // For fade-in

    expect(screen.getByText('Auto-dismissing toast')).toBeInTheDocument();

    // Advance timers past the toast's duration
    act(() => {
      vi.advanceTimersByTime(shortDuration + 100); // Add a small buffer
    });

    expect(screen.queryByText('Auto-dismissing toast')).not.toBeInTheDocument();
    expect(screen.queryAllByRole('alert').length).toBe(0);
  });

  it('should render toasts in the order they are added (newest on top/bottom depending on CSS)', () => {
    // This test assumes newest toasts appear first in the DOM if prepended,
    // or last if appended. Your CSS determines visual order (top/bottom).
    // We'll check the order in the DOM.
    render(
      <ToastProvider>
        <ToastTrigger id="t1" content="Oldest Toast" />
        <ToastTrigger id="t2" content="Middle Toast" />
        <ToastTrigger id="t3" content="Newest Toast" />
        <ToastContainer />
      </ToastProvider>
    );

    fireEvent.click(screen.getByTestId('add-toast-t1'));
    fireEvent.click(screen.getByTestId('add-toast-t2'));
    fireEvent.click(screen.getByTestId('add-toast-t3'));

    act(() => { vi.advanceTimersByTime(50); });

    const allToasts = screen.getAllByRole('alert');
    expect(allToasts.length).toBe(3);

    // Your ToastProvider appends new toasts, so "Oldest Toast" is first in the DOM list.
    expect(allToasts[0]).toHaveTextContent('Oldest Toast');
    expect(allToasts[1]).toHaveTextContent('Middle Toast');
    expect(allToasts[2]).toHaveTextContent('Newest Toast');
  });
});
```

---
### `src\components\Notifications\ToastStyles.css`
```css
@import "../../styles/variables.css";

.toast-container {
  position: fixed;
  bottom: var(--space-lg, 20px);
  right: var(--space-lg, 20px);
  z-index: var(--z-top, 2000);
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--space-sm, 12px);
  pointer-events: none; /* Container doesn't block */
}

.toast {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-sm, 12px) var(--space-md, 16px);
  border-radius: var(--radius-md, 6px);
  box-shadow: var(--shadow-md, 0 4px 10px rgba(0, 0, 0, 0.3));
  color: var(--color-text, #eee);
  font-size: var(--font-size-md, 14px);
  min-width: 250px;
  max-width: 400px;
  pointer-events: auto; /* Toasts are interactive */
  opacity: 0;
  transform: translateX(100%);
  transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
  border: 1px solid transparent;
}

.toast.visible {
  opacity: 1;
  transform: translateX(0);
}

.toast-info {
  background-color: var(--color-primary-a15, rgba(0, 243, 255, 0.15));
  border-color: var(--color-primary-a30, rgba(0, 243, 255, 0.3));
  color: var(--color-primary, #00f3ff);
}

.toast-success {
  background-color: var(--color-success-a10, rgba(0, 255, 0, 0.1));
  border-color: var(--color-success-a30, rgba(0, 255, 0, 0.3));
  color: var(--color-success, #00ff00);
}

.toast-warning {
  background-color: var(--color-warning-a10, rgba(255, 165, 0, 0.1));
  border-color: var(--color-warning-a30, rgba(255, 165, 0, 0.3));
  color: var(--color-warning, #ffa500);
}

.toast-error {
  background-color: var(--color-error-a10, rgba(255, 85, 85, 0.1));
  border-color: var(--color-error-a30, rgba(255, 85, 85, 0.3));
  color: var(--color-error, #ff5555);
}

.toast-content {
  margin-right: var(--space-md, 16px);
  flex-grow: 1;
}

.toast-dismiss-button {
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  font-size: 20px;
  line-height: 1;
  cursor: pointer;
  padding: 0 0 0 var(--space-xs);
  margin-left: var(--space-sm);
}

.toast-dismiss-button:hover {
  opacity: 1;
}
```

---
### `src\components\Panels\EnhancedControlPanel.jsx`
```jsx
// src/components/Panels/EnhancedControlPanel.jsx
import React, { useCallback, useMemo, useEffect, useRef, useState } from "react";
import PropTypes from "prop-types";

import Panel from "./Panel";
import { useProfileSessionState, useVisualLayerState } from "../../hooks/configSelectors";
import { useMIDI } from "../../context/MIDIContext";

import {
  toplayerIcon,
  middlelayerIcon,
  bottomlayerIcon,
  rotateIcon,
} from "../../assets";

import "./PanelStyles/EnhancedControlPanel.css";

const getDefaultLayerConfigTemplate = () => ({
  enabled: true,
  blendMode: "normal",
  opacity: 1.0,
  size: 1.0,
  speed: 0.01,
  drift: 0,
  driftSpeed: 0.1,
  angle: 0,
  xaxis: 0,
  yaxis: 0,
  direction: 1,
  driftState: {
    x: 0,
    y: 0,
    phase: Math.random() * Math.PI * 2,
    enabled: false,
  },
});


const formatValue = (value, decimals = 1) => {
  const numValue = Number(value);
  if (value === undefined || value === null || isNaN(numValue)) {
    return "0".padEnd(decimals > 0 ? decimals + 2 : 1, "0");
  }
  return numValue.toFixed(decimals);
};

export const sliderParams = [
  { prop: "speed", label: "SPEED", icon: "slidersIcon_placeholder", min: 0.001, max: 0.1, step: 0.001, formatDecimals: 3 },
  { prop: "size", label: "SIZE", icon: "enlargeIcon_placeholder", min: 0.1, max: 8.0, step: 0.01, formatDecimals: 1 },
  { prop: "opacity", label: "OPACITY", icon: "eyeIcon_placeholder", min: 0, max: 1, step: 0.001, formatDecimals: 2, defaultValue: 1 },
  { prop: "drift", label: "DRIFT", icon: "wavesIcon_placeholder", min: 0, max: 100, step: 0.001, formatDecimals: 1 },
  { prop: "driftSpeed", label: "DRIFT SPEED", icon: "wavezIcon_placeholder", min: 0, max: 1, step: 0.001, formatDecimals: 1 },
  { prop: "xaxis", label: "X POS", icon: "horizontalviewIcon_placeholder", min: -10000, max: 10000, step: 0.001, formatDecimals: 0 },
  { prop: "yaxis", label: "Y POS", icon: "verticalviewIcon_placeholder", min: -10000, max: 10000, step: 0.001, formatDecimals: 0 },
  { prop: "angle", label: "ANGLE", icon: "rotateIcon_placeholder", min: -360, max: 360, step: 0.001, formatDecimals: 1 },
];

const tabToLayerIdMap = { tab1: 3, tab2: 2, tab3: 1 };

/**
 * @typedef EnhancedControlPanelProps
 * @property {(layerId: string | number, key: string, value: any) => void} onLayerConfigChange - Callback to update a layer's configuration.
 * @property {Array<string>} blendModes - Array of available blend mode strings.
 * @property {() => void} onToggleMinimize - Callback to toggle the panel's minimized state.
 * @property {string} [activeTab="tab1"] - The currently active layer tab.
 * @property {(tabId: string) => void} [onTabChange] - Callback when a layer tab is changed.
 * @property {(newIntervalMs: number) => void} [onSetSequencerInterval] - Optional callback to set the sequencer interval.
 */

/**
 * EnhancedControlPanel provides UI controls for manipulating parameters
 * of visual layers, MIDI mappings, and potentially other global settings like sequencer interval.
 *
 * @param {EnhancedControlPanelProps} props - Component props.
 * @returns {JSX.Element} The rendered EnhancedControlPanel.
 */
const EnhancedControlPanel = ({
  onLayerConfigChange,
  blendModes,
  onToggleMinimize,
  activeTab = "tab1",
  onTabChange,
  onSetSequencerInterval,
}) => {
  const {
    isVisitor,
    isParentAdmin,
    isPreviewMode,
    canSave,
    isProfileOwner,
    currentProfileAddress: hostProfileAddress
  } = useProfileSessionState();
  const { layerConfigs } = useVisualLayerState();

  const disableHostLayerControls = useMemo(() => !hostProfileAddress, [hostProfileAddress]);

  const {
    isConnected: midiConnected,
    midiLearning,
    learningLayer,
    selectedChannel,
    showMidiMonitor,
    midiMonitorData,
    setShowMidiMonitor,
    startMIDILearn,
    stopMIDILearn,
    startLayerMIDILearn,
    stopLayerMIDILearn,
    clearAllMappings,
    setChannelFilter,
    clearMIDIMonitor,
    midiMap,
    layerMappings,
  } = useMIDI();

  const activeLayer = useMemo(() => tabToLayerIdMap[activeTab] || 1, [activeTab]);
  const config = useMemo(() => layerConfigs?.[activeLayer] || getDefaultLayerConfigTemplate(), [layerConfigs, activeLayer]);

  const midiMonitorRef = useRef(null);
  const [localSequencerInterval, setLocalSequencerInterval] = useState("10");

  useEffect(() => {
    if (midiMonitorRef.current && showMidiMonitor) {
      midiMonitorRef.current.scrollTop = midiMonitorRef.current.scrollHeight;
    }
  }, [midiMonitorData, showMidiMonitor]);

  const handleEnterMIDILearnMode = useCallback(
    (paramName) => {
      if (!isProfileOwner) return;
      if (!midiConnected) { alert("Please connect a MIDI device first to enable MIDI Learn."); return; }
      const isValidParam = sliderParams.some((p) => p.prop === paramName);
      if (!isValidParam) {
        if (import.meta.env.DEV) console.warn(`[ECP] Attempted to learn MIDI for invalid param: ${paramName}`);
        return;
      }
      startMIDILearn(paramName, activeLayer);
    },
    [isProfileOwner, midiConnected, startMIDILearn, activeLayer],
  );

  const handleEnterLayerMIDILearnMode = useCallback(
    (layer) => {
      if (!isProfileOwner) return;
      if (!midiConnected) { alert("Please connect a MIDI device first."); return; }
      startLayerMIDILearn(layer);
    },
    [isProfileOwner, midiConnected, startLayerMIDILearn],
  );

  const handleMidiChannelChange = useCallback((e) => { setChannelFilter(parseInt(e.target.value, 10)); }, [setChannelFilter]);
  const handleClearMidiMonitor = useCallback(() => { clearMIDIMonitor(); }, [clearMIDIMonitor]);

  const handleResetAllMappings = useCallback(() => {
    if (disableHostLayerControls || !canSave) {
      if (import.meta.env.DEV) {
        console.warn("[ECP] Reset all MIDI mappings (for host profile) blocked. DisableHostControls:", disableHostLayerControls, "CanSave:", canSave);
      }
      return;
    }
    clearAllMappings();
  }, [disableHostLayerControls, canSave, clearAllMappings]);

  const handleToggleMonitor = useCallback(() => { setShowMidiMonitor(prev => !prev); }, [setShowMidiMonitor]);
  const handleCancelMIDILearn = useCallback(() => { stopMIDILearn?.(); }, [stopMIDILearn]);
  const handleCancelLayerMIDILearn = useCallback(() => { stopLayerMIDILearn?.(); }, [stopLayerMIDILearn]);

  const displayMidiMapping = useCallback(
    (layer, param) => {
      const mapping = midiMap?.[String(layer)]?.[param];
      if (!mapping) return "None";
      const channelDisplay = mapping.channel !== undefined ? ` (Ch ${mapping.channel + 1})` : "";
      if (mapping.type === "cc") return `CC ${mapping.number}${channelDisplay}`;
      if (mapping.type === "note") return `Note ${mapping.number}${channelDisplay}`;
      if (mapping.type === "pitchbend") return `Pitch${channelDisplay}`;
      return "Unknown";
    },
    [midiMap],
  );

  const displayLayerMidiMapping = useCallback(
    (layer) => {
      const mapping = layerMappings[String(layer)]?.layerSelect;
      if (!mapping) return "-";
      const channelDisplay = mapping.channel !== undefined ? ` (Ch ${mapping.channel + 1})` : "";
      if (mapping.type === "note") return `Note ${mapping.number}${channelDisplay}`;
      return "Unknown";
    },
    [layerMappings],
  );

  const handleSliderChange = useCallback((e) => {
    if (disableHostLayerControls) return;
    const { name, value } = e.target;
    const parsedValue = parseFloat(value);
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, name, parsedValue);
    }
  }, [disableHostLayerControls, onLayerConfigChange, activeLayer]);

  const handleBlendModeChange = useCallback((e) => {
    if (disableHostLayerControls) return;
    const { value } = e.target;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, "blendMode", value);
    }
  }, [disableHostLayerControls, onLayerConfigChange, activeLayer]);

  const handleDirectionToggle = useCallback(() => {
    if (disableHostLayerControls) return;
    const currentDirection = config.direction || 1;
    const newDirection = -currentDirection;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, "direction", newDirection);
    }
  }, [disableHostLayerControls, config.direction, onLayerConfigChange, activeLayer]);

  const handleEnabledToggle = useCallback((e) => {
    if (disableHostLayerControls) return;
    const newEnabledState = e.target.checked;
    if (typeof onLayerConfigChange === 'function') {
      onLayerConfigChange(activeLayer, "enabled", newEnabledState);
    }
  }, [disableHostLayerControls, onLayerConfigChange, activeLayer]);

  const handleSequencerIntervalInputChange = (e) => {
    setLocalSequencerInterval(e.target.value);
  };

  const applySequencerInterval = () => {
    if (onSetSequencerInterval) {
        const intervalSeconds = parseFloat(localSequencerInterval);
        if (!isNaN(intervalSeconds) && intervalSeconds >= 1) {
            onSetSequencerInterval(intervalSeconds * 1000);
        } else {
            console.warn("Invalid sequencer interval input.");
            // Optionally, provide user feedback e.g., via a toast
        }
    }
  };

  const adminVisitorMessage = isVisitor && isParentAdmin && !disableHostLayerControls && !canSave && (
    <div className="visitor-message info">
      As an admin visitor, you can experiment with controls. Changes won't save to this profile.
    </div>
  );

  const generalVisitorMessage = isVisitor && !isParentAdmin && !disableHostLayerControls && !canSave && (
      <div className="visitor-message info">
          Viewing another profile. Changes will not be saved.
      </div>
  );

  const readOnlyUIMessage = (disableHostLayerControls || isPreviewMode) && (
    <div className="visitor-message warning">
      {isPreviewMode ? "Preview Mode: Controls are view-only." :
       !hostProfileAddress ? "Connect or load a host profile to enable its layer controls." :
       "Host layer controls are currently disabled."}
    </div>
  );

  const getMIDILearnButtonTitle = (paramProp, paramLabel) => {
    if (!isProfileOwner) return "MIDI Learn disabled when viewing another profile";
    if (!midiConnected) return "Connect MIDI device to enable Learn";
    if (disableHostLayerControls) return "MIDI Learn disabled as host controls are inactive";
    return `Map MIDI to ${paramLabel}. Current: ${displayMidiMapping(String(activeLayer), paramProp)}`;
  };

  const getLayerMIDILearnButtonTitle = (layerNum) => {
    if (!isProfileOwner) return "MIDI Learn for layer selection disabled when viewing another profile";
    if (!midiConnected) return "Connect MIDI device to enable Learn";
    if (disableHostLayerControls) return "MIDI Learn disabled as host controls are inactive";
    return `Map MIDI to select Layer ${layerNum}`;
  };


  return (
    <Panel
      title={`Layer ${activeLayer} Controls`}
      onClose={onToggleMinimize}
      className="panel-from-toolbar enhanced-control-panel"
    >
      <div className="compact-panel-header">
        <div className="tab-navigation">
          <button type="button" className={`tab-button ${activeTab === "tab1" ? "active" : ""}`} onClick={() => onTabChange && onTabChange("tab1")} title={`Layer 3 (Top)`} aria-label="Select Top Layer (Layer 3)"> <img src={toplayerIcon} alt="L3" className="tab-icon" /> </button>
          <button type="button" className={`tab-button ${activeTab === "tab2" ? "active" : ""}`} onClick={() => onTabChange && onTabChange("tab2")} title={`Layer 2 (Middle)`} aria-label="Select Middle Layer (Layer 2)"> <img src={middlelayerIcon} alt="L2" className="tab-icon" /> </button>
          <button type="button" className={`tab-button ${activeTab === "tab3" ? "active" : ""}`} onClick={() => onTabChange && onTabChange("tab3")} title={`Layer 1 (Bottom)`} aria-label="Select Bottom Layer (Layer 1)"> <img src={bottomlayerIcon} alt="L1" className="tab-icon" /> </button>
        </div>
      </div>

      {(midiLearning || learningLayer !== null) && (
        <div className={`midi-learning-container ${learningLayer !== null ? "layer-learning" : ""}`} >
          <span className="midi-learning-text">
            {learningLayer !== null ? `Mapping: LAYER ${learningLayer} SELECTION` : `Mapping: ${midiLearning?.param?.toUpperCase()} for Layer ${midiLearning?.layer}`}
          </span>
          <button type="button" className="midi-cancel-btn" onClick={ learningLayer !== null ? handleCancelLayerMIDILearn : handleCancelMIDILearn } >
            Cancel
          </button>
        </div>
      )}

      <div className="vertical-layout control-panel-content">
        {midiConnected && (
          <div className="layer-mappings">
            <div className="layer-mapping-grid">
              {[3, 2, 1].map((layerNum) => (
                <div key={`layer_mapping_${layerNum}`} className={`layer-mapping-item ${activeLayer === layerNum ? "active" : ""}`} >
                  <div className="layer-mapping-label">Layer {layerNum}</div>
                  <div className="layer-mapping-controls">
                    <span className="layer-mapping-text" title={displayLayerMidiMapping(String(layerNum))} >
                      {displayLayerMidiMapping(String(layerNum))}
                    </span>
                    {isProfileOwner && (
                      <button
                        type="button"
                        className={`midi-learn-btn small-action-button ${learningLayer === layerNum ? "learning" : ""}`}
                        onClick={() => handleEnterLayerMIDILearnMode(layerNum)}
                        disabled={disableHostLayerControls || !midiConnected || learningLayer !== null || (learningLayer !== null && learningLayer !== layerNum)}
                        title={getLayerMIDILearnButtonTitle(layerNum)}
                        aria-label={`Map MIDI to select Layer ${layerNum}`}
                      >
                        {learningLayer === layerNum ? "..." : "Map"}
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {sliderParams.map(
          (paramConfig) => {
            const { prop, label, min, max, step, formatDecimals, defaultValue = 0 } = paramConfig;
            const isLearningThis = midiLearning?.param === prop && midiLearning?.layer === activeLayer;
            const currentValue = config[prop] !== undefined ? config[prop] : defaultValue;
            return (
              <div key={prop} className="slider-container">
                <div className="slider-header">
                  <span className="slider-label">
                    {label}
                  </span>
                  <div className="slider-controls">
                    <span className="slider-value"> {formatValue(currentValue, formatDecimals)} </span>
                    {midiConnected && isProfileOwner && (
                      <button
                        type="button"
                        className={`midi-btn small-action-button ${isLearningThis ? "learning" : ""}`}
                        onClick={() => handleEnterMIDILearnMode(prop)}
                        disabled={disableHostLayerControls || !midiConnected || !!learningLayer || (midiLearning !== null && !(midiLearning?.param === prop && midiLearning?.layer === activeLayer))}
                        title={getMIDILearnButtonTitle(prop, label)}
                        aria-label={`Map MIDI to ${label}`}
                      >
                        {isLearningThis ? "..." : "M"}
                      </button>
                    )}
                  </div>
                </div>
                <input type="range" name={prop} min={min} max={max} step={step} value={currentValue} onChange={handleSliderChange} disabled={disableHostLayerControls || isLearningThis} className="horizontal-slider" aria-label={label} />
              </div>
            );
          },
        )}

        <div className="controls-footer">
          <div className="blendmode-container">
            <label htmlFor={`blendModeVertical-${activeLayer}`}>BLEND MODE</label>
            <select id={`blendModeVertical-${activeLayer}`} className="custom-select blend-mode-select" name="blendMode" value={config.blendMode || "normal"} onChange={handleBlendModeChange} disabled={disableHostLayerControls} aria-label="Select Blend Mode">
              {blendModes.map((mode) => ( <option key={mode} value={mode}> {mode.charAt(0).toUpperCase() + mode.slice(1).replace("-", " ")} </option> ))}
            </select>
          </div>
          <button type="button" className="changerotation-btn icon-button" onClick={handleDirectionToggle} title="Change Rotation Direction" disabled={disableHostLayerControls} aria-label="Change Rotation Direction">
            <img src={rotateIcon} className="changerotation-icon" alt="Change Rotation Direction" />
          </button>
          <div className="enabled-control-vertical">
            <label htmlFor={`enabled-v-${activeLayer}`}>Enabled</label>
            <input type="checkbox" id={`enabled-v-${activeLayer}`} name="enabled" checked={config.enabled ?? true} onChange={handleEnabledToggle} disabled={disableHostLayerControls} />
          </div>
        </div>

        {typeof onSetSequencerInterval === 'function' && (
            <div className="sequencer-interval-control config-section"> {/* Added config-section for consistent styling */}
                <h4 className="section-title">Sequencer Settings</h4> {/* Changed from h3 to h4 for hierarchy */}
                <div className="form-group">
                    <label htmlFor="sequencer-interval-input">Interval (seconds)</label>
                    <div className="input-with-button">
                        <input
                            type="number"
                            id="sequencer-interval-input"
                            className="form-control"
                            value={localSequencerInterval}
                            onChange={handleSequencerIntervalInputChange}
                            min="1" // Minimum 1 second
                            step="1"
                            disabled={disableHostLayerControls} // Example disable logic
                        />
                        <button
                            type="button"
                            className="btn btn-sm" // Use existing button style
                            onClick={applySequencerInterval}
                            disabled={disableHostLayerControls}
                        >
                            Set
                        </button>
                    </div>
                </div>
            </div>
        )}


        {midiConnected && (
          <div className="midi-tools">
              <button type="button" className="midi-monitor-btn" onClick={handleToggleMonitor}> {showMidiMonitor ? "Hide Monitor" : "Show Monitor"} </button>
              <button
                  type="button"
                  className="midi-reset-btn"
                  onClick={handleResetAllMappings}
                  title="Reset all MIDI mappings for this controller (saved on host profile)"
                  disabled={disableHostLayerControls || !canSave}
              >
                  Reset Mappings
              </button>
              <select className="midi-channel-select" value={selectedChannel} onChange={handleMidiChannelChange} title="Filter MIDI messages by channel" aria-label="Select MIDI Channel Filter" >
                <option value="0">All Channels</option>
                {[...Array(16)].map((_, i) => ( <option key={i + 1} value={i + 1}> Channel {i + 1} </option> ))}
              </select>
          </div>
        )}
        {!midiConnected && (
            <p className="midi-disconnected-message">MIDI Disconnected. Connect a device to enable MIDI features.</p>
        )}
      </div>

      {midiConnected && showMidiMonitor && (
        <div className="midi-monitor" ref={midiMonitorRef}>
          <div className="midi-monitor-header">
            <h4>MIDI Monitor</h4>
            <button type="button" className="midi-clear-btn small-action-button" onClick={handleClearMidiMonitor}> Clear </button>
          </div>
          <div className="midi-monitor-content">
            {midiMonitorData.length === 0 ? ( <div className="midi-monitor-empty"> No MIDI messages received yet. </div> ) : (
              midiMonitorData.map((msg, index) => (
                <div key={`${msg.timestamp}-${index}`} className="midi-monitor-msg">
                  <span className="midi-monitor-time">{msg.timestamp}</span>
                  <span className="midi-monitor-type">{msg.type}</span>
                  <span className="midi-monitor-channel">Ch{msg.channel}</span>
                  <span className="midi-monitor-data">D1:{msg.data1}</span>
                  <span className="midi-monitor-data">D2:{msg.data2}</span>
                </div>
              ))
            )}
          </div>
        </div>
      )}
      {adminVisitorMessage}
      {generalVisitorMessage}
      {readOnlyUIMessage}
    </Panel>
  );
};

EnhancedControlPanel.propTypes = {
  onLayerConfigChange: PropTypes.func.isRequired,
  blendModes: PropTypes.arrayOf(PropTypes.string).isRequired,
  onToggleMinimize: PropTypes.func.isRequired,
  activeTab: PropTypes.string,
  onTabChange: PropTypes.func,
  onSetSequencerInterval: PropTypes.func,
};
EnhancedControlPanel.defaultProps = {
  activeTab: "tab1",
  onTabChange: () => {},
};

export default React.memo(EnhancedControlPanel);
```

---
### `src\components\Panels\EnhancedSavePanel.jsx`
```jsx
// src/components/Panels/EnhancedSavePanel.jsx
import React, { useState, useEffect, useCallback, useRef } from "react"; // Removed useMemo
import PropTypes from "prop-types";

import Panel from "./Panel"; // Local component
import {
  useProfileSessionState,
  usePresetManagementState,
  useInteractionSettingsState,
  usePendingChangesState,
  useConfigStatusState,
} from "../../hooks/configSelectors"; // Local hooks
import { useMIDI } from "../../context/MIDIContext"; // Local context
import { useVisualConfig } from "../../context/VisualConfigContext.jsx"; // Local context

import "./PanelStyles/EnhancedSavePanel.css"; // Local styles

/**
 * Formats an Ethereum address for display by showing the beginning and end.
 * @param {string | null | undefined} address - The address string.
 * @param {number} [length=6] - The number of characters to show from the start and end.
 * @returns {string} The formatted address or "N/A".
 */
const formatAddress = (address, length = 6) => {
  if (!address || typeof address !== "string" || !address.startsWith("0x")) {
    return "N/A";
  }
  if (address.length <= length * 2 + 2) return address; // Return full address if it's short
  return `${address.substring(0, length + 2)}...${address.substring(address.length - length)}`;
};

const MAX_BUTTON_LABEL_LENGTH_PREVIEW = 3;
/**
 * Generates a short display label for a preset button, typically from a numeric or short part of the full name.
 * This mirrors logic from PresetSelectorBar for consistency in how preset names are abbreviated.
 * @param {string | null | undefined} fullName - The full name of the preset.
 * @returns {string} A short display label (e.g., "1", "ABC") or "?" if input is invalid.
 */
const getPresetDisplayLabelForPreview = (fullName) => {
  if (!fullName || typeof fullName !== 'string') return '?';
  const nameParts = fullName.split('.'); // Assuming names like "RADAR.001" or "MyPreset.ABC"
  if (nameParts.length > 1) {
    const identifier = nameParts.slice(1).join('.');
    if (/^\d+$/.test(identifier)) { // If the part after the first dot is purely numeric
      const num = parseInt(identifier, 10);
      return num.toString(); // Use the number directly
    } else {
      // Use the first few chars of the identifier part
      return identifier.substring(0, MAX_BUTTON_LABEL_LENGTH_PREVIEW).toUpperCase();
    }
  } else {
    // If no dot, use the first few chars of the full name
    return fullName.substring(0, MAX_BUTTON_LABEL_LENGTH_PREVIEW).toUpperCase();
  }
};

/**
 * @typedef {object} EnhancedSavePanelProps
 * @property {() => void} onClose - Callback function to close the panel.
 */

/**
 * EnhancedSavePanel: A UI component for saving and managing visual presets and global settings.
 * It allows users to save the current visual configuration as a named preset, update global
 * event reactions and MIDI mappings, load existing presets, and delete presets.
 * The panel's functionality and available actions are contingent on user permissions
 * (e.g., profile ownership, admin status) and application mode (e.g., preview mode).
 *
 * @param {EnhancedSavePanelProps} props - The component's props.
 * @returns {JSX.Element} The rendered EnhancedSavePanel component.
 */
const EnhancedSavePanel = ({ onClose }) => {
  const {
    currentProfileAddress,
    visitorUPAddress, // Used to determine if viewing own profile or another's
    isPreviewMode,
    isProfileOwner,
    canSave, // Derived: isProfileOwner && !isPreviewMode
  } = useProfileSessionState();

  const {
    currentConfigName, // Name of the currently loaded preset
    savedConfigList,   // List of {name: string} objects
    isLoading: presetHookIsLoading, // Loading state from preset management
    saveVisualPreset: actualSavePreset, // Function to save a visual preset
    loadNamedConfig,
    loadDefaultConfig,
    loadSavedConfigList,
    deleteNamedConfig,
  } = usePresetManagementState();

  const { saveGlobalReactions, saveGlobalMidiMap } = useInteractionSettingsState();
  const { hasPendingChanges } = usePendingChangesState();
  const { configServiceInstanceReady } = useConfigStatusState();
  const { isConnected: isMidiConnected } = useMIDI(); // MIDI device connection status

  // Current visual state to be saved
  const { layerConfigs: currentLayerConfigs, tokenAssignments: currentTokenAssignments } = useVisualConfig();

  // Local component state for UI and processing flags
  const [isProcessing, setIsProcessing] = useState(false); // General async operation flag
  const [isSavingPreset, setIsSavingPreset] = useState(false);
  const [isSavingReactions, setIsSavingReactions] = useState(false);
  const [isSavingMidi, setIsSavingMidi] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [isLoadingListEffect, setIsLoadingListEffect] = useState(false); // Specific for list refresh

  const [statusMessage, setStatusMessage] = useState("");
  /** @type {['info' | 'success' | 'warning' | 'error', React.Dispatch<React.SetStateAction<'info' | 'success' | 'warning' | 'error'>>]} */
  const [statusType, setStatusType] = useState("info");
  /** @type {['idle' | 'saving' | 'success' | 'error', React.Dispatch<React.SetStateAction<'idle' | 'saving' | 'success' | 'error'>>]} */
  const [saveStatus, setSaveStatus] = useState("idle"); // For the main status indicator

  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const statusTimerRef = useRef(null);
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const saveStatusTimerRef = useRef(null);
  /** @type {React.RefObject<boolean>} */
  const isMountedRef = useRef(false);

  // Form state for saving a new preset
  const [newConfigName, setNewConfigName] = useState("");
  const [setAsDefault, setSetAsDefault] = useState(false);
  const [updateGlobalReactionsOnPresetSave, setUpdateGlobalReactionsOnPresetSave] = useState(false);
  const [updateGlobalMidiOnPresetSave, setUpdateGlobalMidiOnPresetSave] = useState(false);

  const canEdit = canSave; // User can edit/save if they have save permissions

  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      if (statusTimerRef.current) clearTimeout(statusTimerRef.current);
      if (saveStatusTimerRef.current) clearTimeout(saveStatusTimerRef.current);
    };
  }, []);

  // Effect to pre-fill the new config name input based on current state
  useEffect(() => {
    const listLength = savedConfigList?.length ?? 0;
    const isValidCurrentName = currentConfigName && currentConfigName !== "Default" && currentConfigName !== "None Loaded" && currentConfigName !== "Fallback" && currentConfigName !== "ErrorState";
    const baseName = isValidCurrentName
      ? currentConfigName // Suggest current name if it's a loaded user preset
      : `RADAR.${String(listLength + 1).padStart(3, '0')}`; // Suggest new name otherwise
    setNewConfigName(baseName);
    // Reset checkboxes when currentConfigName or list changes significantly
    setSetAsDefault(false);
    setUpdateGlobalReactionsOnPresetSave(false);
    setUpdateGlobalMidiOnPresetSave(false);
  }, [currentConfigName, savedConfigList]);

  const displayStatus = useCallback((message, type = "success", duration = 4000) => {
    if (!isMountedRef.current) return;
    setStatusMessage(message);
    setStatusType(type);
    if (statusTimerRef.current) clearTimeout(statusTimerRef.current);
    if (duration > 0) {
      statusTimerRef.current = setTimeout(() => {
        if (isMountedRef.current) setStatusMessage((prev) => (prev === message ? "" : prev)); // Clear only if it's the same message
        statusTimerRef.current = null;
      }, duration);
    }
  }, []); // isMountedRef is a ref, not a dependency

  // Effect to load the list of saved configurations when the panel mounts or profile changes
  useEffect(() => {
    const logPrefix = `[EnhancedSavePanel ListLoadEffect Addr:${currentProfileAddress?.slice(0, 6) ?? 'N/A'}]`;
    if (currentProfileAddress && configServiceInstanceReady && !isPreviewMode && typeof loadSavedConfigList === "function") {
      setIsLoadingListEffect(true);
      loadSavedConfigList()
        .catch((err) => {
            if (isMountedRef.current) {
                if (import.meta.env.DEV) console.error(`${logPrefix} Error loading configurations list:`, err);
                displayStatus("Failed to load configurations list", "error");
            }
        })
        .finally(() => { if (isMountedRef.current) setIsLoadingListEffect(false); });
    } else {
      if (isMountedRef.current) setIsLoadingListEffect(false); // Ensure loading state is reset if conditions not met
    }
  }, [currentProfileAddress, configServiceInstanceReady, isPreviewMode, loadSavedConfigList, displayStatus]);

  const displaySaveStatus = useCallback((status, message = null, duration = 3000) => {
    if (!isMountedRef.current) return;
    setSaveStatus(status);
    if (message) displayStatus(message, status === 'success' ? 'success' : 'error', duration);

    if (saveStatusTimerRef.current) clearTimeout(saveStatusTimerRef.current);
    if (status === 'success' || status === 'error') { // Auto-clear success/error save status
      saveStatusTimerRef.current = setTimeout(() => {
        if (isMountedRef.current) setSaveStatus('idle');
        saveStatusTimerRef.current = null;
      }, duration);
    }
  }, [displayStatus]); // displayStatus is memoized

  const handleSavePreset = useCallback(async () => {
    const nameToSave = newConfigName.trim();
    const logPrefix = `[EnhancedSavePanel handleSavePreset Name:${nameToSave}]`;
    if (!canEdit) { displayStatus("Cannot save: Permissions missing.", "error"); return; }
    if (typeof actualSavePreset !== "function") { displayStatus("Save Preset function not available.", "error"); return; }
    if (!nameToSave) { displayStatus("Preset name cannot be empty.", "warning"); return; }
    if (nameToSave.length > 100) { displayStatus("Preset name is too long (max 100 characters).", "warning"); return; }

    if (savedConfigList?.some(preset => preset.name === nameToSave)) {
      if (!window.confirm(`A preset named "${nameToSave}" already exists. Do you want to overwrite it?`)) {
         return; // User cancelled overwrite
      }
    }

    setIsProcessing(true); setIsSavingPreset(true); displaySaveStatus('saving');

    try {
      const result = await actualSavePreset(
        nameToSave,
        setAsDefault,
        updateGlobalReactionsOnPresetSave,
        updateGlobalMidiOnPresetSave,
        currentLayerConfigs, // From useVisualConfig
        currentTokenAssignments // From useVisualConfig
      );
      if (result?.success) {
        let successMsg = `Preset "${nameToSave}" saved successfully.`;
        if (updateGlobalReactionsOnPresetSave || updateGlobalMidiOnPresetSave) successMsg += " Global settings also updated.";
        if (setAsDefault) successMsg += " Set as default.";
        displaySaveStatus('success', successMsg);
        // Reset checkboxes after successful save
        setUpdateGlobalReactionsOnPresetSave(false);
        setUpdateGlobalMidiOnPresetSave(false);
      } else {
        const errorDetail = result?.error || "Unknown error during save.";
        displaySaveStatus('error', `Save Preset failed: ${errorDetail}`);
        if (import.meta.env.DEV) console.error(`${logPrefix} Save failed:`, errorDetail);
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred during save.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during save preset call:`, e);
      displaySaveStatus('error', `Save Preset error: ${errorDetail}`);
    } finally {
      if (isMountedRef.current) { setIsProcessing(false); setIsSavingPreset(false); }
    }
  }, [
      canEdit, actualSavePreset, newConfigName, savedConfigList, displayStatus, displaySaveStatus,
      setAsDefault, updateGlobalReactionsOnPresetSave, updateGlobalMidiOnPresetSave,
      currentLayerConfigs, currentTokenAssignments
  ]);

  const handleSaveGlobalReactions = useCallback(async () => {
    const logPrefix = `[EnhancedSavePanel handleSaveGlobalReactions]`;
    if (!canEdit) { displayStatus("Cannot save: Permissions missing.", "error"); return; }
    if (typeof saveGlobalReactions !== "function") { displayStatus("Save Reactions function not available.", "error"); return; }
    if (!window.confirm("Are you sure you want to save the current Reaction settings globally? This will overwrite any previous global Reaction settings.")) {
       return;
    }
    setIsProcessing(true); setIsSavingReactions(true); displaySaveStatus('saving');
    try {
      const result = await saveGlobalReactions();
      if (result?.success) {
        displaySaveStatus('success', `Global Reactions saved successfully!`);
      } else {
        const errorDetail = result?.error || "Unknown error during save.";
        displaySaveStatus('error', `Save Reactions failed: ${errorDetail}`);
        if (import.meta.env.DEV) console.error(`${logPrefix} Save failed:`, errorDetail);
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during save reactions call:`, e);
      displaySaveStatus('error', `Save Reactions error: ${errorDetail}`);
    } finally {
      if (isMountedRef.current) { setIsProcessing(false); setIsSavingReactions(false); }
    }
  }, [canEdit, saveGlobalReactions, displayStatus, displaySaveStatus]);

  const handleSaveGlobalMidiMap = useCallback(async () => {
    const logPrefix = `[EnhancedSavePanel handleSaveGlobalMidiMap]`;
    if (!canEdit) { displayStatus("Cannot save: Permissions missing.", "error"); return; }
    if (!isMidiConnected) { displayStatus("Cannot save MIDI Map: No MIDI device connected.", "warning"); return; }
    if (typeof saveGlobalMidiMap !== "function") { displayStatus("Save MIDI Map function not available.", "error"); return; }
    if (!window.confirm("Are you sure you want to save the current MIDI Map settings globally? This will overwrite any previous global MIDI Map settings.")) {
       return;
    }
    setIsProcessing(true); setIsSavingMidi(true); displaySaveStatus('saving');
    try {
      const result = await saveGlobalMidiMap();
      if (result?.success) {
        displaySaveStatus('success', `Global MIDI Map saved successfully!`);
      } else {
        const errorDetail = result?.error || "Unknown error during save.";
        displaySaveStatus('error', `Save MIDI Map failed: ${errorDetail}`);
        if (import.meta.env.DEV) console.error(`${logPrefix} Save failed:`, errorDetail);
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during save MIDI call:`, e);
      displaySaveStatus('error', `Save MIDI Map error: ${errorDetail}`);
    } finally {
      if (isMountedRef.current) { setIsProcessing(false); setIsSavingMidi(false); }
    }
  }, [canEdit, saveGlobalMidiMap, displayStatus, displaySaveStatus, isMidiConnected]);

  const handleLoadByName = useCallback(async (name) => {
    const logPrefix = `[EnhancedSavePanel handleLoadByName Name:${name}]`;
    if (!currentProfileAddress) { displayStatus("Cannot load: No profile active.", "warning"); return; }
    if (!name) { displayStatus("Cannot load: Invalid preset name.", "warning"); return; }
    if (typeof loadNamedConfig !== "function") { displayStatus("Load function not available.", "error"); return; }
    if (hasPendingChanges && canEdit && !window.confirm("You have unsaved changes that will be lost. Are you sure you want to load this preset?")) {
       return;
    }
    setIsProcessing(true); displayStatus(`Loading preset "${name}"...`, "info", 0);
    try {
      const result = await loadNamedConfig(name);
      if (result?.success) {
        displayStatus(`Preset "${name}" loaded successfully.`, "success");
        if (onClose) onClose();
      } else {
        const errorDetail = result?.error || "Configuration not found or is invalid.";
        displayStatus(`Load failed: ${errorDetail}`, "error");
        if (import.meta.env.DEV) console.error(`${logPrefix} Load failed:`, errorDetail);
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred during load.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during load call:`, e);
      displayStatus(`Load error: ${errorDetail}`, "error");
    } finally {
      if (isMountedRef.current) setIsProcessing(false);
    }
  }, [currentProfileAddress, loadNamedConfig, hasPendingChanges, displayStatus, onClose, canEdit]);

  const handleLoadDefault = useCallback(async () => {
    const logPrefix = `[EnhancedSavePanel handleLoadDefault]`;
    if (!currentProfileAddress) { displayStatus("Cannot load default: No profile active.", "warning"); return; }
    if (typeof loadDefaultConfig !== "function") { displayStatus("Load Default function not available.", "error"); return; }
    if (hasPendingChanges && canEdit && !window.confirm("You have unsaved changes that will be lost. Are you sure you want to load the default preset?")) {
       return;
    }
    setIsProcessing(true); displayStatus(`Loading default configuration...`, "info", 0);
    try {
      const result = await loadDefaultConfig();
      if (result?.success) {
        const loadedName = result.config?.name;
        displayStatus(loadedName ? `Default preset "${loadedName}" loaded.` : "Default configuration loaded.", "success");
        if (onClose) onClose();
      } else {
        const errorDetail = result?.error || "Could not load default configuration.";
        if (errorDetail.includes("No default")) {
          displayStatus(`Load default failed: No default preset is set for this profile.`, "warning");
          if (import.meta.env.DEV) console.warn(`${logPrefix} Load failed: No default preset set.`);
        } else {
          displayStatus(`Load default failed: ${errorDetail}`, "error");
          if (import.meta.env.DEV) console.error(`${logPrefix} Load failed:`, errorDetail);
        }
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during load default call:`, e);
      displayStatus(`Load default error: ${errorDetail}`, "error");
    } finally {
      if (isMountedRef.current) setIsProcessing(false);
    }
  }, [currentProfileAddress, loadDefaultConfig, hasPendingChanges, displayStatus, onClose, canEdit]);

  const handleDelete = useCallback(async (name) => {
    const logPrefix = `[EnhancedSavePanel handleDelete Name:${name}]`;
    if (!canEdit) { displayStatus("Cannot delete: Permissions missing.", "error"); return; }
    if (!name) { displayStatus("Cannot delete: Invalid preset name.", "warning"); return; }
    if (typeof deleteNamedConfig !== "function") { displayStatus("Delete function not available.", "error"); return; }
    if (!window.confirm(`Are you sure you want to DELETE the preset "${name}" permanently? This action cannot be undone.`)) {
       return;
    }
    setIsProcessing(true); setIsDeleting(true); displayStatus(`Deleting preset "${name}"...`, "info", 0);
    try {
      const result = await deleteNamedConfig(name);
      if (result?.success) {
        displayStatus(`Preset "${name}" deleted successfully.`, "success");
        if (currentConfigName === name && typeof loadDefaultConfig === 'function') {
            await loadDefaultConfig();
        }
      } else {
        const errorDetail = result?.error || "Unknown error during delete.";
        displayStatus(`Delete failed: ${errorDetail}`, "error");
        if (import.meta.env.DEV) console.error(`${logPrefix} Delete failed:`, errorDetail);
      }
    } catch (e) {
      const errorDetail = e?.message || "A client-side error occurred.";
      if (import.meta.env.DEV) console.error(`${logPrefix} Unexpected error during delete call:`, e);
      displayStatus(`Delete error: ${errorDetail}`, "error");
    } finally {
      if (isMountedRef.current) { setIsProcessing(false); setIsDeleting(false); }
    }
  }, [canEdit, deleteNamedConfig, displayStatus, currentConfigName, loadDefaultConfig]);

  const getPanelTitle = () => {
    if (isPreviewMode) return "VISITOR PREVIEW";
    if (!currentProfileAddress) return "CONNECT PROFILE";
    if (canEdit) return "MY PROFILE - SAVE & MANAGE";
    return `VIEWING PROFILE (${formatAddress(currentProfileAddress)})`;
  };

  const isDisabledBaseReadOrWrite = isProcessing || presetHookIsLoading || !configServiceInstanceReady;
  const isDisabledWriteOperations = isDisabledBaseReadOrWrite || !canEdit;
  const isSavePresetDisabled = isDisabledWriteOperations || !newConfigName.trim() || isSavingPreset;
  const isSaveReactionsDisabled = isDisabledWriteOperations || isSavingReactions;
  const isSaveMidiDisabled = isDisabledWriteOperations || !isMidiConnected || isSavingMidi;
  const isGenericLoadDisabled = isDisabledBaseReadOrWrite || isDeleting;
  const isRefreshListDisabled = isDisabledBaseReadOrWrite || isLoadingListEffect || isDeleting;
  const isDeleteButtonDisabled = isDisabledWriteOperations || isDeleting;

  const renderStatusIndicator = () => {
    if (saveStatus === 'success' && canEdit) return <div className="status-indicator success">Configuration Saved</div>;
    if (saveStatus === 'error' && canEdit) return <div className="status-indicator error">Save Failed</div>;
    if (saveStatus === 'saving' && canEdit) return <div className="status-indicator saving">Saving...</div>;
    if (hasPendingChanges && canEdit) return <div className="status-indicator pending">Unsaved changes active</div>;
    if (!canEdit && currentProfileAddress && !isPreviewMode) return <div className="status-indicator idle">Viewing mode. Changes are not saved.</div>;
    return <div className="status-indicator idle">No unsaved changes detected</div>;
  };

  const renderInformationalBanner = () => {
    if (isPreviewMode) {
      return (
        <div className="save-info preview-banner">
          <span aria-hidden="true">👁️</span>
          <div>
            <div className="title">Preview Mode</div>
            <div className="desc">Saving configurations is disabled in this mode. Exit preview to manage your profile's settings.</div>
          </div>
        </div>
      );
    }
    if (!currentProfileAddress) {
      return (
        <div className="save-info connection-warning">
          <p><strong>No Profile Active</strong></p>
          <p>Connect your Universal Profile to save or load your configurations.</p>
        </div>
      );
    }
    if (!isProfileOwner && visitorUPAddress) {
      return (
        <div className="save-info visitor-banner">
          <span aria-hidden="true">👤</span>
          <div>
            <div className="title">Viewing Mode</div>
            <div className="desc">
              You are viewing another profile. You can load their presets and experiment with controls.
              Saving changes to this profile is disabled.
            </div>
          </div>
        </div>
      );
    }
    if (!isProfileOwner && !visitorUPAddress) {
        return (
          <div className="save-info visitor-banner">
            <span aria-hidden="true">👤</span>
            <div>
              <div className="title">Viewing Another Profile</div>
              <div className="desc">
                You can load this profile's presets and experiment. Connect your own Universal Profile to save your creations.
              </div>
            </div>
          </div>
        );
    }
    return null;
  };

  return (
    <Panel
      title={getPanelTitle()}
      onClose={onClose}
      className="panel-from-toolbar enhanced-save-panel"
    >
      {statusMessage && (
        <div className={`status-message ${statusType}`}>{statusMessage}</div>
      )}

      {renderStatusIndicator()}

      {canEdit && currentProfileAddress && (
        <div className="config-section save-preset-section">
          <h3>Save Visual Preset As</h3>
          <div className="form-group">
            <label htmlFor="preset-name" className="sr-only">Preset Name</label>
            <input id="preset-name" type="text" value={newConfigName} onChange={(e) => setNewConfigName(e.target.value)} className="form-control" placeholder="Visual Preset Name" disabled={isDisabledWriteOperations || isSavingPreset} maxLength={100} aria-describedby="save-preset-help-text preset-name-display-tip" required />
            {newConfigName.trim() && (
                <p id="preset-name-display-tip" className="form-help-text preset-name-display-tip">
                    Button will show: <strong>{getPresetDisplayLabelForPreview(newConfigName.trim())}</strong>
                    <br/>
                    (Full name "{newConfigName.trim()}" shown on hover)
                </p>
            )}
          </div>
          <div className="checkbox-options-group">
            <div className="checkbox-group"><input id="update-global-reactions" type="checkbox" checked={updateGlobalReactionsOnPresetSave} onChange={(e) => setUpdateGlobalReactionsOnPresetSave(e.target.checked)} disabled={isDisabledWriteOperations || isSavingPreset} /><label htmlFor="update-global-reactions">Also update global Reactions?</label></div>
            <div className="checkbox-group"><input id="update-global-midi" type="checkbox" checked={updateGlobalMidiOnPresetSave} onChange={(e) => setUpdateGlobalMidiOnPresetSave(e.target.checked)} disabled={isDisabledWriteOperations || !isMidiConnected || isSavingPreset} /><label htmlFor="update-global-midi" className={(isDisabledWriteOperations || !isMidiConnected || isSavingPreset) ? 'disabled-label' : ''}>Also update global MIDI Map? { !isMidiConnected && "(MIDI Disconnected)"}</label></div>
            <div className="checkbox-group"><input id="set-default-preset" type="checkbox" checked={setAsDefault} onChange={(e) => setSetAsDefault(e.target.checked)} disabled={isDisabledWriteOperations || isSavingPreset} /><label htmlFor="set-default-preset">Set as Default preset for this profile</label></div>
          </div>
          <p id="save-preset-help-text" className="form-help-text">Saves current visual layers & tokens. Optionally updates global Reactions/MIDI map too.</p>
          {typeof actualSavePreset === "function" ? (<button className="btn btn-block btn-save btn-save-preset" onClick={handleSavePreset} disabled={isSavePresetDisabled} aria-live="polite">{isSavingPreset ? "SAVING PRESET..." : `SAVE PRESET "${newConfigName.trim() || "..."}"`}</button>) : ( <p className="error-message">Save Preset action is unavailable.</p> )}
        </div>
      )}

      {canEdit && currentProfileAddress && (
        <div className="config-section save-global-section">
          <h3>Update Global Settings Only</h3>
          <p className="form-help-text">Saves only the current Reactions or MIDI map globally. Does not create a named visual preset.</p>
          <div className="global-save-buttons">
            {typeof saveGlobalReactions === "function" ? (<button className="btn btn-secondary btn-save-global" onClick={handleSaveGlobalReactions} disabled={isSaveReactionsDisabled} aria-live="polite">{isSavingReactions ? "SAVING..." : "Save Global Reactions"}</button>) : ( <p className="error-message">Save Reactions action is unavailable.</p> )}
            {typeof saveGlobalMidiMap === "function" ? (<button className="btn btn-secondary btn-save-global" onClick={handleSaveGlobalMidiMap} disabled={isSaveMidiDisabled} aria-live="polite" title={!isMidiConnected ? "Connect MIDI device to save map" : "Save current MIDI map globally"}>{isSavingMidi ? "SAVING..." : "Save Global MIDI Map"}</button>) : ( <p className="error-message">Save MIDI Map action is unavailable.</p> )}
          </div>
        </div>
      )}

      {currentProfileAddress && !isPreviewMode && (
        <div className="config-section load-section">
          <h3>Load / Delete Presets</h3>
          <div className="load-actions-group">
            {typeof loadDefaultConfig === "function" && (<button className="btn btn-secondary" onClick={handleLoadDefault} disabled={isGenericLoadDisabled} title={isGenericLoadDisabled ? "Processing..." : "Load default preset"}>{(presetHookIsLoading && !currentConfigName) ? "LOADING..." : "Load Default"}</button>)}
            {typeof loadSavedConfigList === "function" && (<button className="btn btn-secondary btn-outline" onClick={() => { if (!isRefreshListDisabled) loadSavedConfigList(); }} disabled={isRefreshListDisabled} title={isRefreshListDisabled ? "Processing..." : "Refresh preset list"} aria-live="polite">{isLoadingListEffect || (presetHookIsLoading && savedConfigList.length === 0) ? "REFRESHING..." : "Refresh List"}</button>)}
          </div>
          {isLoadingListEffect || (presetHookIsLoading && savedConfigList.length === 0 && currentProfileAddress) ? (
            <p className="loading-list-message">Loading presets...</p>
          ) : savedConfigList?.length > 0 ? (
            <ul className="config-list">
              {Array.isArray(savedConfigList) && savedConfigList.map((preset) => (
                <li key={preset.name} className={preset.name === currentConfigName ? "active" : ""}>
                  {typeof loadNamedConfig === "function" ? (<button className="btn-link config-name" onClick={() => { if (!isGenericLoadDisabled) handleLoadByName(preset.name); }} disabled={isGenericLoadDisabled} title={isGenericLoadDisabled ? "Processing..." : `Load "${preset.name}"`}>{preset.name}</button>) : ( <span className="config-name-noload">{preset.name}</span> )}
                  {canEdit && typeof deleteNamedConfig === "function" && (<button className="btn-icon delete-config" onClick={() => { if (!isDeleteButtonDisabled) handleDelete(preset.name); }} disabled={isDeleteButtonDisabled} title={isDeleteButtonDisabled ? "Processing..." : `Delete "${preset.name}"`} aria-label={`Delete preset ${preset.name}`}>×</button>)}
                </li>
              ))}
            </ul>
          ) : ( currentProfileAddress && <p className="no-configs-message">No saved visual presets found for this profile.</p> )}
        </div>
      )}

      {renderInformationalBanner()}
    </Panel>
  );
};

EnhancedSavePanel.propTypes = {
  /** Callback function to close the panel. */
  onClose: PropTypes.func.isRequired,
};

export default React.memo(EnhancedSavePanel);
```

---
### `src\components\Panels\EventsPanel.jsx`
```jsx
// src/components/Panels/EventsPanel.jsx
import React, { useState, useCallback, useEffect, useMemo } from "react";
import PropTypes from "prop-types";

import Panel from "./Panel"; // Local component
import { EVENT_TYPE_MAP } from "../../config/global-config"; // Local config
import { useToast } from "../../context/ToastContext"; // Local context

import "./PanelStyles/Eventspanel.css"; // Local styles

/**
 * Generates a sorted list of event type options for a dropdown selector.
 * It uses EVENT_TYPE_MAP as the sole source.
 * The option's 'value' will be the typeId (hex string), and 'label' will be human-readable.
 * @returns {Array<{value: string, label: string}>} A sorted array of event type options.
 */
const generateEventOptions = () => {
    const optionsMap = new Map();
    // Add options from EVENT_TYPE_MAP (which maps readable names to typeIds)
    Object.keys(EVENT_TYPE_MAP).forEach((readableKey) => {
        const typeId = EVENT_TYPE_MAP[readableKey]; // typeId is the value for the option
        // Use typeId as the unique key for the map to prevent duplicates if any typeId were mapped multiple times (though unlikely)
        if (!optionsMap.has(typeId)) {
            optionsMap.set(typeId, {
                value: typeId, // The actual typeId from the map
                label: readableKey.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
            });
        }
    });

    return Array.from(optionsMap.values()).sort((a, b) => a.label.localeCompare(b.label));
};

/**
 * @typedef {object} ReactionConfig
 * @property {string} event - The event type identifier (this will be the typeId/hex string).
 * @property {string} layer - The target layer for the effect (e.g., 'global', '1').
 * @property {string} effect - The type of visual effect (e.g., 'color_overlay').
 * @property {object} [config] - Configuration specific to the `effect` type.
 */

/**
 * @typedef {Object.<string, ReactionConfig>} ReactionsMap
 * A map where keys are event type identifiers (typeIds/hex strings) and values are `ReactionConfig` objects.
 */

/**
 * @typedef {object} EventsPanelProps
 * @property {(reactionId: string, reactionConfig: ReactionConfig) => void} [onSaveReaction] - Callback to stage a reaction locally. `reactionId` is the event typeId.
 * @property {(reactionId: string) => void} [onRemoveReaction] - Callback to remove/unstage a reaction locally (uses event typeId).
 * @property {ReactionsMap} [reactions={}] - The currently saved global reactions for the host profile. Keys are event typeIds.
 * @property {() => void} onClose - Callback to close the panel.
 * @property {boolean} [readOnly=false] - If true, UI controls for modifying reactions are disabled.
 * @property {(effectConfig: object) => Promise<string | null>} [onPreviewEffect] - Callback to trigger a preview of the configured visual effect.
 */

/**
 * EventsPanel: A UI component for configuring visual reactions to blockchain events.
 * Users can select an event type, choose a visual effect (currently 'color_overlay'),
 * configure the effect's parameters (color, pulse, duration), preview the effect,
 * and stage the reaction. Staged reactions are then saved globally via the main Save Panel.
 * The panel also displays currently saved global reactions for the profile.
 *
 * @param {EventsPanelProps} props - The component's props.
 * @returns {JSX.Element} The rendered EventsPanel component.
 */
const EventsPanel = ({
  onSaveReaction,
  onRemoveReaction,
  reactions = {},
  onClose,
  readOnly = false,
  onPreviewEffect,
}) => {
  const { addToast } = useToast();
  const allEventOptions = useMemo(() => generateEventOptions(), []);

  const [selectedEvent, setSelectedEvent] = useState(allEventOptions[0]?.value || ""); // Value will be typeId
  const [selectedEffect, setSelectedEffect] = useState("color_overlay");
  const [effectConfig, setEffectConfig] = useState({
    color: "rgba(255, 165, 0, 0.4)", pulseCount: 2, duration: 2500,
    r: 255, g: 165, b: 0, a: 0.4,
  });
  const [previewStatus, setPreviewStatus] = useState("");

  useEffect(() => {
    const existingReaction = reactions[selectedEvent]; // selectedEvent is now typeId
    if (existingReaction) {
      setSelectedEffect(existingReaction.effect || "color_overlay");
      if (existingReaction.effect === "color_overlay" && existingReaction.config) {
        const colorString = existingReaction.config.color || "rgba(255, 165, 0, 0.4)";
        const rgbaMatch = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
        const [r, g, b, a] = rgbaMatch
          ? [ parseInt(rgbaMatch[1],10), parseInt(rgbaMatch[2],10), parseInt(rgbaMatch[3],10), parseFloat(rgbaMatch[4] ?? 1) ]
          : [255, 165, 0, 0.4];
        setEffectConfig({
          color: colorString,
          pulseCount: existingReaction.config.pulseCount || 2,
          duration: existingReaction.config.duration || 2500,
          r, g, b, a,
        });
      } else {
        setEffectConfig({ color: "rgba(255, 165, 0, 0.4)", pulseCount: 2, duration: 2500, r: 255, g: 165, b: 0, a: 0.4 });
      }
    } else {
      setSelectedEffect("color_overlay");
      setEffectConfig({ color: "rgba(255, 165, 0, 0.4)", pulseCount: 2, duration: 2500, r: 255, g: 165, b: 0, a: 0.4 });
    }
  }, [selectedEvent, reactions]);

  const handleEventChange = useCallback((e) => setSelectedEvent(e.target.value), []);

  const handleEffectChange = useCallback((e) => {
    const newEffectType = e.target.value;
    setSelectedEffect(newEffectType);
    if (newEffectType === "color_overlay") {
      setEffectConfig({ color: "rgba(255, 165, 0, 0.4)", pulseCount: 2, duration: 2500, r: 255, g: 165, b: 0, a: 0.4 });
    } else {
      setEffectConfig({});
    }
  }, []);

  const handleColorChange = useCallback((component, value) => {
    setEffectConfig((prevConfig) => {
      const updatedConfig = { ...prevConfig, [component]: Number(value) };
      const { r = 0, g = 0, b = 0, a = 1 } = updatedConfig;
      updatedConfig.color = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${Number(a).toFixed(2)})`;
      return updatedConfig;
    });
  }, []);

  const handleConfigChange = useCallback((field, value) => {
    const numericValue = ["pulseCount", "duration"].includes(field) ? parseInt(value, 10) : value;
    setEffectConfig((prev) => ({ ...prev, [field]: numericValue }));
  }, []);

  const handleStageLocally = useCallback(() => {
    if (readOnly) { addToast("Read-only mode: Cannot stage changes.", "warning"); return; }
    if (typeof onSaveReaction !== "function") { addToast("Error: Staging function unavailable.", "error"); return; }
    if (!selectedEvent) { addToast("Please select an event type.", "warning"); return; } // selectedEvent is typeId

    const reactionId = selectedEvent; // reactionId is the typeId
    const reactionConfigToStage = {
      event: selectedEvent, // Store the event typeId
      layer: "global",
      effect: selectedEffect,
      config: selectedEffect === "color_overlay" ? {
          color: effectConfig.color,
          pulseCount: Number(effectConfig.pulseCount),
          duration: Number(effectConfig.duration),
        } : {},
    };

    try {
      onSaveReaction(reactionId, reactionConfigToStage); // Pass typeId as reactionId
      const eventLabel = allEventOptions.find(opt => opt.value === selectedEvent)?.label || selectedEvent;
      addToast(`Reaction for '${eventLabel}' staged. Save globally via Save Panel.`, "success");
    } catch (error) {
      if (import.meta.env.DEV) console.error("[EventsPanel] Error during onSaveReaction call:", error);
      addToast(`Error staging reaction: ${error.message || "Unknown error"}`, "error");
    }
  }, [ readOnly, selectedEvent, selectedEffect, effectConfig, onSaveReaction, addToast, allEventOptions ]);

  const handleRemoveStagedReaction = useCallback((typeIdToRemove) => {
    if (readOnly) { addToast("Read-only mode: Cannot unstage changes.", "warning"); return; }
    if (typeof onRemoveReaction !== "function") { addToast("Error: Unstaging function unavailable.", "error"); return; }
    if (!typeIdToRemove) { addToast("No event type specified to unstage.", "warning"); return; }

    const eventLabel = allEventOptions.find(opt => opt.value === typeIdToRemove)?.label || typeIdToRemove;
    if (window.confirm(`Are you sure you want to unstage the reaction for "${eventLabel}"? This will remove it from the current pending changes.`)) {
        try {
            onRemoveReaction(typeIdToRemove);
            addToast(`Reaction for "${eventLabel}" unstaged.`, "info");
            if (selectedEvent === typeIdToRemove) {
                setSelectedEvent(allEventOptions[0]?.value || "");
            }
        } catch (error) {
            if (import.meta.env.DEV) console.error("[EventsPanel] Error during onRemoveReaction call:", error);
            addToast(`Error unstaging reaction: ${error.message || "Unknown error"}`, "error");
        }
    }
  }, [readOnly, onRemoveReaction, addToast, selectedEvent, allEventOptions]);


  const handlePreview = useCallback(() => {
    setPreviewStatus("");
    if (typeof onPreviewEffect !== "function") {
      setPreviewStatus("Preview function unavailable.");
      setTimeout(() => setPreviewStatus(""), 3000);
      return;
    }
    const effectToPreview = {
      layer: "global",
      type: selectedEffect,
      config: selectedEffect === "color_overlay" ? {
          color: effectConfig.color,
          pulseCount: Number(effectConfig.pulseCount),
          duration: Number(effectConfig.duration),
        } : {},
      effectId: `preview_${Date.now()}`,
    };
    onPreviewEffect(effectToPreview)
      .then((effectId) => {
        setPreviewStatus(effectId ? "Preview triggered!" : "Preview failed to apply.");
        setTimeout(() => setPreviewStatus(""), 2000);
      })
      .catch((error) => {
        if (import.meta.env.DEV) console.error("[EventsPanel] Error triggering preview effect:", error);
        setPreviewStatus("Preview error occurred.");
        setTimeout(() => setPreviewStatus(""), 3000);
      });
  }, [onPreviewEffect, selectedEffect, effectConfig]);

  return (
    <Panel
      title="EVENT REACTIONS"
      onClose={onClose}
      className="panel-from-toolbar events-panel-custom-scroll"
    >
      <div className="reaction-form section-box">
        <h3 className="section-title">Configure New Reaction / Edit Existing</h3>
        <p className="form-help-text">
          Select an event to configure its visual reaction. Click "Stage Reaction" to add your changes.
          Finally, use the main Save Panel to persist all staged reactions globally to this profile.
        </p>
        <div className="form-group">
          <label htmlFor="event-select">Event Type</label>
          <select id="event-select" value={selectedEvent} onChange={handleEventChange} className="custom-select" disabled={readOnly} aria-label="Select Event Type">
            {allEventOptions.map((opt) => (
              // --- MODIFIED LINE: Comment removed ---
              <option key={opt.value} value={opt.value}> {opt.label} </option>
              // ------------------------------------
            ))}
          </select>
        </div>
        <div className="form-group">
          <label htmlFor="effect-select">Visual Effect</label>
          <select id="effect-select" value={selectedEffect} onChange={handleEffectChange} className="custom-select" disabled={readOnly} aria-label="Select Visual Effect">
            <option value="color_overlay">Color Overlay Pulse</option>
          </select>
        </div>

        {selectedEffect === "color_overlay" && (
          <div className="color-config-section">
            <h4 className="config-section-title">Effect Settings: Color Overlay</h4>
            <div className="color-preview-container">
              <span className="color-preview-label">Preview:</span>
              <div className="color-preview" style={{ backgroundColor: effectConfig.color }} title={`Current color: ${effectConfig.color}`} ></div>
            </div>
            <div className="slider-group">
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Red</span> <span className="slider-value">{effectConfig.r || 0}</span> </div><input type="range" min="0" max="255" step="1" value={effectConfig.r || 0} onChange={(e) => handleColorChange("r", parseInt(e.target.value,10))} className="color-slider red-slider" disabled={readOnly} aria-label="Red color component"/></div>
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Green</span> <span className="slider-value">{effectConfig.g || 0}</span> </div><input type="range" min="0" max="255" step="1" value={effectConfig.g || 0} onChange={(e) => handleColorChange("g", parseInt(e.target.value,10))} className="color-slider green-slider" disabled={readOnly} aria-label="Green color component"/></div>
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Blue</span> <span className="slider-value">{effectConfig.b || 0}</span> </div><input type="range" min="0" max="255" step="1" value={effectConfig.b || 0} onChange={(e) => handleColorChange("b", parseInt(e.target.value,10))} className="color-slider blue-slider" disabled={readOnly} aria-label="Blue color component"/></div>
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Opacity</span> <span className="slider-value">{(Number(effectConfig.a) || 0).toFixed(2)}</span> </div><input type="range" min="0" max="1" step="0.01" value={effectConfig.a || 0} onChange={(e) => handleColorChange("a", parseFloat(e.target.value))} className="color-slider alpha-slider" disabled={readOnly} aria-label="Color opacity"/></div>
            </div>
            <div className="slider-group">
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Pulse Count</span> <span className="slider-value">{effectConfig.pulseCount || 1}</span> </div><input type="range" min="1" max="10" step="1" value={effectConfig.pulseCount || 1} onChange={(e) => handleConfigChange("pulseCount", e.target.value)} disabled={readOnly} aria-label="Number of pulses"/></div>
              <div className="slider-container"><div className="slider-header"> <span className="slider-label">Total Duration (ms)</span> <span className="slider-value">{effectConfig.duration || 500}</span> </div><input type="range" min="500" max="10000" step="100" value={effectConfig.duration || 500} onChange={(e) => handleConfigChange("duration", e.target.value)} disabled={readOnly} aria-label="Total effect duration in milliseconds"/></div>
            </div>
          </div>
        )}

        <div className="form-actions">
          <button className="btn btn-secondary btn-preview" onClick={handlePreview} disabled={typeof onPreviewEffect !== "function"} title="Trigger a preview of the current effect settings" > PREVIEW EFFECT </button>
          <button className="btn btn-primary btn-save-reaction" onClick={handleStageLocally} disabled={readOnly || typeof onSaveReaction !== "function"} title={ readOnly ? "Cannot stage in read-only mode" : "Stage this reaction (must save globally via Save Panel)" } > STAGE REACTION </button>
        </div>

        {previewStatus && ( <div className="status-message preview-status">{previewStatus}</div> )}
      </div>

      <div className="active-reactions section-box">
        <h3 className="section-title">Current Global Event Reactions (Profile)</h3>
        {Object.keys(reactions).length === 0 ? (
          <div className="no-reactions">No global reactions currently saved for this profile.</div>
        ) : (
          <div className="reactions-list">
            {Object.entries(reactions).map(([typeId, reaction]) => { // Key is typeId
              const eventLabel = allEventOptions.find((opt) => opt.value === typeId)?.label || typeId.slice(0,10)+"...";
              return (
                <div key={typeId} className="reaction-item" id={'reaction-' + typeId} >
                  <div className="reaction-details">
                    <span className="reaction-event" title={typeId}>
                      {eventLabel}
                    </span>
                    <span className="reaction-effect-type"> ({reaction.effect === "color_overlay" ? "Color Pulse" : reaction.effect}) </span>
                    {reaction.effect === "color_overlay" && reaction.config?.color && (
                        <span className="color-pill" style={{ backgroundColor: reaction.config.color }} title={`Color: ${reaction.config.color}`} ></span>
                    )}
                  </div>
                  {!readOnly && typeof onRemoveReaction === 'function' && (
                      <button
                          className="btn-icon delete-reaction"
                          onClick={() => handleRemoveStagedReaction(typeId)} // Use typeId
                          title={`Unstage reaction for ${eventLabel}`}
                          aria-label={`Unstage reaction for ${eventLabel}`}
                      >
                          ×
                      </button>
                  )}
                </div>
              );
            })}
          </div>
        )}
        {readOnly && ( <p className="read-only-hint">Viewing in read-only mode. Staging or unstaging reactions is disabled.</p> )}
        {!readOnly && ( <p className="save-hint"> Use the main Save Panel to persist staged changes globally to your profile. </p> )}
      </div>
    </Panel>
  );
};

EventsPanel.propTypes = {
  onSaveReaction: PropTypes.func,
  onRemoveReaction: PropTypes.func,
  reactions: PropTypes.object,
  onClose: PropTypes.func.isRequired,
  readOnly: PropTypes.bool,
  onPreviewEffect: PropTypes.func,
};

export default React.memo(EventsPanel);
```

---
### `src\components\Panels\InfoOverlay.jsx`
```jsx
// src/components/Panels/InfoOverlay.jsx
import React, { useState, useEffect, useCallback } from "react"; // Removed useMemo as it's not used
import PropTypes from "prop-types";

import "./PanelStyles/InfoOverlay.css"; // Local styles
import radarWordmarkBlue from "../../assets/branding/radarwordmarkblue.svg"; // Local asset

/**
 * @typedef {'initial' | 'fadeToContent' | 'exiting'} TransitionState - Possible transition states for the overlay.
 */

/**
 * @typedef {'philosophy' | 'general' | 'layers' | 'audioReactivity' | 'events' | 'tokens' | 'configurations' | 'collections' | 'artists' | 'ipRights' | 'roadmap'} InfoTabId - Valid identifiers for tabs within the info overlay.
 */

/**
 * @typedef {object} InfoOverlayProps
 * @property {boolean} isOpen - Controls whether the overlay is currently open or closed.
 * @property {() => void} onClose - Callback function invoked when the overlay requests to be closed (e.g., by clicking the close button or background).
 */

/**
 * InfoOverlay: A modal-like component that displays detailed information about the RADAR application.
 * It features tabbed navigation to organize content into sections like Philosophy, About, Controls, etc.
 * The overlay includes fade-in and fade-out transitions for a smoother user experience.
 *
 * @param {InfoOverlayProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered InfoOverlay component, or null if it's not open and not transitioning out.
 */
const InfoOverlay = ({ isOpen, onClose }) => {
  /** @type {[TransitionState, React.Dispatch<React.SetStateAction<TransitionState>>]} */
  const [transitionState, setTransitionState] = useState("initial");
  /** @type {[InfoTabId, React.Dispatch<React.SetStateAction<InfoTabId>>]} */
  const [activeTab, setActiveTab] = useState("philosophy"); // Default active tab

  // Effect to manage transition states based on the `isOpen` prop
  useEffect(() => {
    if (isOpen) {
      // When isOpen becomes true, start the fade-in transition
      setTransitionState("fadeToContent");
    } else {
      // When isOpen becomes false, start the fade-out transition
      setTransitionState("exiting");
      // After the fade-out duration, reset to initial state (fully hidden)
      const timer = setTimeout(() => setTransitionState("initial"), 300); // Matches CSS transition duration
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  /**
   * Handles the close action, initiating the fade-out transition and then calling the `onClose` prop.
   */
  const handleClose = useCallback(() => {
    setTransitionState("exiting");
    // Call the parent's onClose after the CSS transition duration
    setTimeout(onClose, 300);
  }, [onClose]);

  /**
   * Handles clicks on the overlay background, triggering a close action.
   * Ensures that clicks within the content area do not close the overlay.
   * @param {React.MouseEvent<HTMLDivElement>} e - The mouse event.
   */
  const handleBackgroundClick = useCallback((e) => {
    if (e.target === e.currentTarget) { // Only close if the click is directly on the background
      handleClose();
    }
  }, [handleClose]);

  /**
   * Renders the content for the currently active tab.
   * @returns {JSX.Element} The JSX content for the active tab.
   */
  const renderTabContent = useCallback(() => {
    // Content for each tab is defined here.
    // Using paragraphs and headings as per the refactoring of the original list structures.
    switch (activeTab) {
      case "philosophy":
        return (
          <div className="tab-pane">
            <h3>Stop letting your assets gather virtual dust</h3>
            <p>
              Most NFTs are digital posters in expensive frames. Static.
              Lifeless. Collecting virtual dust in a wallet that's little more
              than a glorified vault. Is that really the revolution? That
              thinking misses the entire point of true digital ownership, decentralization and the
              universe of possibility unlocked by LUKSO's Universal Profiles.
            </p>
            <h4>Decentralization Creates</h4>
            <p>
              Centralized platforms lure you in, then dictate exactly how you can
              interact with the stuff "you supposedly own". Their APIs, their
              features, their arbitrary limits. They build the playground, you
              just get to use the swings they allow.
            </p>
            <p>
              LUKSO flips the script. Your Universal Profile is your own sovereign space on the blockchain. Your
              assets, your data, your configurations. They all live with you, under
              your control, accessible through open standards.
            </p>
            <div className="info-card">
              <h4>Your NFTs are an Engine</h4>
              <p>
                RADAR is the antidote to static and treats your NFTs as a living
                visual source. Assign NFTs to layers, make them breathe with
                audio, contort them with MIDI and make them react to on-chain
                events. Where most blockchain interactions remain abstract data,
                RADAR turns these into a visual experience.
              </p>
            </div>
            <div className="info-card">
              <h4>Ownership = Uncensored Freedom to Use (and Abuse)</h4>
              <p>
                Holding is basic. Using is power. RADAR gives you the freedom to
                push your owned assets. Layer 'em, glitch 'em, blend 'em into
                oblivion. Save infinite configurations on chain, discover visuals
                the original creator couldn't fathom. Break the mold. Go wild.
              </p>
            </div>
            <div className="info-card">
              <h4>From collector to creator</h4>
              <p>
                RADAR hands you the keys to the visual kingdom. That unique NFT
                becomes a Generative Art Motor. You're not just a collector;
                you're a VJ, a digital sculptor, unleashing the dormant power
                within your assets. Make something new. Make something yours.
              </p>
            </div>
            <div className="info-card">
              <h4>Composable & Open: Build Together</h4>
              <p>
                Visual presets, MIDI maps, event reactions, they are all stored
                on your profile, using ERC725Y keys. This isn't locked away in a
                database; it's decentralized data YOU own. Imagine building a
                collaborative and collective visual database. RADAR makes it
                possible through the usage of a globally defined MIDI map key
                tied to your profile. This makes cross profile VJ'ing possible,
                you can not only just check out another profile's presets, you
                can also play their owned assets while you are browsing them. Imagine it like this:
                if the RADAR Genesis Collection happens to sell out, you can perceive it as a collection
                that is now actually owned by the community. How? By setting up your owned assets
                as presets through saved dynamic keys, you also make them available to others to play around with.
                So, your profile not only looks good with your own presets, people now have a reason to visit your
                profile because you have the most / coolest presets available. Tying this with the global MIDI key
                that is loaded from your profile while browsing his presets opens another door to the imagination
                how these keys can be used.
              </p>
            </div>
            <div className="info-card">
              <h4>Provenance + Use is the Future</h4>
              <p>
                Forget archaic IP restrictions. On LUKSO, LSP4 metadata provides
                immutable, on-chain proof of origin, linked to the creator's UP.
                That's provenance solved, right at the front door. RADAR focuses
                on the next step: empowering radical use and transformation of
                your owned assets. It's about creative liberation, not legal
                handcuffs.
              </p>
            </div>
            <p style={{ marginTop: "var(--space-lg)", fontWeight: "bold" }}>
              While others are still figuring out profile pictures, LUKSO built
              the operating system for the decentralized future. It's here & fully operational so
              stop letting your assets gather virtual dust. Load 'em UP! Crank
              the knobs. RADAR is a statement against digital stagnation. It's
              proof that the future of digital art is dynamic, interactive, radically free & deeply embeded in your profile's DNA.
            </p>
          </div>
        );
      case "general":
        return (
          <div className="tab-pane">
            <h3>What is RADAR?</h3>
            <p>
              RADAR is short for "Reactive Asset Driven Audio Receiver", it's way more than just an
              NFT viewer. It's a high-performance, multi-layer visual
              synthesizer built for the architecture of the LUKSO
              ecosystem. It lives directly within your Universal Profile,
              transforming your static digital assets into dynamic, interactive
              art pieces you control.
            </p>
            <div className="info-card">
              <h4>Core Pillars:</h4>
              <p>
                <strong>Visual Synthesis Engine:</strong> Utilizes a 3-layer
                system where LSP8 NFTs become the raw visual material,
                manipulated in real-time.
              </p>
              <p>
                <strong>Multi-Modal Reactivity:</strong> Responds dynamically
                to external stimuli, the rhythm and frequencies of audio (Web
                Audio API) and the precise control of MIDI hardware (Web MIDI
                API).
              </p>
              <p>
                <strong>Blockchain Awareness (LSP1):</strong> Directly connects
                to your Universal Profile's event stream via the LSP1
                Universal Receiver standard, enabling visual reactions (for now custom color coded pulses) to
                on-chain activity like receiving LYX, receiving and sending LSP7/8 tokens, Follower lost, Follower Gained.
                You can fullsceen the RADAR application on a second screen, put on some good music, activate the responsive audio layers, pour in a coctail and get notified through these color coded pulses.
                At a glance you can see what events are incoming.
                This makes blockchain events not only tied to just data driven notifications but actual visual experiences you have set up yourself, fully configurable.
              </p>
              <p>
                <strong>Decentralized State (ERC725Y):</strong> All your
                configurations, intricate visual presets, personalized MIDI
                mappings, custom event reactions are saved directly onto
                your Universal Profile using ERC725Y key-value
                storage. No servers, no databases, just your profile.
              </p>
              <p>
                <strong>Optimized Performance:</strong> Engineered for
                fluidity, targeting high FPS to ensure a seamless, immersive
                visual experience even with complex layer interactions.
              </p>
            </div>
            <p>
              RADAR is a demonstration of LUKSO's potential: creating
              applications that are deeply integrated with user identity, truly
              ownable, and capable of unlocking unprecedented creative utility
              for digital assets.
            </p>
          </div>
        );
      case "layers":
        return (
          <div className="tab-pane">
            <h3>Layer Controls & MIDI Mastery</h3>
            <p>
              RADAR's power lies in its three-layer system. Think of them as
              channels on a visual mixer, each driven by an NFT and fine-tuned
              with these controls:
            </p>
            <div className="info-card">
              <h4>Layer Parameters:</h4>
              <p>
                <strong>Layer Selection:</strong> Use the Top/Middle/Bottom
                tabs to target a specific layer.
              </p>
              <p>
                <strong>Core Visuals:</strong> Control `Speed`, `Size`,
                `Angle`, `Direction`, and `Opacity`.
              </p>
              <p>
                <strong>Positioning:</strong> Manually shift the layer's
                origin with `X/Y Position`.
              </p>
              <p>
                <strong>Organic Movement:</strong> Add subtle, flowing motion
                with `Drift` and `Drift Speed`.
              </p>
              <p>
                <strong>Visual Interaction:</strong> Define how layers blend
                using `Blend Mode`.
              </p>
              <p>
                <strong>Visibility:</strong> Toggle layers on/off with
                `Enabled`.
              </p>
            </div>
            <div className="info-card">
              <h4>MIDI Integration: Your Tactile Command Center</h4>
              <p>Why click when you can play? RADAR features robust MIDI Learn:</p>
              <p>Connect your MIDI controller.</p>
              <p>
                When connecting a class compliant USB MIDI contoller through the MIDI button in the bottom right a midi learn function becomes available in the controls panel.
                Click the small 'M' button next to any parameter (Speed, Size,
                X Pos, etc.). Move a physical knob, fader, or pad on your controller. Boom. Mapped. Instantly.
              </p>
              <p>
                The magic? Your entire mapping setup is saved as{" "}
                <strong>one single entry</strong> (
                <code>RADAR.MIDI.ParameterMap</code>) in your UP's ERC725Y
                storage. Load any visual preset and your knobs always control the
                same parameters, for any profile you visit that has set up RADAR. Persistent & interoperable.
              </p>
            </div>
          </div>
        );
      case "audioReactivity":
        return (
          <div className="tab-pane">
            <h3>Audio Reactivity Setup (Using Virtual Audio Cable & Voicemeeter)</h3>
            <p>
              To make RADAR's visuals react to the audio playing on your computer (e.g., from your browser, music player, voice stream, games,...), you can route your audio through Voicemeeter using a Virtual Audio Cable. This gives you fine-grained control.
            </p>
            <div className="info-card">
              <h4>Prerequisites:</h4>
              <p>
                <strong>Voicemeeter (Standard version, Banana, or Potato) installed.</strong> Get it from vb-audio.com/Voicemeeter/.
              </p>
              <p>
                <strong>Virtual Audio Cable installed.</strong> Also from vb-audio.com (VB-CABLE).
              </p>
              <p>
                <strong>Restart your computer after installing these.</strong>
              </p>
            </div>
            <div className="info-card">
              <h4>Steps:</h4>
              <p>
                <strong>1. Route Desired Audio to the Virtual Cable:</strong>
              </p>
              <p style={{ paddingLeft: "var(--space-md)" }}>
                In Windows Sound settings ("Open Sound settings" → "App volume and device preferences"):
                Find your web browser (or the app you want to capture).
                Set its Output device to <strong>"CABLE Input (VB-Audio Virtual Cable)"</strong>.
              </p>
              <p style={{ paddingLeft: "var(--space-md)" }}>
                This ensures the browser or app audio is sent into the virtual cable for further routing.
              </p>
              <p>
                <strong>2. Configure Voicemeeter:</strong>
              </p>
              <p style={{ paddingLeft: "var(--space-md)" }}>
                Open Voicemeeter.
                Under Hardware Input 1 (or an available stereo input strip): Click the name field and select <strong>"CABLE Output (VB-Audio Virtual Cable)"</strong>.
                This brings the audio from the virtual cable into Voicemeeter.
                Make sure this channel is active (fader up, not muted).
              </p>
              <p style={{ paddingLeft: "var(--space-md)" }}>
                For your main output (to hear the audio yourself): Click "A1" (typically the first hardware output selection button on the master section) and select your real speakers or headphones. Ensure the audio from the "CABLE Output" input strip is routed to A1 (usually by default or by pressing the 'A1' button on that input strip).
              </p>
              <p>
                <strong>3. Browser Permissions for RADAR:</strong>
              </p>
              <p style={{ paddingLeft: "var(--space-md)" }}>
                When enabling Audio Reactivity in RADAR, your browser will ask for microphone permission. Click "Allow".
                Ensure the microphone source selected in the browser (if it gives you a choice, or in browser settings) is set to <strong>"Voicemeeter Output (VB-Audio Voicemeeter VAIO)"</strong> or a similar name representing Voicemeeter's main virtual output.
              </p>
            </div>
            <div className="info-card">
              <h4>How it Works:</h4>
              <p>
                Your system audio (from the selected browser/app) is sent to <strong>"CABLE Input"</strong>.
                The <strong>"CABLE Output"</strong> then carries this audio into a Voicemeeter input strip.
                Voicemeeter processes this audio, sends it to your physical speakers/headphones (via A1, A2, etc.), and simultaneously makes it available through its own virtual output (e.g., <strong>"Voicemeeter Output VAIO"</strong>), which acts like a virtual microphone.
                RADAR listens to this "Voicemeeter Output" as if it were a microphone input, capturing the audio you've routed.
              </p>
            </div>
            <p>
              This method allows selective audio routing for the visualizer without capturing your real microphone or unwanted system sounds.
            </p>
            <div className="info-card">
              <h4>Embedding RADAR with Permissions:</h4>
              <p>
                If you are embedding RADAR (e.g., in an iframe), ensure you grant the necessary permissions for full functionality:
              </p>
              <p>
                <code>{`<iframe src="https://radar725.netlify.app/" allow="microphone; midi; fullscreen"></iframe>`}</code>
              </p>
              <p>
                This allows RADAR to access the microphone (for audio reactivity), MIDI devices, and enter fullscreen mode.
              </p>
            </div>
          </div>
        );
      case "events":
        return (
          <div className="tab-pane">
            <h3>LSP1 UniversalReceiver: Visualizing Your Blockchain Life</h3>
            <p>
              Your Universal Profile isn't just a container; it's an active
              participant on the blockchain. RADAR taps into this activity using
              the standardized <strong>LSP1 UniversalReceiver</strong>, turning
              on-chain events into visual feedback.
            </p>
            <div className="info-card">
              <h4>The LSP1 Advantage:</h4>
              <p>
                <strong>Standardized Notifications:</strong> LSP1 provides a
                single, reliable endpoint on your UP for receiving
                notifications about incoming value (LYX, LSP7 Tokens) and
                potentially other standardized actions across the ecosystem.
              </p>
              <p>
                <strong>Real-Time Connection:</strong> RADAR maintains a
                WebSocket connection to monitor these LSP1 events as they
                happen on your profile.
              </p>
              <p>
                <strong>Custom Reactions:</strong> The "Event Reactions" panel
                lets you define rules: "IF LYX Received THEN Trigger Orange
                Pulse on Layer 1". You choose the event, the target layer, and
                the visual effect.
              </p>
              <p>
                <strong>Persistent & Global (ERC725Y):</strong> Your entire
                ruleset is saved to the global{" "}
                <code>RADAR.EventReactions</code> key on your UP. Set it up
                once, and your profile will visually react according to your
                rules, no matter which visual preset is loaded.
              </p>
            </div>
            <p>
              Leveraging the core architecture of LUKSO UPs to create a reactive, personalized
              experience directly linked to your on-chain interactions.
            </p>
          </div>
        );
      case "tokens":
        return (
          <div className="tab-pane">
            <h3>NFTs Reimagined: LSP8 Assets as Visual Fuel</h3>
            <p>
              RADAR is built around LUKSO's next-generation NFT standard,{" "}
              <strong>LSP8 Identifiable Digital Asset</strong>. These aren't
              just static collectibles; they are the dynamic source material for
              the visualizer.
            </p>
            <div className="info-card">
              <h4>Why LSP8 Matters:</h4>
              <p>
                <strong>Rich Metadata (LSP4):</strong> RADAR utilizes the
                associated{" "}
                <strong>LSP4 Digital Asset Metadata</strong> standard to
                reliably fetch crucial information like token names and image
                locations (including IPFS resolution). This structured data
                avoids the inconsistencies plagueing older NFT standards.
              </p>
              <p>
                <strong>Designed for Interaction:</strong> While RADAR
                primarily uses the visual aspect, LSP8 allows for richer data
                and potential future interactions beyond what other standards offer.
              </p>
            </div>
            <div className="info-card">
              <h4>Loading Assets:</h4>
              <p>
                <strong>Transparency is Power:</strong> Assets created with
                transparent backgrounds (like the RADAR Genesis collection)
                unlock the full potential of the layering system, allowing
                intricate visual blending.
              </p>
              <p>
                <strong>Demo & Owned:</strong> Experiment instantly with
                built-in Demo Tokens, or connect your UP via the extension to
                access LSP8 NFTs you own from RADAR-whitelisted collections.
              </p>
              <p>
                <strong>Simple Application:</strong> Use the Token Selector
                panel, choose your target layer (Top/Middle/Bottom), and click
                an asset to load it instantly.
              </p>
            </div>
            <p>
              By embracing LSP8 and LSP4, RADAR moves beyond basic NFT display
              towards true digital asset *utility* and *composability*.
            </p>
          </div>
        );
      case "configurations":
        return (
          <div className="tab-pane">
            <h3>
              On-Chain Configurations: Your State, Your Profile (ERC725Y)
            </h3>
            <p>
              Forget saving files locally or relying on centralized backends.
              RADAR leverages the <strong>ERC725Y</strong> standard to store all
              your personalized configurations directly and decentrally onto your
              Universal Profile's storage. This is a cornerstone of the LUKSO
              vision.
            </p>
            <div className="info-card">
              <h4>How RADAR Uses Your UP Storage:</h4>
              <p>
                <strong>
                  Visual Presets (Map:{" "}
                  <code>{`RADAR.NamedConfiguration:<nameHash>`}</code>):
                </strong>{" "}
                Every unique visual setup you create (layers, loaded tokens,
                all parameters) can be saved as a named preset. RADAR uses an
                ERC725Y Map, hashing the preset name to generate a unique
                storage key. This allows you to store a virtually unlimited
                number of distinct visual configurations directly on your
                profile.
              </p>
              <p>
                <strong>
                  Preset Index (Array:{" "}
                  <code>RADAR.SavedConfigurationList[]</code>):
                </strong>{" "}
                To keep track of your named presets, RADAR maintains an ERC725Y
                Array storing the names of all your saved configurations. This
                populates the Preset Selector Bar.
              </p>
              <p>
                <strong>
                  Default Preset (Singleton:{" "}
                  <code>RADAR.DefaultConfigurationName</code>):
                </strong>{" "}
                Designate your favorite preset! RADAR stores the *name* of your
                chosen default preset in this Singleton key. This is the
                configuration automatically loaded when anyone views RADAR on
                your profile.
              </p>
              <p>
                <strong>
                  Global MIDI Map (Singleton:{" "}
                  <code>RADAR.MIDI.ParameterMap</code>):
                </strong>{" "}
                Your entire MIDI controller mapping schema is saved to this
                single key. Consistent control across all presets.
              </p>
              <p>
                <strong>
                  Global Reactions (Singleton:{" "}
                  <code>RADAR.EventReactions</code>):
                </strong>{" "}
                All your custom LSP1 event-to-visual effect rules are stored
                together in this key. Persistent blockchain reactivity.
              </p>
            </div>
            <div className="info-card">
              <h4>Management:</h4>
              <p>Use the "Save" panel (write icon) to:</p>
              <p>Save new named Visual Presets.</p>
              <p>
                Optionally update the Global MIDI and Reaction keys when
                saving a preset.
              </p>
              <p>Explicitly save only the Global MIDI or Reaction keys.</p>
              <p>
                Load any saved preset by name or load your designated Default.
              </p>
              <p>
                Delete unwanted presets (which removes them from the Map and
                the Array).
              </p>
            </div>
            <p>
              This powerful combination of ERC725Y data types enables a truly
              decentralized, persistent, and user-owned application state,
              showcasing the advanced capabilities of Universal Profiles.
            </p>
          </div>
        );
      case "collections":
        return (
          <div className="tab-pane">
            <h3>
              Whitelisted Collections: Curated Compatibility (ERC725Y & LSP4)
            </h3>
            <p>
              To ensure assets load correctly and interact well with the visual
              engine, RADAR utilizes an on-chain whitelist managed by the
              project's admin profile.
            </p>
            <div className="info-card">
              <h4>The Whitelist System:</h4>
              <p>
                <strong>On-Chain List (ERC725Y):</strong> A list of approved
                LSP8 collection contract addresses is stored under the{" "}
                <code>RADAR.WhitelistedCollections</code> key on the admin UP.
              </p>
              <p>
                <strong>Loading Owned Assets:</strong> When you connect your
                UP, RADAR checks which LSP8 assets you hold (via LSP5 Received
                Assets) and cross-references them against this on-chain
                whitelist. Only assets from approved collections appear in the
                "My Owned Tokens" tab.
              </p>
              <p>
                <strong>Metadata (LSP4):</strong> For displaying collection
                information (and potentially in the future, token details),
                RADAR relies on the collection contracts supporting the LSP4
                metadata standard.
              </p>
            </div>
            <div className="info-card">
              <h4>RADAR Genesis:</h4>
              <p>
                The primary whitelisted collection is <strong>RADAR Genesis</strong>,
                featuring 8,000 unique LSP8 NFTs specifically designed by the
                creator of RADAR with transparency and visual complexity ideal
                for this layering system.
              </p>
            </div>
            <p>
              This system balances openness with quality control, ensuring a
              smooth user experience while leveraging on-chain data for
              configuration.
            </p>
          </div>
        );
      case "artists":
        return (
          <div className="tab-pane">
            <h3>Artist & Creation: The Vision Behind RADAR (LSP4)</h3>
            <p>
              RADAR wasn't built in a vacuum; it's the culmination of an
              artistic vision combined with deep exploration of LUKSO's
              technical capabilities. It's a tool built *by* an artist, *for*
              enhancing digital art.
            </p>
            <div className="info-card">
              <h4>The RADAR Genesis Collection:</h4>
              <p>
                At the heart of the demo and the initial offering is the{" "}
                <strong>RADAR Genesis</strong> collection. This isn't random
                art; it's 8,000 unique LSP8 NFTs derived from over 350
                meticulously hand-drawn characters, algorithmically processed
                into fractal forms. Crucially, they were designed from the
                ground up with <strong>transparent backgrounds</strong> and
                intricate detail specifically for RADAR's dynamic layering and
                manipulation engine.
              </p>
            </div>
            <div className="info-card">
              <h4>Empowering Owners & Redefining Utility:</h4>
              <p>
                <strong>From Static to Dynamic:</strong> RADAR empowers owners
                to transform the base artwork. Your NFT is the seed for
                countless unique visual experiences you create and control.
              </p>
              <p>
                <strong>Immutable Artist Link (LSP4):</strong> Thanks to LSP4
                metadata, the connection between the NFT, its collection, and
                the original creator's Universal Profile is permanently
                recorded on-chain. Provenance is inherent.
              </p>
              <p>
                <strong>A Solo Endeavor:</strong> This entire project – the
                concept, the 8k artwork collection, the complex
                React/Canvas/Blockchain application, the UI/UX design –
                represents thousands of hours of work by a single creator
                dedicated to realizing this vision on LUKSO.
              </p>
            </div>
            <p>
              The goal is to demonstrate that NFTs can be more than static
              collectibles – they can be living, breathing components of a
              larger creative ecosystem.
            </p>
          </div>
        );
      case "ipRights":
        return (
          <div className="tab-pane">
            <h3>IP is Old News: Embrace the New Protocol</h3>
            <p>
              As an artist, I’ve wrestled with the concept of intellectual
              property countless times. My conclusion? True artistic value isn't
              found in locking your work away; it's unleashed when you set it
              free.
            </p>
            <div className="info-card">
              <h4>Signature as the New IP</h4>
              <p>
                In this new era of digital creativity, your signature is the
                indelible mark of your authorship. This signature is
                intrinsically baked into the very fabric of your work,
                especially on platforms like LUKSO with standards like LSP4. Your
                originality becomes traceable, immutable, and profoundly
                composable. This isn't just desirable for a creator, it's
                fundamental.
              </p>
            </div>
            <div className="info-card">
              <h4>From Control to Ignition</h4>
              <p>
                Create art. Sell it. Let it evolve as it passes through hands.
                Encourage others to mutate it, remix it, and propel it to
                horizons you never imagined. This isn't theft, it's the
                cultivation of a living legacy.
              </p>
              <p>
                My vision towards this has shifted immensly through paying
                carefull attention what LUKSO is stating. I no longer seek
                control, I aim for ignition. I want my art to be the spark for
                someone else’s artistic journey. And through LUKSO's Universal
                Profiles and LSP4 metadata, your name, your provenance, remains
                eternally linked.
              </p>
            </div>
            <div className="info-card">
              <h4>Transparency for the AI Era</h4>
              <p>
                Imagine an AI trained on a dataset where every single piece
                includes embedded, verifiable metadata about the original
                artist, its title, its context. No more guesswork, no more
                unethical scraping, no more protracted lawsuits. Just pure,
                unadulterated transparency.
              </p>
              <p>
                This approach, built on foundational standards native to LUKSO,
                solves the attribution problem from the outset.
              </p>
            </div>
            <div className="info-card">
              <h4>Beyond Outdated Legal Frameworks</h4>
              <p>
                Attempting to combat the dynamic nature of AI and Web3 remix
                culture with archaic IP laws is like bringing a quill to a data
                stream. Traditional IP rights often serve middlemen who monetize
                your creativity, packaging you as a product while claiming to
                protect you.
              </p>
            </div>
            <p style={{ marginTop: "var(--space-lg)", fontWeight: "bold" }}>
              Don’t become a product. Become the protocol. Embrace the future
              where your art lives, breathes, and inspires, all while your
              authorship is clearly and immutably recognized on LUKSO.
            </p>
          </div>
        );
      case "roadmap":
        return (
          <div className="tab-pane">
            <h3>Roadmap: The Journey Ahead</h3>
            <p>
              RADAR is launched, but the vision extends further. This is a
              living project fueled by the potential of LUKSO and my personal to
              push self expression and creative boundaries.
            </p>
            <div className="info-card">
              <h4>Potential Future Directions:</h4>
              <p>
                <strong>Visual Effect Expansion:</strong> Adding more diverse
                and controllable visual effects triggered by LSP1 events or
                MIDI signals.
              </p>
              <p>
                <strong>Advanced MIDI Capabilities:</strong> Investigating
                features like MIDI clock synchronization for tempo-based
                effects, or more sophisticated mapping options (e.g., value
                ranges, toggles).
              </p>
              <p>
                <strong>Preset Sharing & Discovery:</strong> Building tools or
                standards to allow users to easily share their on-chain RADAR
                presets, fostering a community library of visual setups.
              </p>
              <p>
                <strong>Collection Onboarding:</strong> Streamlining the
                process for suggesting and potentially whitelisting new,
                compatible LSP8 collections from the community.
              </p>
              <p>
                <strong>Performance & Optimization:</strong> Continuously
                refining the rendering engine (CanvasManager) for maximum
                efficiency across devices.
              </p>
              <p>
                <strong>Open Source Strategy:</strong> Evaluating which parts
                of RADAR could be open-sourced to serve as examples and
                building blocks for other LUKSO developers.
              </p>
            </div>
            <p>
              The path forward will be shaped by user feedback and the evolving
              capabilities of the LUKSO network. Join the conversation and help
              define the future of dynamic digital art!
            </p>
          </div>
        );
      default:
        return (
          <div className="tab-pane">
            <p>Select a tab to view information.</p>
          </div>
        );
    }
  }, [activeTab]); // Dependency on activeTab to re-render content when tab changes

  // Do not render the overlay at all if it's closed and not in the process of exiting.
  // This prevents an invisible DOM element from potentially interfering with interactions.
  if (!isOpen && transitionState === "initial") {
    return null;
  }

  return (
    <div
      className={`overlay ${transitionState}`} // CSS classes control visibility and transitions
      onClick={handleBackgroundClick}
      role="dialog" // Accessibility: Indicate it's a dialog
      aria-modal="true" // Accessibility: Indicate it's a modal dialog
      aria-labelledby="info-overlay-title" // Accessibility: Link to title
    >
      <div className="overlay-content" role="document"> {/* Accessibility: Content container */}
        <div className="overlay-header">
          <h2 className="overlay-title" id="info-overlay-title">
            <img
              src={radarWordmarkBlue}
              alt="RADAR Application Information" // More descriptive alt text
              className="radar-logo-image"
            />
          </h2>
          <button
            className="close-button"
            onClick={handleClose}
            aria-label="Close Information Overlay" // Accessibility
            title="Close" // Tooltip
          >
            ✕
          </button>
        </div>
        <div className="overlay-body">
          <div className="info-overlay-tab-navigation" role="tablist" aria-orientation="vertical">
            {/* Tab buttons with ARIA roles and properties for accessibility */}
            <button
              className={`info-overlay-tab-button ${activeTab === "philosophy" ? "active" : ""}`}
              onClick={() => setActiveTab("philosophy")}
              role="tab"
              aria-selected={activeTab === "philosophy"}
              aria-controls="tab-panel-philosophy" // Link to corresponding tab panel
            >
              Philosophy
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "general" ? "active" : ""}`}
              onClick={() => setActiveTab("general")}
              role="tab"
              aria-selected={activeTab === "general"}
              aria-controls="tab-panel-general"
            >
              About
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "layers" ? "active" : ""}`}
              onClick={() => setActiveTab("layers")}
              role="tab"
              aria-selected={activeTab === "layers"}
              aria-controls="tab-panel-layers"
            >
              Controls
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "audioReactivity" ? "active" : ""}`}
              onClick={() => setActiveTab("audioReactivity")}
              role="tab"
              aria-selected={activeTab === "audioReactivity"}
              aria-controls="tab-panel-audioReactivity"
            >
              Audio Reactivity
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "events" ? "active" : ""}`}
              onClick={() => setActiveTab("events")}
              role="tab"
              aria-selected={activeTab === "events"}
              aria-controls="tab-panel-events"
            >
              Universal Receiver
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "tokens" ? "active" : ""}`}
              onClick={() => setActiveTab("tokens")}
              role="tab"
              aria-selected={activeTab === "tokens"}
              aria-controls="tab-panel-tokens"
            >
              Tokens
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "configurations" ? "active" : ""}`}
              onClick={() => setActiveTab("configurations")}
              role="tab"
              aria-selected={activeTab === "configurations"}
              aria-controls="tab-panel-configurations"
            >
              Configurations
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "collections" ? "active" : ""}`}
              onClick={() => setActiveTab("collections")}
              role="tab"
              aria-selected={activeTab === "collections"}
              aria-controls="tab-panel-collections"
            >
              Collections
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "artists" ? "active" : ""}`}
              onClick={() => setActiveTab("artists")}
              role="tab"
              aria-selected={activeTab === "artists"}
              aria-controls="tab-panel-artists"
            >
              Artists
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "ipRights" ? "active" : ""}`}
              onClick={() => setActiveTab("ipRights")}
              role="tab"
              aria-selected={activeTab === "ipRights"}
              aria-controls="tab-panel-ipRights"
            >
              IP Rights
            </button>
            <button
              className={`info-overlay-tab-button ${activeTab === "roadmap" ? "active" : ""}`}
              onClick={() => setActiveTab("roadmap")}
              role="tab"
              aria-selected={activeTab === "roadmap"}
              aria-controls="tab-panel-roadmap"
            >
              Roadmap
            </button>
          </div>

          {/* Tab content panels with ARIA properties */}
          <div className="tab-content" id={`tab-panel-${activeTab}`} role="tabpanel" aria-labelledby={`tab-button-${activeTab}`}>
            {renderTabContent()}
          </div>
        </div>
      </div>
    </div>
  );
};

InfoOverlay.propTypes = {
  /** Controls whether the overlay is currently open or closed. */
  isOpen: PropTypes.bool.isRequired,
  /** Callback function invoked when the overlay requests to be closed. */
  onClose: PropTypes.func.isRequired,
};

export default React.memo(InfoOverlay); // Memoize for performance if props are stable
```

---
### `src\components\Panels\NotificationPanel.jsx`
```jsx
// src/components/Panels/NotificationPanel.jsx
import React, { useState, useEffect, useMemo } from "react";
import PropTypes from "prop-types";

import Panel from "./Panel"; // Local component
import { useProfileCache } from "../../hooks/useProfileCache"; // Local hook

import { isAddress } from "viem"; // Third-party utility

import "./PanelStyles/NotificationPanel.css"; // Local styles

/**
 * Formats an Ethereum address for display by showing the beginning and end.
 * Returns "Unknown Address" if the input is invalid.
 * @param {string | null | undefined} address - The address string.
 * @param {number} [length=6] - The number of characters to show from the start and end.
 * @returns {string} The formatted address or "Unknown Address".
 */
const formatAddress = (address, length = 6) => {
  if (!address || typeof address !== "string" || !address.startsWith("0x")) {
    return "Unknown Address";
  }
  if (address.length <= length * 2 + 2) {
    return address;
  }
  return `${address.substring(0, length + 2)}...${address.substring(address.length - length)}`;
};

/**
 * @typedef {object} Notification
 * @property {string|number} id - Unique ID of the notification.
 * @property {string} type - Type of the event (e.g., 'lyx_received', 'follower_gained').
 * @property {string} sender - Address of the transaction sender or relevant party.
 * @property {object} [decodedPayload] - Additional decoded data, e.g., `followerAddress`.
 * @property {number} [timestamp] - Timestamp of the notification.
 * @property {boolean} [read] - Whether the notification has been marked as read.
 * @property {string|React.ReactNode} [content] - Custom content if not using default message generation.
 */

/**
 * @typedef {object} NotificationItemProps
 * @property {Notification} notification - The notification object to display.
 * @property {(id: string|number) => void} [onMarkAsRead] - Callback function to mark the notification as read.
 */

/**
 * NotificationItem: Displays a single notification.
 * It resolves sender and follower addresses to profile names using `useProfileCache`
 * for better readability. Allows marking as read on click.
 *
 * @param {NotificationItemProps} props - The component's props.
 * @returns {JSX.Element} The rendered NotificationItem component.
 */
const NotificationItem = ({ notification, onMarkAsRead }) => {
  const { getCachedProfile, getProfileData } = useProfileCache();
  const itemLogPrefix = `[NotifItem ID:${String(notification.id).slice(-5)} Type:${notification.type}]`;


  const [senderName, setSenderName] = useState(() => {
    const initialName = notification.sender ? formatAddress(notification.sender) : "Unknown Sender";
    if (import.meta.env.DEV) console.log(`${itemLogPrefix} Initial senderName set to: ${initialName}`);
    return initialName;
  });

  const [followerName, setFollowerName] = useState(() => {
      const addr = notification.decodedPayload?.followerAddress;
      const initialName = addr && isAddress(addr) ? formatAddress(addr) : null;
      if (import.meta.env.DEV) console.log(`${itemLogPrefix} Initial followerName set to: ${initialName} (from followerAddress: ${addr})`);
      return initialName;
  });

  // Effect to fetch and update sender's profile name
  useEffect(() => {
    const senderAddress = notification.sender;
    if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER effect. Address: ${senderAddress}`);
    if (senderAddress && isAddress(senderAddress)) {
      const cachedProfile = getCachedProfile(senderAddress);
      if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER cachedProfile for ${senderAddress}:`, cachedProfile);
      if (cachedProfile?.name) {
        if (senderName !== cachedProfile.name) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER setSenderName from CACHE: ${cachedProfile.name}`);
            setSenderName(cachedProfile.name);
        }
      } else if (cachedProfile?.error) {
        const errorName = `Error (${formatAddress(senderAddress,4)})`;
        if (senderName !== errorName) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER setSenderName from CACHED ERROR: ${errorName}`);
            setSenderName(errorName);
        }
      } else { 
        if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER no valid cache, calling getProfileData for ${senderAddress}`);
        getProfileData(senderAddress).then((profileData) => {
          if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER getProfileData response for ${senderAddress}:`, profileData);
          if (profileData?.name) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER setSenderName from FETCH: ${profileData.name}`);
            setSenderName(profileData.name);
          } else if (profileData === null && import.meta.env.DEV) { // Explicitly null usually means invalid address to fetch
             console.warn(`${itemLogPrefix} SENDER getProfileData returned null for ${senderAddress}. Keeping current name: ${senderName}`);
          }
          // If profileData is an error object from getProfileData, its name field will indicate error.
        }).catch(err => {
            if(import.meta.env.DEV) console.error(`${itemLogPrefix} SENDER Error in getProfileData promise for ${senderAddress}:`, err);
        });
      }
    } else if (senderName !== "Unknown Sender") {
      if (import.meta.env.DEV) console.log(`${itemLogPrefix} SENDER setSenderName to 'Unknown Sender' (no valid address)`);
      setSenderName("Unknown Sender");
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [notification.sender, getProfileData, getCachedProfile]); // senderName removed to avoid re-fetch loops on its own change

  // Effect to fetch and update follower's profile name
  useEffect(() => {
    const followerAddr = notification.decodedPayload?.followerAddress;
    if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER effect. Address: ${followerAddr}`);

    if ((notification.type === "follower_gained" || notification.type === "follower_lost") && followerAddr && isAddress(followerAddr)) {
      const cachedProfile = getCachedProfile(followerAddr);
      if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER cachedProfile for ${followerAddr}:`, cachedProfile);

      if (cachedProfile?.name) {
        if (followerName !== cachedProfile.name) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER setFollowerName from CACHE: ${cachedProfile.name}`);
            setFollowerName(cachedProfile.name);
        }
      } else if (cachedProfile?.error) {
        const errorName = `Error (${formatAddress(followerAddr, 4)})`;
        if (followerName !== errorName) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER setFollowerName from CACHED ERROR: ${errorName}`);
            setFollowerName(errorName);
        }
      } else {
        if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER no valid cache, calling getProfileData for ${followerAddr}`);
        getProfileData(followerAddr).then((profileData) => {
          if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER getProfileData response for ${followerAddr}:`, profileData);
          if (profileData?.name) {
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER setFollowerName from FETCH: ${profileData.name}`);
            setFollowerName(profileData.name);
          } else { // No name found after fetch, or profileData is null (e.g. invalid address sent to fetch)
            const fallbackName = formatAddress(followerAddr);
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER no name from fetch, setFollowerName to FALLBACK: ${fallbackName}`);
            setFollowerName(fallbackName); 
          }
        }).catch(err => {
            if(import.meta.env.DEV) console.error(`${itemLogPrefix} FOLLOWER Error in getProfileData promise for ${followerAddr}:`, err);
            const errorName = `Error (${formatAddress(followerAddr, 4)})`;
            if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER setFollowerName to FETCH ERROR: ${errorName}`);
            setFollowerName(errorName);
        });
      }
    } else { // Not a follower event or no valid followerAddr
      if (followerName !== null) {
        if (import.meta.env.DEV) console.log(`${itemLogPrefix} FOLLOWER setFollowerName to null (not a follower event or no valid address)`);
        setFollowerName(null);
      }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [notification.id, notification.type, notification.decodedPayload?.followerAddress, getCachedProfile, getProfileData]); // followerName removed

  const getEventTypeClass = (eventType) => {
    if (typeof eventType !== "string") return "contract";
    const lower = eventType.toLowerCase();
    if (lower.includes("lyx")) return "lyx";
    if (lower.includes("token") || lower.includes("lsp7") || lower.includes("lsp8")) return "token";
    if (lower.includes("follower")) return "social";
    return "contract";
  };

  const displayMessage = useMemo(() => {
    if (notification.content) return notification.content;
    const currentFollowerName = followerName || "Someone"; // Use "Someone" if followerName is null/empty

    switch (notification.type) {
      case "lyx_received":
        return <>Received LYX from <strong>{senderName}</strong></>;
      case "follower_gained":
        return <>{currentFollowerName} started following you</>;
      case "follower_lost":
        return <>{currentFollowerName} unfollowed you</>;
      case "lsp7_received":
         return <>Received LSP7 Token from <strong>{senderName}</strong></>;
      case "lsp8_received":
         return <>Received LSP8 NFT from <strong>{senderName}</strong></>;
      default: {
        const typeLabel = (notification.type || "Event")
          .replace(/_/g, " ")
          .replace(/\b\w/g, (l) => l.toUpperCase());
        return <>{typeLabel} detected from <strong>{senderName}</strong></>;
      }
    }
  }, [notification.type, notification.content, senderName, followerName]);

  const handleItemClick = () => {
    if (onMarkAsRead && !notification.read) {
      onMarkAsRead(notification.id);
    }
  };

  return (
    <div
      className={`notification-item ${!notification.read ? "new" : ""} type-${getEventTypeClass(notification.type)}`}
      onClick={handleItemClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') handleItemClick();}}
      aria-live="polite"
      aria-label={`Notification: ${typeof displayMessage === 'string' ? displayMessage : 'Event details'}. Status: ${notification.read ? 'Read' : 'Unread'}.`}
    >
      <div className="notification-header">
        <span className="notification-timestamp">
          {notification.timestamp
            ? new Date(notification.timestamp).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
              })
            : "Unknown time"}
        </span>
        <span
          className={`notification-type-tag type-${getEventTypeClass(notification.type)}`}
        >
          {(notification.type || "EVENT").replace(/_/g, " ").toUpperCase()}
        </span>
      </div>
      <div className="notification-content">
        <div className="notification-message">{displayMessage}</div>
      </div>
    </div>
  );
};

NotificationItem.propTypes = {
  notification: PropTypes.shape({
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    type: PropTypes.string.isRequired,
    sender: PropTypes.string,
    decodedPayload: PropTypes.object,
    timestamp: PropTypes.number,
    read: PropTypes.bool,
    content: PropTypes.node,
  }).isRequired,
  onMarkAsRead: PropTypes.func,
};

const MemoizedNotificationItem = React.memo(NotificationItem);


/**
 * @typedef {object} NotificationPanelProps
 * @property {Array<Notification>} [notifications=[]] - Array of notification objects to display.
 * @property {() => void} onClose - Callback function to close the panel.
 * @property {(id: string|number) => void} [onMarkAsRead] - Callback to mark a notification as read.
 * @property {() => void} [onClearAll] - Callback to clear all notifications.
 */

/**
 * NotificationPanel: Displays a list of notifications.
 * @param {NotificationPanelProps} props - The component's props.
 * @returns {JSX.Element} The rendered NotificationPanel component.
 */
const NotificationPanel = ({
  notifications = [],
  onClose,
  onMarkAsRead,
  onClearAll,
}) => {
  return (
    <Panel
      title="NOTIFICATIONS"
      onClose={onClose}
      className="panel-from-toolbar notification-panel"
    >
      <div className="panel-header-actions">
        <button
          className="btn btn-sm btn-clear-all"
          onClick={onClearAll}
          disabled={notifications.length === 0 || typeof onClearAll !== 'function'}
          aria-label="Clear all notifications"
        >
          CLEAR ALL
        </button>
      </div>

      <div className="notification-list">
        {notifications.length === 0 ? (
          <div className="notification-empty">No notifications yet.</div>
        ) : (
          notifications.map((notification) => (
            <MemoizedNotificationItem
              key={notification.id}
              notification={notification}
              onMarkAsRead={onMarkAsRead}
            />
          ))
        )}
      </div>
    </Panel>
  );
};

NotificationPanel.propTypes = {
  notifications: PropTypes.arrayOf(PropTypes.object),
  onClose: PropTypes.func.isRequired,
  onMarkAsRead: PropTypes.func,
  onClearAll: PropTypes.func,
};

export default React.memo(NotificationPanel);
```

---
### `src\components\Panels\Panel.jsx`
```jsx
// src/components/Panels/Panel.jsx
import React from "react";
import PropTypes from "prop-types";
import "./PanelStyles/PanelStyles.css"; // Local styles

/**
 * @typedef {object} PanelProps
 * @property {string} title - The title to be displayed in the panel header.
 * @property {(() => void)} [onClose] - Optional callback function to handle the close action. If provided, a close button will be rendered.
 * @property {React.ReactNode} children - The content to be rendered within the panel's body.
 * @property {string} [className=""] - Optional additional CSS class names to apply to the panel's root element for custom styling.
 * @property {string | null} [width=null] - Optional CSS width override for the panel (e.g., "300px", "50%"). If null, it defaults to a CSS variable `--panel-width`.
 */

/**
 * Base Panel component used by all panel types in the application.
 * It provides a consistent structure with a header (containing a title and an optional close button)
 * and a content area for child elements. The panel's width can be customized.
 *
 * @param {PanelProps} props - The component's props.
 * @returns {JSX.Element} The rendered Panel component.
 */
const Panel = ({ title, onClose, children, className = "", width = null }) => {
  return (
    <div
      className={`panel ${className}`} // Apply base class and any additional classes
      style={{ width: width || "var(--panel-width)" }} // Allow overriding default width via prop, fallback to CSS variable
      role="dialog" // Assuming panels are dialog-like; adjust if not always modal
      aria-labelledby="panel-title-id" // Link to title for accessibility
      // aria-modal={!!onClose} // Consider if it's always modal when closable
    >
      <div className="panel-header">
        <h2 className="panel-title" id="panel-title-id">{title}</h2>
        {onClose && ( // Conditionally render close button if onClose callback is provided
          <button
            className="close-button" // Standard class for styling
            onClick={onClose}
            aria-label={`Close ${title} panel`} // More specific accessible name
            title="Close" // Tooltip
          >
            ✕ {/* Standard multiplication sign for 'close' */}
          </button>
        )}
      </div>

      <div className="panel-content">
        {children}
      </div>
    </div>
  );
};

Panel.propTypes = {
  title: PropTypes.string.isRequired,
  onClose: PropTypes.func,
  children: PropTypes.node.isRequired,
  className: PropTypes.string,
  width: PropTypes.string,
};

// Default export is standard for React components.
export default Panel;
```

---
### `src\components\Panels\PanelStyles\EnhancedControlPanel.css`
```css
/* src/components/Panels/PanelStyles/EnhancedControlPanel.css */

/* Styles for the tab container in THIS panel */
.compact-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-sm);
}
.panel-actions {
  display: flex;
  gap: var(--space-xs);
}
.tab-navigation {
  display: flex;
  gap: var(--space-xs);
}
/* Styles for the tab buttons in THIS panel */
.tab-button {
  width: var(--icon-size-lg);
  height: var(--icon-size-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-normal);
  padding: 0;
  outline: none;
  flex-shrink: 0;
}
.tab-button:focus {
  outline: none;
  box-shadow: none;
}
.tab-button:hover {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a30);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}
.tab-button.active {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-md);
}
.tab-icon {
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  opacity: 0.8;
  transition: all var(--transition-fast);
}
.tab-button:hover .tab-icon,
.tab-button.active .tab-icon {
  opacity: 1;
  filter: drop-shadow(0 0 5px var(--color-primary-a30));
}

.vertical-layout {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.slider-container {
  margin-bottom: 3px;
}
.slider-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1px;
}
.slider-controls {
  display: flex;
  align-items: center;
  gap: 3px;
}
.slider-label {
  font-weight: bold;
  color: var(--color-text);
  font-size: 9px;
  text-transform: uppercase;
  opacity: 0.9;
  flex-shrink: 0;
  margin-right: var(--space-xs);
}
.slider-value {
  font-size: 10px;
  color: var(--color-primary-a90);
  font-weight: bold;
  min-width: 30px;
  text-align: right;
  font-family: monospace;
}
.horizontal-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: var(--color-primary-a15);
  border-radius: 2px;
  outline: none;
  border: none;
  box-shadow: none;
  cursor: pointer;
  margin-top: 2px;
}
.horizontal-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--color-primary);
  cursor: pointer;
  border: none;
  box-shadow: 0 0 4px rgba(0, 243, 255, 0.4);
  margin-top: -4px;
}
.horizontal-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--color-primary);
  cursor: pointer;
  border: none;
  box-shadow: 0 0 4px rgba(0, 243, 255, 0.4);
}

/* MIDI 'M' Button - Tiny orange button */
.midi-btn {
  padding: 0 2px;
  font-size: 8px;
  background: var(--color-warning-a15);
  border: 1px solid var(--color-warning-a30);
  border-radius: 3px;
  color: var(--color-warning);
  cursor: pointer;
  outline: none;
  line-height: 1;
  min-width: 12px;
  height: 12px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
  margin-left: 2px;
}
.midi-btn:focus {
  outline: none;
  box-shadow: none;
}
.midi-btn:hover:not(:disabled) {
  background: var(--color-warning-a25);
  border-color: var(--color-warning-a30);
  color: var(--color-warning);
}
.midi-btn.learning {
  background: var(--color-accent-a20);
  border-color: var(--color-accent);
  color: var(--color-accent);
  animation: blink 1s infinite;
}

.controls-footer {
  display: grid;
  grid-template-columns: 1fr auto auto;
  align-items: end;
  gap: var(--space-sm);
  margin-top: var(--space-sm);
  padding-top: var(--space-xs);
  border-top: 1px solid var(--color-border);
}
.blendmode-container {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex-grow: 1;
}
.blendmode-container label {
  font-size: var(--font-size-xs);
  color: var(--color-primary);
  text-transform: uppercase;
  font-weight: bold;
  margin: 0;
}
.enabled-control-vertical {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}
.enabled-control-vertical label {
  font-size: var(--font-size-xs);
  color: var(--color-primary-a90);
  text-transform: uppercase;
  font-weight: bold;
}
.enabled-control-vertical input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: var(--color-primary);
}
.changerotation-btn {
  padding: 5px;
  height: auto;
  width: auto;
  min-width: 28px;
  min-height: 28px;
  background: var(--color-primary-a15);
  border: 1px solid var(--color-primary-a30);
  border-radius: var(--radius-sm);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.changerotation-btn:hover {
  background: var(--color-primary-a25);
  box-shadow: var(--shadow-primary-sm);
}
.changerotation-icon {
  width: 18px;
  height: 18px;
  filter: drop-shadow(0 0 4px var(--color-primary));
}

.blend-mode-select,
.midi-channel-select,
.custom-select {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  font-size: var(--font-size-sm);
  padding: 5px var(--space-xs);
  background-color: var(--color-bg-alt);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  color: var(--color-text);
  outline: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='6' viewBox='0 0 12 6' fill='none'%3E%3Cpath d='M6 6L0 0H12L6 6Z' fill='%2300f3ff'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--space-xs) center;
  cursor: pointer;
}
.blend-mode-select:focus,
.midi-channel-select:focus,
.custom-select:focus {
  border-color: var(--color-primary-a30);
  box-shadow: none;
}

.blend-mode-select option,
.midi-channel-select option {
  background-color: var(--color-bg-dark, #050f19);
  color: var(--color-primary);
  padding: var(--space-xs) var(--space-sm);
}

.layer-mappings {
  background: var(--color-bg-alt);
  padding: 5px;
  border-radius: var(--radius-md);
  margin-bottom: var(--space-xs);
}
.layer-mapping-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-xs);
}
.layer-mapping-item {
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: 4px;
}
.layer-mapping-item.active {
  border-color: var(--color-primary-a50);
  background: var(--color-primary-a10);
}
.layer-mapping-label {
  font-weight: bold;
  margin-bottom: 2px;
  font-size: 9px;
}
.layer-mapping-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-xs);
}
.layer-mapping-text {
  font-size: 9px;
  color: var(--color-text-dim);
}
.midi-learn-btn {
  padding: 0 4px;
  font-size: 9px;
  background: var(--color-primary-a10);
  border: 1px solid var(--color-primary-a20);
  border-radius: var(--radius-sm);
  color: var(--color-primary);
  cursor: pointer;
  outline: none;
  line-height: 1.1;
  min-height: 16px;
}
.midi-learn-btn:focus {
  outline: none;
  box-shadow: none;
}
.midi-learn-btn:hover:not(:disabled) {
  background: var(--color-primary-a20);
}
.midi-learn-btn.learning {
  background: var(--color-accent-a20);
  border-color: var(--color-accent);
  color: var(--color-accent);
  animation: blink 1s infinite;
}
.midi-learning-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: var(--space-xs) 0;
  padding: 5px var(--space-xs);
  background: var(--color-accent-a05);
  border: 1px solid var(--color-accent-a15);
  border-radius: var(--radius-md);
}
.midi-learning-container.layer-learning {
  background: var(--color-warning-a05);
  border: 1px solid var(--color-warning-a15);
}
.midi-learning {
  color: var(--color-accent);
  font-weight: bold;
  animation: blink 1s infinite;
  font-size: var(--font-size-sm);
}
.layer-learning .midi-learning {
  color: var(--color-warning);
}
.midi-cancel-btn {
  background: var(--color-error-a15);
  color: var(--color-error);
  border: 1px solid var(--color-error-a30);
  border-radius: var(--radius-sm);
  padding: 3px 8px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  outline: none;
}
.midi-cancel-btn:focus {
  outline: none;
  box-shadow: none;
}
.midi-cancel-btn:hover {
  background: var(--color-error-a25);
}
.midi-tools {
  display: flex;
  gap: var(--space-xs);
  margin-top: var(--space-sm);
  justify-content: space-between;
  flex-wrap: wrap;
  padding-top: var(--space-xs);
  border-top: 1px solid var(--color-border);
}
.midi-monitor-btn,
.midi-clear-btn,
.midi-reset-btn {
  background: var(--color-primary-a15);
  color: var(--color-primary);
  border: 1px solid var(--color-primary-a30);
  border-radius: var(--radius-sm);
  padding: 3px 8px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  outline: none;
  flex-shrink: 0;
  transition: background-color var(--transition-fast);
}
.midi-monitor-btn:focus,
.midi-clear-btn:focus,
.midi-reset-btn:focus {
  outline: none;
  box-shadow: none;
}
.midi-monitor-btn:hover,
.midi-clear-btn:hover,
.midi-reset-btn:hover {
  background: var(--color-primary-a25);
}
.midi-reset-btn {
  background: var(--color-warning-a15);
  color: var(--color-warning);
  border-color: var(--color-warning-a30);
}
.midi-reset-btn:hover {
  background: var(--color-warning-a25);
}
.midi-monitor {
  margin-top: var(--space-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
  max-height: 100px;
  display: flex;
  flex-direction: column;
}
.midi-monitor-header {
  background: var(--color-bg-alt);
  padding: var(--space-xs);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--color-border);
}
.midi-monitor-header h4 {
  margin: 0;
  font-size: var(--font-size-sm);
  color: var(--color-text);
}
.midi-monitor-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-xs);
  font-size: var(--font-size-xs);
  font-family: monospace;
  background: var(--color-bg);
}
.midi-monitor-empty {
  padding: var(--space-sm);
  text-align: center;
  color: var(--color-text-dim);
  font-size: var(--font-size-xs);
}
.midi-monitor-msg {
  padding: 1px 0;
  display: flex;
  border-bottom: 1px solid var(--color-border-light);
}
.midi-monitor-time {
  width: 55px;
  color: var(--color-text-dim);
}
.midi-monitor-type {
  width: 75px;
  color: var(--color-primary);
}
.midi-monitor-channel {
  width: 35px;
  color: var(--color-accent);
}
.midi-monitor-data {
  width: 25px;
  text-align: right;
  color: var(--color-text);
  margin-right: var(--space-xs);
}

/* Custom Scrollbar for MIDI Monitor */
.midi-monitor-content::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
.midi-monitor-content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}
.midi-monitor-content::-webkit-scrollbar-thumb {
  background: var(--color-primary-a30);
  border-radius: 3px;
}
.midi-monitor-content::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-a50);
}
.midi-monitor-content {
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
}

.visitor-message {
  margin-top: var(--space-md);
  padding: var(--space-sm);
  background: var(--color-primary-a05);
  border: 1px solid var(--color-primary-a15);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  color: var(--color-primary-a90);
  text-align: center;
}
.visitor-message.warning {
    background: var(--color-warning-a05);
    border-color: var(--color-warning-a15);
    color: var(--color-warning-a90);
}

@keyframes blink {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.midi-tools {
  display: flex;
  gap: var(--space-xs);
  margin-top: var(--space-sm);
  justify-content: space-between; /* Adjusted for better spacing */
  flex-wrap: wrap;
  padding-top: var(--space-xs);
  border-top: 1px solid var(--color-border);
}

/* Style for the new disconnect button */
.midi-disconnect-btn {
  background: var(--color-error-a15);
  color: var(--color-error);
  border: 1px solid var(--color-error-a30);
  border-radius: var(--radius-sm);
  padding: 3px 8px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  outline: none;
  flex-shrink: 0;
  transition: background-color var(--transition-fast);
}

.midi-disconnect-btn:focus {
  outline: none;
  box-shadow: none;
}

.midi-disconnect-btn:hover {
  background: var(--color-error-a25);
}

.midi-disconnected-message {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  text-align: center;
  width: 100%;
  padding: var(--space-xs) 0;
}

/* --- START: Styles for Sequencer Interval Control --- */
.sequencer-interval-control {
  margin-top: var(--space-lg);
  padding-top: var(--space-md);
  border-top: 1px solid var(--color-border);
}

.sequencer-interval-control .section-title { /* Re-style h4 if needed, or use existing */
  margin-bottom: var(--space-sm);
  font-size: var(--font-size-sm); /* Smaller title for this section */
  color: var(--color-primary-a90);
  text-transform: uppercase;
  font-weight: 500; /* Match other section titles if needed */
  letter-spacing: 0.5px;
  border-bottom: none; /* Remove double border if .config-section already has one */
  padding-bottom: 0;
}

.sequencer-interval-control .form-group {
  margin-bottom: 0; /* Remove bottom margin if it's the only element */
}

.sequencer-interval-control .input-with-button {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
}

.sequencer-interval-control .input-with-button .form-control {
  flex-grow: 1;
  /* Optional: make number input smaller if desired */
  /* max-width: 80px; */
}

.sequencer-interval-control .input-with-button .btn {
  flex-shrink: 0; /* Prevent button from shrinking */
}
/* --- END: Styles for Sequencer Interval Control --- */
```

---
### `src\components\Panels\PanelStyles\EnhancedSavePanel.css`
```css
@import "../../../styles/variables.css";

.enhanced-save-panel .config-section {
  margin-bottom: var(--space-lg);
  padding-bottom: var(--space-lg);
  border-bottom: 1px solid var(--color-border-dark);
}
.enhanced-save-panel .config-section:last-child {
  border-bottom: none;
  margin-bottom: var(--space-md);
}
.enhanced-save-panel h3 {
  margin-top: 0;
  margin-bottom: var(--space-md);
  color: var(--color-primary);
  font-size: var(--font-size-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.enhanced-save-panel .form-group {
  margin-bottom: var(--space-md);
}
.enhanced-save-panel .form-control {
  width: 100%;
  padding: var(--space-sm) var(--space-md);
  background-color: var(--color-bg-inset, #222);
  border: 1px solid var(--color-border, #555);
  color: var(--color-text, #eee);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-md);
}
.enhanced-save-panel .form-control:disabled {
  background-color: var(--color-bg-disabled, #333);
  cursor: not-allowed;
  opacity: 0.7;
}

.enhanced-save-panel .checkbox-options-group {
  display: flex;
  flex-direction: column;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
  padding-left: var(--space-xs);
  border: none;
  padding: 0;
}
.enhanced-save-panel .checkbox-group {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  margin-bottom: 0;
}
.enhanced-save-panel .checkbox-group input[type="checkbox"] {
  margin: 0;
  width: 16px;
  height: 16px;
  flex-shrink: 0;
  accent-color: var(--color-primary);
  cursor: pointer;
}
.enhanced-save-panel .checkbox-group label {
  margin-bottom: 0;
  font-weight: normal;
  color: var(--color-text-muted);
  cursor: pointer;
  line-height: 1.4;
  font-size: var(--font-size-sm);
}
.enhanced-save-panel .checkbox-group input[type="checkbox"]:disabled + label {
  cursor: not-allowed;
  opacity: 0.7;
}

.enhanced-save-panel .form-help-text {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  line-height: 1.5;
  margin-top: var(--space-xs);
  margin-bottom: var(--space-md);
}

.save-global-section .global-save-buttons {
  display: flex;
  gap: var(--space-sm);
  flex-wrap: wrap;
  margin-top: var(--space-sm);
}
.save-global-section .btn-save-global {
  flex-grow: 1;
  flex-basis: 150px;
}

.load-section h3 {
  color: var(--color-primary);
}
.load-section .load-actions-group {
  display: flex;
  gap: var(--space-sm);
  margin-bottom: var(--space-md);
  flex-wrap: wrap;
}
.load-section .load-actions-group .btn {
  flex-grow: 1;
  flex-basis: 150px;
}

.load-section .config-list {
  list-style: none;
  padding: 0;
  margin: 0;
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  background-color: var(--color-bg-inset, #1f1f1f);
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
}
.load-section .config-list::-webkit-scrollbar { width: 6px; height: 6px; }
.load-section .config-list::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; }
.load-section .config-list::-webkit-scrollbar-thumb { background-color: var(--color-primary-a30); border-radius: 3px; }
.load-section .config-list::-webkit-scrollbar-thumb:hover { background-color: var(--color-primary-a50); }

.load-section .config-list li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-sm) var(--space-md);
  border-bottom: 1px solid var(--color-border-dark);
}
.load-section .config-list li:last-child { border-bottom: none; }
.load-section .config-list li.active { background-color: var(--color-primary-a15); }
.load-section .config-list li.active .config-name { font-weight: bold; color: var(--color-primary); }

.load-section .config-list .config-name {
  flex-grow: 1;
  text-align: left;
  background: none;
  border: none;
  color: var(--color-primary-a90);
  cursor: pointer;
  padding: 0;
  margin-right: var(--space-sm);
  font-size: var(--font-size-md);
  font-family: var(--font-family);
}
.load-section .config-list .config-name:hover:not(:disabled) { text-decoration: none; color: var(--color-primary); }
.load-section .config-list .config-name:disabled { color: var(--color-text-muted); cursor: not-allowed; font-weight: normal; }

.load-section .config-list .delete-config {
  background: none;
  border: none;
  color: var(--color-error-a70);
  cursor: pointer;
  font-size: 1.4em;
  font-weight: bold;
  padding: 0 5px;
  line-height: 1;
  flex-shrink: 0;
  transition: color var(--transition-fast);
}
.load-section .config-list .delete-config:hover:not(:disabled) { color: var(--color-error); }
.load-section .config-list .delete-config:disabled { color: var(--color-text-muted); cursor: not-allowed; opacity: 0.5; }

.load-section .no-configs-message,
.load-section .loading-list-message {
  font-style: italic;
  color: var(--color-text-muted);
  margin-top: var(--space-md);
  padding: var(--space-sm);
  text-align: center;
  background-color: var(--color-primary-a05);
  border-radius: var(--radius-sm);
}

.status-indicator { padding: var(--space-sm) var(--space-md); border-radius: var(--radius-md); font-size: var(--font-size-sm); text-align: center; margin-bottom: var(--space-md); font-weight: bold; border: 1px solid transparent; transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
.status-indicator.pending { background-color: var(--color-warning-a10); border-color: var(--color-warning-a30); color: var(--color-warning-a90); }
.status-indicator.success { background-color: var(--color-success-a10); border-color: var(--color-success-a30); color: var(--color-success-a90); }
.status-indicator.error { background-color: var(--color-error-a10); border-color: var(--color-error-a30); color: var(--color-error-a90); }
.status-indicator.saving { background-color: var(--color-info-a10, #1a3a5a); border-color: var(--color-info-a30, #3a5a78); color: var(--color-info-a90, #b3e5fc); }
.status-indicator.idle { background-color: var(--color-primary-a05); border-color: var(--color-primary-a15); color: var(--color-primary-a70); font-weight: normal; }

.status-message { padding: var(--space-sm) var(--space-md); margin-bottom: var(--space-md); border-radius: var(--radius-md); text-align: center; font-size: var(--font-size-sm); border: 1px solid transparent; }
.status-message.success { background-color: var(--color-success-a10); border-color: var(--color-success-a30); color: var(--color-success-a90); }
.status-message.error { background-color: var(--color-error-a10); border-color: var(--color-error-a30); color: var(--color-error-a90); }
.status-message.info { background-color: var(--color-info-a10, #1a3a5a); border-color: var(--color-info-a30, #3a5a78); color: var(--color-info-a90, #b3e5fc); }
.status-message.warning { background-color: var(--color-warning-a10); border-color: var(--color-warning-a30); color: var(--color-warning-a90); }

.save-info { display: flex; align-items: flex-start; gap: var(--space-sm); padding: var(--space-md); border-radius: var(--radius-md); margin-top: var(--space-lg); margin-bottom: var(--space-md); border: 1px solid; }
.save-info span[aria-hidden="true"] { font-size: 20px; margin-top: 2px; flex-shrink: 0; }
.save-info > div { flex-grow: 1; }
.save-info .title { font-weight: bold; margin-bottom: 4px; font-size: var(--font-size-md); }
.save-info .desc { font-size: var(--font-size-sm); color: var(--color-text-muted); line-height: 1.4; }
.connection-warning.save-info { background: var(--color-error-a10); border-color: var(--color-error-a30); color: var(--color-error-a90); }
.connection-warning.save-info strong { color: var(--color-error-a90); }
.preview-banner.save-info { background: var(--color-warning-a10); border-color: var(--color-warning-a30); }
.preview-banner.save-info .title { color: var(--color-warning-a90); }
.preview-banner.save-info span[aria-hidden="true"] { color: var(--color-warning-a90); }
.visitor-banner.save-info { background: var(--color-primary-a05); border-color: var(--color-primary-a30); }
.visitor-banner.save-info .title { color: var(--color-primary); }
.visitor-banner.save-info span[aria-hidden="true"] { color: var(--color-primary); }

.btn { display: inline-block; padding: var(--space-sm) var(--space-md); border: 1px solid transparent; border-radius: var(--radius-sm); font-weight: bold; text-align: center; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; }
.btn:disabled { cursor: not-allowed; opacity: 0.6; }
.btn-block { display: block; width: 100%; }
.btn-save { background-color: var(--color-primary); border-color: var(--color-primary); color: var(--color-bg-dark); }
.btn-save:not(:disabled):hover { background-color: var(--color-primary-a70); border-color: var(--color-primary-a70); }
.btn-secondary { background-color: var(--color-bg-light); border-color: var(--color-border); color: var(--color-text); }
.btn-secondary:not(:disabled):hover { background-color: var(--color-primary-a05); border-color: var(--color-primary-a30); }
.btn-outline { background-color: transparent; border: 1px solid var(--color-primary-a30); color: var(--color-primary-a70); }
.btn-outline:not(:disabled):hover { background-color: var(--color-primary-a05); border-color: var(--color-primary-a70); }
.btn-link { background: none; border: none; padding: 0; color: var(--color-primary); cursor: pointer; text-decoration: none; }
.btn-link:hover:not(:disabled) { text-decoration: underline; }
.btn-link:disabled { color: var(--color-text-muted); cursor: not-allowed; text-decoration: none; }
.btn-icon { background: none; border: none; padding: 2px 5px; cursor: pointer; line-height: 1; }
.btn-icon:disabled { cursor: not-allowed; opacity: 0.5; }

.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
```

---
### `src\components\Panels\PanelStyles\Eventspanel.css`
```css
@import "../../../styles/variables.css";

.events-panel-custom-scroll .section-title {
  font-size: var(--font-size-sm);
  color: var(--color-primary);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  opacity: 0.9;
  font-weight: 600;
  letter-spacing: 0.5px;
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
}

.events-panel-custom-scroll .form-help-text {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  line-height: 1.4;
  margin-bottom: var(--space-md);
}

/* Target options specifically within this panel's selects */
.events-panel-custom-scroll .custom-select option {
  background-color: var(--color-bg-dark, #050f19);
  color: var(--color-primary);
  padding: var(--space-xs) var(--space-sm);
}
/* Style for the select element itself when opened (browser dependent) */
.events-panel-custom-scroll .custom-select {
    background-color: var(--color-bg-alt);
}
.events-panel-custom-scroll .custom-select:focus {
   background-color: var(--color-bg-dark);
   border-color: var(--color-primary-a50);
}

.reaction-form.section-box {
  margin-bottom: var(--space-lg);
}

.color-config-section {
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  margin-top: var(--space-md);
  margin-bottom: var(--space-md);
}

.config-section-title {
  font-size: var(--font-size-xs);
  color: var(--color-primary);
  margin-bottom: var(--space-sm);
  text-transform: uppercase;
  opacity: 0.8;
  font-weight: 500;
}

.color-preview-container {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
  margin-bottom: var(--space-md);
}

.color-preview-label {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
}

.color-preview {
  height: 25px;
  flex-grow: 1;
  border-radius: var(--radius-sm);
  border: 1px solid var(--color-border);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
}

/* UPDATED STYLES FOR SLIDER SPACING */
.color-config-section .slider-group { /* Targets slider groups specifically within color-config-section */
  display: flex;
  flex-direction: column;
  gap: 2px; /* Reduced gap between slider containers */
}
.color-config-section .slider-container { /* Targets slider containers specifically within color-config-section */
  margin-bottom: 0px; /* Removed bottom margin from individual slider containers */
}

.color-config-section .slider-header { /* Targets slider headers specifically within color-config-section */
  /* This overrides the global .slider-header margin if needed, or complements it */
  margin-bottom: 2px; /* Reduced space between header and the input */
}

.color-config-section input[type="range"].color-slider { /* Targets color sliders specifically */
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 3px;
  cursor: pointer;
  outline: none;
  margin-top: 2px; /* Reduced space above the slider input */
}
/* END UPDATED STYLES FOR SLIDER SPACING */


input[type="range"].color-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 14px;
  height: 14px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.5);
  margin-top: -4px; /* This helps vertically center the thumb on the track */
}
input[type="range"].color-slider::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  box-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.5);
}

input[type="range"].red-slider { background: linear-gradient(to right, #000000, #ff0000); }
input[type="range"].green-slider { background: linear-gradient(to right, #000000, #00ff00); }
input[type="range"].blue-slider { background: linear-gradient(to right, #000000, #0000ff); }
input[type="range"].alpha-slider { background: linear-gradient( to right, rgba(var(--color-primary-rgb), 0), var(--color-primary) ); }

.active-reactions.section-box {
  margin-top: var(--space-lg);
  border-top: 1px solid var(--color-border);
  padding-top: var(--space-md);
}

.no-reactions {
  color: var(--color-primary-a50);
  font-style: italic;
  font-size: var(--font-size-sm);
  text-align: center;
  padding: var(--space-sm);
}

.reactions-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
  max-height: 200px;
  overflow-y: auto;
  /* Custom Scrollbar */
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
}
.reactions-list::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
.reactions-list::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}
.reactions-list::-webkit-scrollbar-thumb {
  background-color: var(--color-primary-a30);
  border-radius: 3px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}
.reactions-list::-webkit-scrollbar-thumb:hover {
  background-color: var(--color-primary-a50);
}

.reaction-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--space-sm);
  transition: all var(--transition-fast);
}

.reaction-item:hover {
  background: var(--color-primary-a15);
}

.reaction-details {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  flex-grow: 1;
  overflow: hidden;
}

.reaction-event {
  color: var(--color-primary);
  font-size: var(--font-size-sm);
  font-weight: bold;
  white-space: nowrap;
}

.reaction-effect-type {
  color: var(--color-primary-a70);
  font-size: var(--font-size-xs);
  white-space: nowrap;
}

.color-pill {
  display: inline-block;
  min-width: 12px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  vertical-align: middle;
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
  flex-shrink: 0;
}

.form-actions {
  display: flex;
  justify-content: space-between;
  gap: var(--space-md);
  margin-top: var(--space-lg);
}

.btn-preview,
.btn-save-reaction {
  flex-grow: 1;
  font-size: var(--font-size-sm);
}

.save-hint,
.read-only-hint {
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  text-align: center;
  margin-top: var(--space-md);
  padding: var(--space-xs);
  background-color: var(--color-primary-a05);
  border-radius: var(--radius-sm);
}

.status-message {
  padding: var(--space-xs);
  margin-top: var(--space-sm);
  border-radius: var(--radius-sm);
  text-align: center;
  font-size: var(--font-size-xs);
}

.preview-status {
  color: var(--color-info-a90, lightblue);
}

.save-status.error {
  color: var(--color-error-a90);
  background-color: var(--color-error-a10);
}

.save-status.success {
  color: var(--color-success-a90);
  background-color: var(--color-success-a10);
}
```

---
### `src\components\Panels\PanelStyles\InfoOverlay.css`
```css
@import "../../../styles/variables.css";

.overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: var(--z-overlay); background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(var(--blur-amount)); -webkit-backdrop-filter: blur(var(--blur-amount)); display: flex; justify-content: center; align-items: center; transition: background-color var(--transition-slow), backdrop-filter var(--transition-slow);
}

.overlay-content {
  width: 90%; max-width: 900px; height: 85vh; background: var(--color-glass-bg-dark); border: 1px solid var(--color-border); border-radius: var(--radius-xl); overflow: hidden; position: relative; box-shadow: var(--shadow-primary-lg); transition: transform var(--transition-slow), opacity var(--transition-slow); display: flex; flex-direction: column;
}

.overlay-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-md) var(--space-lg);
  border-bottom: 1px solid var(--color-border);
  z-index: 10;
  flex-shrink: 0;
}

.overlay-title {
  margin: 0;
  line-height: 1;
  display: flex;
  align-items: center;
}

.radar-logo-image {
  display: block;
  height: 60px;
  width: auto;
  position: relative;
  left: 10px;
  opacity: 0.55;
}

.close-button {
  background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xl); cursor: pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: all var(--transition-fast); padding: 0; margin: 0; flex-shrink: 0;
}
.close-button:hover { opacity: 0.8; transform: scale(1.1); }

.overlay-body {
  flex: 1; display: flex; flex-direction: column; overflow: hidden; padding: 0; align-items: stretch; min-height: 0; width: 100%;
}

/* Tab Navigation specific to Info Overlay */
.info-overlay-tab-navigation {
  display: flex;
  flex-wrap: nowrap;
  justify-content: flex-start;
  padding: var(--space-md) 0;
  border-top: 1px solid var(--color-border);
  border-bottom: 1px solid var(--color-border);
  overflow-x: auto;
  overflow-y: hidden;
  flex-shrink: 0;
  align-items: center;
  min-width: 0;
  box-sizing: border-box;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none;  /* IE and Edge */
}
.info-overlay-tab-navigation::-webkit-scrollbar {
  display: none; /* Safari and Chrome */
  height: 0;
  width: 0;
}
.info-overlay-tab-navigation {
  mask-image: linear-gradient(to right, transparent 0%, black var(--space-lg), black calc(100% - var(--space-lg)), transparent 100%);
  -webkit-mask-image: linear-gradient(to right, transparent 0%, black var(--space-lg), black calc(100% - var(--space-lg)), transparent 100%);
}

/* Tab Button specific to Info Overlay */
.info-overlay-tab-button {
  background: transparent;
  border: 1px solid transparent;
  color: var(--color-text-muted);
  border-radius: var(--radius-sm);
  padding: 6px 8px;
  margin: 0 2px;
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
  white-space: nowrap;
  font-weight: 500;
  flex-shrink: 0;
  line-height: 1.2;
}
.info-overlay-tab-button:first-child {
    margin-left: var(--space-lg);
}
.info-overlay-tab-button:last-child {
    margin-right: var(--space-lg);
}
.info-overlay-tab-button:hover {
  background: var(--color-primary-a05);
  color: var(--color-primary-a90);
  border-color: var(--color-primary-a15);
}
.info-overlay-tab-button.active {
  background: var(--color-primary-a15);
  color: var(--color-primary);
  border-color: var(--color-primary-a30);
  box-shadow: var(--shadow-primary-sm);
}

.tab-content {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-lg) var(--space-lg);
  padding-right: calc(var(--space-lg) - 8px); /* Adjust for scrollbar */
  min-height: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
  /* --- ADDED: Prevent scroll chaining from info overlay content --- */
  overscroll-behavior: contain;
  /* -------------------------------------------------------------- */
}
.tab-content::-webkit-scrollbar { width: 8px; height: 8px; }
.tab-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; }
.tab-content::-webkit-scrollbar-thumb { background: var(--color-primary-a30); border-radius: 4px; }
.tab-content::-webkit-scrollbar-thumb:hover { background: var(--color-primary-a50); }

.tab-pane { padding-bottom: var(--space-lg); }
.tab-pane h3 { color: var(--color-primary); font-size: var(--font-size-lg); margin-top: 0; border-bottom: 1px solid var(--color-border); padding-bottom: var(--space-sm); margin-bottom: var(--space-lg); font-weight: 600; }
.tab-pane h4 { color: var(--color-primary-a90); font-size: 1.1em; margin-top: var(--space-lg); border-bottom: 1px solid var(--color-border); padding-bottom: var(--space-xs); margin-bottom: var(--space-md); font-weight: 600; }
.tab-pane p { color: var(--color-text); line-height: 1.7; margin-bottom: var(--space-md); font-size: 12px; }
.tab-pane ul { list-style: none; padding-left: 0; margin-bottom: var(--space-md); }
.tab-pane li { margin-bottom: var(--space-sm); line-height: 1.6; color: var(--color-text); position: relative; padding-left: var(--space-md); font-size: 12px; }
.tab-pane li::before { content: '◆'; position: absolute; left: 0; top: 1px; color: var(--color-primary-a50); font-size: 0.8em; }
.tab-pane strong { color: var(--color-primary-a90); font-weight: 600; }
.tab-pane code { background-color: var(--color-primary-a05); color: var(--color-primary-a90); padding: 2px 4px; border-radius: var(--radius-sm); font-family: monospace; font-size: 0.9em; }
.info-card { background: var(--color-primary-a05); border: 1px solid var(--color-primary-a15); border-radius: var(--radius-md); padding: var(--space-md); margin-top: var(--space-lg); margin-bottom: var(--space-lg); }
.info-card h4 { color: var(--color-primary); margin-top: 0; margin-bottom: var(--space-sm); font-size: var(--font-size-md); border-bottom: none; padding-bottom: 0; font-weight: 600; }
.info-card p, .info-card li { font-size: 12px; color: var(--color-text); margin-bottom: var(--space-sm); }
.info-card p:last-child, .info-card ul:last-child { margin-bottom: 0; }
.info-card ul { margin-top: var(--space-sm); }
.info-card li::before { content: '—'; left: 2px; color: var(--color-primary-a70); }

.overlay {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
}

.overlay.fadeToContent {
  opacity: 1;
  visibility: visible;
  transition: opacity 0.3s ease-in, visibility 0s linear 0s;
}

.overlay.exiting {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease-out, visibility 0s linear 0.3s;
}

.overlay-content {
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
}

.overlay.exiting .overlay-content {
  transform: scale(0.98);
  opacity: 0;
  transition: transform 0.3s ease-out, opacity 0.3s ease-out;
}
```

---
### `src\components\Panels\PanelStyles\NotificationPanel.css`
```css
.notification-empty {
  text-align: center;
  padding: 15px 0;
  color: var(--color-primary-a50);
  font-style: italic;
  font-size: var(--font-size-sm);
}

.panel-header-actions {
  margin-bottom: var(--space-md);
  display: flex;
  justify-content: flex-end;
}

.btn-clear-all {
  background: var(--color-error-a10);
  color: var(--color-error-a90);
  border-color: var(--color-error-a30);
}
.btn-clear-all:hover:not(:disabled) {
  background: var(--color-error-a30);
  color: var(--color-text);
}

.notification-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
}

.notification-item {
  padding: var(--space-sm);
  background: var(--color-primary-a05);
  border-radius: var(--radius-md);
  border-left: 3px solid var(--color-primary-a30);
  transition: all var(--transition-fast);
  cursor: pointer;
}

.notification-item:hover {
  background: var(--color-primary-a15);
  transform: translateY(-2px);
}

.notification-item.new {
  border-left-color: var(--color-error, #ff5555);
  background: var(--color-error-a05, rgba(255, 85, 85, 0.05));
  animation: highlight-new 2s ease-out;
}

.notification-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-xs);
}

.notification-timestamp {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
}

.notification-type-tag {
  font-size: var(--font-size-xs);
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  text-transform: uppercase;
  font-weight: bold;
}

.notification-type-tag.lyx {
  background: var(--color-lyx-a20);
  color: var(--color-lyx);
}

.notification-type-tag.token {
  background: var(--color-token-a20);
  color: var(--color-token);
}

.notification-type-tag.contract {
  background: var(--color-contract-a20);
  color: var(--color-contract);
}

.notification-type-tag.social {
  background: rgba(138, 43, 226, 0.2); /* Example: Purple */
  color: #9370db; /* Example: Medium Purple */
}

.notification-content {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.notification-message {
  font-size: var(--font-size-sm);
  flex: 1;
  color: var(--color-text);
  line-height: 1.4;
}
```

---
### `src\components\Panels\PanelStyles\PanelStyles.css`
```css
@import "../../../styles/variables.css";

.panel {
  border: 1px solid rgba(0, 243, 255, 0.25);
  border-radius: var(--radius-md);
  color: var(--color-text);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  overflow: hidden;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  background: rgba(0, 10, 20, 0.8);
  border-top: 1px solid rgba(0, 243, 255, 0.25) !important;
  transition: none !important;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  background: rgba(0, 243, 255, 0.05);
  border-bottom: 1px solid rgba(0, 243, 255, 0.15);
  border-top: none !important;
  box-shadow: none !important;
  position: relative;
}

.panel-header:before,
.panel-header:after {
  display: none !important;
}

.panel-title {
  margin: 0;
  font-size: var(--font-size-md);
  font-weight: 600;
  color: var(--color-primary);
  letter-spacing: 0.8px;
  text-transform: uppercase;
}

.close-button {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: none;
  background: transparent;
  color: var(--color-primary);
  cursor: pointer;
  font-size: 16px;
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
  padding: 0;
}

.close-button:hover {
  background: rgba(0, 243, 255, 0.1);
}

.panel-content {
  padding: 15px;
  overflow-y: auto;
  flex: 1;
  /* --- ADDED: Prevent scroll chaining from panel content --- */
  overscroll-behavior: contain;
  /* --------------------------------------------------------- */
}
```

---
### `src\components\Panels\PanelStyles\TokenSelectorOverlay.css`
```css
@import "../../../styles/variables.css";

.logo-transition-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: calc(var(--z-overlay) + 5); /* Above main overlay backdrop */
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

.logo-transition-container.visible {
  opacity: 1;
  visibility: visible;
  transition:
    opacity 400ms ease-in-out,
    visibility 0s linear 0s;
}

.logo-transition-container .logo-animation {
  max-width: 150px;
  opacity: 0.8;
  animation: pulse 2s infinite ease-in-out;
}

.overlay.token-selector-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-overlay); /* Below logo container */
  background-color: rgba(0, 0, 0, 0);
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transform: translateZ(0);
  transition:
    opacity 300ms ease-out,
    background-color 300ms ease-out,
    visibility 0s linear 300ms;
}

.overlay.token-selector-overlay.visible {
  opacity: 1;
  visibility: visible;
  transition:
    opacity 300ms ease-out,
    background-color 300ms ease-out,
    visibility 0s linear 0s; /* Show immediately */
}

.overlay.token-selector-overlay.state-logo {
  background-color: rgba(0, 0, 0, 0);
  backdrop-filter: blur(0px);
  -webkit-backdrop-filter: blur(0px);
  pointer-events: none;
}

.overlay.token-selector-overlay.state-content {
  background-color: rgba(0, 0, 0, 0.8);
  will-change: opacity, background-color;
  pointer-events: auto;
  transition:
    opacity 300ms ease-out,
    background-color 300ms ease-out,
    visibility 0s linear 0s;
}

.overlay.token-selector-overlay.state-exiting {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  background-color: rgba(0, 0, 0, 0);
  backdrop-filter: blur(0px);
  -webkit-backdrop-filter: blur(0px);
  transition:
    opacity 300ms ease-out,
    background-color 300ms ease-out,
    backdrop-filter 300ms ease-out,
    -webkit-backdrop-filter 300ms ease-out,
    visibility 0s linear 300ms;
}

.overlay.token-selector-overlay .overlay-content {
  width: 90%;
  max-width: 900px;
  height: 80vh;
  background: var(--color-glass-bg-dark);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-xl);
  overflow: hidden;
  position: relative;
  box-shadow: var(--shadow-primary-lg);
  display: flex;
  flex-direction: column;
  opacity: 0;
  transform: scale(0.95);
  transform-origin: center center;
  will-change: transform, opacity;
  transition:
    opacity 300ms ease-out,
    transform 300ms ease-out;
}

.overlay.token-selector-overlay.state-logo .overlay-content {
  opacity: 0;
  transform: scale(0.95);
  transition: none;
}

.overlay.token-selector-overlay.state-content .overlay-content {
  opacity: 1;
  transform: scale(1);
  transition-delay: 100ms; /* Delay content appearance slightly after background */
  transition:
    opacity 300ms ease-out 100ms,
    transform 300ms ease-out 100ms;
}

.overlay.token-selector-overlay.state-exiting .overlay-content {
  opacity: 0;
  transform: scale(0.95);
  transition:
    opacity 300ms ease-out,
    transform 300ms ease-out;
}

.overlay.token-selector-overlay.preview-mode {
  background-color: transparent !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  pointer-events: none !important;
  opacity: 0 !important;
  transition: opacity 300ms ease !important;
}

.overlay.token-selector-overlay.preview-mode .overlay-content {
  opacity: 0 !important;
  pointer-events: none !important;
  transition: opacity 300ms ease !important;
  background: transparent !important;
}

.token-selector-overlay .overlay-body {
  padding: 0;
  display: flex;
  flex-direction: column;
  height: calc(100% - 50px);
  overflow: hidden;
  position: relative;
}

.token-selector-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 var(--space-md);
  border-bottom: 1px solid var(--color-border);
  flex-shrink: 0;
  background: rgba(var(--color-bg-rgb, 16, 16, 24), 0.7);
  backdrop-filter: blur(var(--blur-amount, 10px));
  -webkit-backdrop-filter: blur(var(--blur-amount, 10px));
  height: 50px;
  position: relative;
  z-index: 20;
  overflow: hidden;
}

.header-center-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-grow: 1;
  padding: 0 var(--space-lg);
}

.token-selector-header .layer-buttons {
  display: flex;
  gap: var(--space-xs);
  margin: 0;
  margin-bottom: 3px;
}

.token-selector-header .layer-button {
  width: 34px;
  height: 34px;
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.token-selector-header .layer-button:hover {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a30);
}

.token-selector-header .layer-button.active {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-sm);
}

.token-selector-header .layer-button-icon {
  width: 20px;
  height: 20px;
  opacity: 0.8;
}

.token-selector-header .layer-button:hover .layer-button-icon,
.token-selector-header .layer-button.active .layer-button-icon {
  opacity: 1;
  filter: drop-shadow(0 0 3px var(--color-primary-a30));
}

.token-selector-header .close-button {
  flex-shrink: 0;
  width: 30px;
  height: 30px;
  font-size: 18px;
  color: var(--color-primary-a70);
  border-radius: var(--radius-sm);
  background: none;
  border: none;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.token-selector-header .close-button:hover {
  background: var(--color-primary-a15);
  color: var(--color-primary);
  transform: none;
}

.status-message {
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  z-index: calc(var(--z-overlay) + 1);
  width: auto;
  max-width: 60%;
  padding: 6px 12px;
  border-radius: var(--radius-lg);
  text-align: center;
  font-size: var(--font-size-xs);
  font-weight: 500;
  background-color: var(--color-info-a10, rgba(0, 180, 255, 0.1));
  border: 1px solid var(--color-info-a30, rgba(0, 180, 255, 0.3));
  color: var(--color-info-a90, #a0e0ff);
  transition: opacity 300ms ease, visibility 300ms ease;
  opacity: 1;
  visibility: visible;
  pointer-events: none;
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
}

.status-message.success {
  background-color: var(--color-success-a10);
  border-color: var(--color-success-a30);
  color: var(--color-success-a90);
}

.status-message.error {
  background-color: var(--color-error-a10);
  border-color: var(--color-error-a30);
  color: var(--color-error-a90);
}

.status-message.warning {
  background-color: var(--color-warning-a10);
  border-color: var(--color-warning-a30);
  color: var(--color-warning-a90);
}

.status-message.hidden {
  opacity: 0;
  visibility: hidden;
}

.token-display-area {
  flex-grow: 1;
  overflow-y: auto;
  padding: var(--space-md);
  scrollbar-width: thin;
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1);
}

.token-display-area::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.token-display-area::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
}

.token-display-area::-webkit-scrollbar-thumb {
  background: var(--color-primary-a30);
  border-radius: 3px;
}

.token-display-area::-webkit-scrollbar-thumb:hover {
  background: var(--color-primary-a50);
}

.tokens-grid {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  justify-content: center;
}

.token-item {
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--space-xs);
  cursor: pointer;
  transition: all var(--transition-normal);
  text-align: center;
  width: 90px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  user-select: none;
  -webkit-user-select: none;
}

.token-item:hover {
  border-color: var(--color-primary-a50);
  background: var(--color-primary-a15);
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
}

.token-item.selected {
  border-color: var(--color-primary);
  background: var(--color-primary-a30);
  box-shadow: var(--shadow-primary-md);
}

.token-item.read-only {
  cursor: default; /* Not not-allowed, as demo tokens are still usable */
  opacity: 0.8; /* Slightly dim if it's read-only for non-demo */
}
.token-item.read-only:hover {
  /* Keep hover for demo tokens, or remove if all interaction should cease */
  /* For now, let demo token hover effects persist */
}

.token-image-container {
  width: 100%;
  height: 0;
  padding-bottom: 100%;
  position: relative;
  margin-bottom: var(--space-xs);
  overflow: hidden;
  border-radius: var(--radius-sm);
  background-color: rgba(0, 0, 0, 0.3);
}

.token-image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform var(--transition-normal);
  pointer-events: none;
}

.token-item:hover .token-image {
  transform: scale(1.05);
}
.token-item.read-only:hover .token-image {
  /* Allow image scale on hover even if read-only for demo tokens */
  /* transform: none; */ 
}

.token-name {
  display: none;
}

.loading-message {
  text-align: center;
  padding: var(--space-lg);
  color: var(--color-text-muted);
  font-style: italic;
}

.visitor-banner {
  text-align: center; 
  padding: var(--space-sm) var(--space-md); 
  margin: var(--space-md); 
  border-radius: var(--radius-md); 
  background: var(--color-warning-a10); 
  border: 1px solid var(--color-warning-a30);
  color: var(--color-warning-a90);
  font-size: var(--font-size-sm); 
  font-weight: 500; 
  flex-shrink: 0; 
  box-shadow: var(--shadow-sm); 
}

/* New style for token preview instruction */
.token-preview-instruction {
  text-align: center;
  padding: var(--space-xs) var(--space-md);
  margin: var(--space-xs) var(--space-md) var(--space-sm); /* Adjusted margin */
  font-size: var(--font-size-sm);
  color: var(--color-text-muted);
  background-color: var(--color-primary-a05);
  border: 1px solid var(--color-primary-a15);
  border-radius: var(--radius-sm);
}


@keyframes pulse {
  0% { opacity: 0.7; }
  50% { opacity: 1; }
  100% { opacity: 0.7; }
}
```

---
### `src\components\Panels\PanelStyles\WhitelistCollectionsPanel.css`
```css
.whitelist-panel-content {
  display: flex;
  flex-direction: column;
  gap: var(--space-lg);
}

.admin-header {
  background: var(--color-success-a10);
  border: 1px solid var(--color-success-a30);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  margin-bottom: var(--space-md);
}

.admin-badge {
  display: inline-block;
  background: var(--color-success-a30);
  color: var(--color-success-a90);
  font-size: var(--font-size-xs);
  font-weight: bold;
  padding: 2px 6px;
  border-radius: var(--radius-sm);
  margin-bottom: var(--space-xs);
}

.admin-description {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  margin: 0;
}

.section-title {
  color: var(--color-primary);
  font-size: var(--font-size-lg);
  margin-bottom: var(--space-md);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--space-xs);
}

.loading-message {
  text-align: center;
  padding: var(--space-md);
  color: var(--color-text-muted);
}

.empty-message {
  text-align: center;
  padding: var(--space-md);
  color: var(--color-text-muted);
  font-style: italic;
}

.error-message {
  background: var(--color-error-a10);
  border: 1px solid var(--color-error-a30);
  color: var(--color-error-a90);
  padding: var(--space-sm);
  border-radius: var(--radius-sm);
  margin-bottom: var(--space-md);
}

.success-message {
  background: var(--color-success-a10);
  border: 1px solid var(--color-success-a30);
  color: var(--color-success-a90);
  padding: var(--space-sm);
  border-radius: var(--radius-sm);
  margin-bottom: var(--space-md);
}

.collections-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: var(--space-md);
  margin-bottom: var(--space-lg);
}

.collection-card {
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  overflow: hidden;
  transition: all var(--transition-fast);
  position: relative;
}

.collection-card:hover {
  background: var(--color-primary-a15);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}

.collection-image {
  width: 100%;
  height: 120px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--color-bg);
}

.collection-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.collection-info {
  padding: var(--space-sm);
}

.collection-name {
  font-size: var(--font-size-md);
  color: var(--color-primary);
  margin: 0 0 var(--space-xs) 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.collection-address {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  font-family: monospace;
  margin-bottom: var(--space-xs);
}

.collection-description {
  font-size: var(--font-size-xs);
  color: var(--color-text-muted);
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.remove-button {
  position: absolute;
  top: 5px;
  right: 5px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--color-error-a50);
  color: var(--color-error-a90);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  cursor: pointer;
  transition: all var(--transition-fast);
  z-index: 5;
}

.remove-button:hover {
  background: var(--color-error-a30);
  transform: scale(1.1);
}

.form-control {
  width: 100%;
  padding: var(--space-xs) var(--space-sm);
  background: var(--color-glass-bg);
  border: 1px solid var(--color-border);
  color: var(--color-text);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-sm);
  transition: border-color var(--transition-fast);
}

.form-control:focus {
  outline: none;
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-sm);
}

textarea.form-control {
  resize: vertical;
  min-height: 80px;
}

```

---
### `src\components\Panels\PanelWrapper.jsx`
```jsx
// src/components/Panels/PanelWrapper.jsx
import React from "react";
import PropTypes from "prop-types";

/**
 * @typedef {object} PanelWrapperProps
 * @property {string} [className=""] - Optional additional CSS class names to apply to the wrapper div.
 * @property {React.ReactNode} children - The panel content (typically a `Panel` component) to be rendered within this wrapper.
 * @property {React.CSSProperties} [style] - Optional inline styles to apply to the wrapper div.
 */

/**
 * PanelWrapper: A component designed to wrap individual panels (like `EnhancedControlPanel`, `NotificationPanel`).
 * It handles the positioning of the panel on the screen and applies slide-in/slide-out animations
 * using CSS keyframes defined via styled-jsx.
 *
 * The animation durations have been modified as per the original comments.
 *
 * @param {PanelWrapperProps} props - The component's props.
 * @returns {JSX.Element} The rendered PanelWrapper component.
 */
const PanelWrapper = ({ className = "", children, style }) => {
  return (
    <div className={`panel-wrapper ${className}`} style={style}>
      {children}

      <style jsx>{`
        .panel-wrapper {
          position: fixed;
          top: 5px;
          left: -20px; /* Initial position slightly off-screen for slide-in */
          z-index: 1000;
          max-height: 90vh;
          /* MODIFIED: Changed animation duration from 0.3s to 0.5s */
          animation: panel-slide-in 0.5s ease-out forwards;
          overflow: visible; /* Allow shadows/effects outside bounds */
          border: none !important;
          outline: none !important;
        }

        .panel-wrapper.panel-from-toolbar {
          /* Styles for panels originating from toolbar, if any, would go here */
        }

        @keyframes panel-slide-in {
          from {
            opacity: 0;
            transform: translateX(-150px); /* Initial off-screen position */
          }
          to {
            opacity: 1;
            transform: translateX(0);
          }
        }

        .panel-wrapper.animating.closing {
          /* MODIFIED: Changed animation duration from 0.3s to 0.5s */
          animation: panel-slide-out 0.5s ease-in forwards;
        }

        @keyframes panel-slide-out {
          from {
            opacity: 1;
            transform: translateX(0);
          }
          to {
            opacity: 0;
            transform: translateX(-150px); /* MODIFIED: Match slide-in 'from' transform */
          }
        }
      `}</style>
    </div>
  );
};

PanelWrapper.propTypes = {
  /** Optional additional CSS class names for the wrapper. */
  className: PropTypes.string,
  /** The panel content to be rendered within this wrapper. */
  children: PropTypes.node.isRequired,
  /** Optional inline styles for the wrapper. */
  style: PropTypes.object,
};

export default PanelWrapper;
```

---
### `src\components\Panels\TokenSelectorOverlay.jsx`
```jsx
// src/components/Panels/TokenSelectorOverlay.jsx
import React, { useState, useEffect, useMemo, useCallback, useRef } from "react";
import PropTypes from "prop-types";
import {
    toplayerIcon,
    middlelayerIcon,
    bottomlayerIcon,
} from "../../assets";
import { demoAssetMap } from "../../assets/DemoLayers/initLayers";
import { manageOverlayDimmingEffect } from "../../utils/performanceHelpers";
import { globalAnimationFlags } from "../../utils/globalAnimationFlags";
import "./PanelStyles/TokenSelectorOverlay.css";

const OPEN_CLOSE_ANIMATION_DURATION = 300;
const CONTENT_VISIBILITY_DELAY = 50;
const INITIAL_OPERATIONS_DELAY = 16;
const IMAGE_PRELOAD_DELAY_AFTER_CONTENT_VISIBLE = 200;
const IMAGE_PRELOAD_BATCH_SIZE = 40; // Load images in batches of 40
const IMAGE_PRELOAD_BATCH_DELAY = 50; // Small delay between batches (ms)

const TokenSelectorOverlay = ({ isOpen, onClose, onTokenApplied, readOnly = false }) => {
  const [internalIsOpen, setInternalIsOpen] = useState(false);
  const [isLoadingImages, setIsLoadingImages] = useState(false);
  const [triggerImagePreload, setTriggerImagePreload] = useState(false);
  const [demoTokens, setDemoTokens] = useState([]);
  const [selectedLayer, setSelectedLayer] = useState(3);
  const [selectedTokens, setSelectedTokens] = useState({ 1: null, 2: null, 3: null });
  const [animationState, setAnimationState] = useState("hidden");
  const [displayMessage, setDisplayMessage] = useState({ text: null, type: 'info' });
  const [areImagesPreloaded, setAreImagesPreloaded] = useState(false);
  const [isPreviewingCanvas, setIsPreviewingCanvas] = useState(false);
  const [loadedImageCount, setLoadedImageCount] = useState(0); // For progress

  const statusMessageTimerRef = useRef(null);
  const overlayRef = useRef(null);
  const contentDelayTimerRef = useRef(null);
  const operationsDelayTimerRef = useRef(null);
  const isMountedRef = useRef(false);
  const cancelDimmingEffectRef = useRef(null);
  const imagePreloadTimerRef = useRef(null);
  const batchLoadAbortControllerRef = useRef(null); // To abort batch loading

  useEffect(() => {
      isMountedRef.current = true;
      return () => {
          isMountedRef.current = false;
          if (statusMessageTimerRef.current) clearTimeout(statusMessageTimerRef.current);
          if (contentDelayTimerRef.current) clearTimeout(contentDelayTimerRef.current);
          if (operationsDelayTimerRef.current) clearTimeout(operationsDelayTimerRef.current);
          if (cancelDimmingEffectRef.current) cancelDimmingEffectRef.current();
          if (imagePreloadTimerRef.current) clearTimeout(imagePreloadTimerRef.current);
          if (batchLoadAbortControllerRef.current) batchLoadAbortControllerRef.current.abort();
          globalAnimationFlags.isTokenSelectorOpening = false;
      };
  }, []);

  useEffect(() => {
    if (isOpen) {
        globalAnimationFlags.isTokenSelectorOpening = true;
        setAreImagesPreloaded(false);
        setTriggerImagePreload(false);
        setIsLoadingImages(false);
        setLoadedImageCount(0); // Reset loaded count
        if (batchLoadAbortControllerRef.current) batchLoadAbortControllerRef.current.abort(); // Abort previous loading

        if (operationsDelayTimerRef.current) clearTimeout(operationsDelayTimerRef.current);
        operationsDelayTimerRef.current = setTimeout(() => {
            if (isMountedRef.current && isOpen) {
                setInternalIsOpen(true);
            } else if (isMountedRef.current && !isOpen) {
                globalAnimationFlags.isTokenSelectorOpening = false;
            }
        }, INITIAL_OPERATIONS_DELAY);
    } else {
        globalAnimationFlags.isTokenSelectorOpening = false;
        setInternalIsOpen(false);
        if (operationsDelayTimerRef.current) clearTimeout(operationsDelayTimerRef.current);
        setAnimationState("hidden");
        setAreImagesPreloaded(false);
        setIsLoadingImages(false);
        setTriggerImagePreload(false);
        setLoadedImageCount(0);
        if (imagePreloadTimerRef.current) clearTimeout(imagePreloadTimerRef.current);
        if (batchLoadAbortControllerRef.current) batchLoadAbortControllerRef.current.abort();
    }
    return () => {
        if (operationsDelayTimerRef.current) clearTimeout(operationsDelayTimerRef.current);
        if (isOpen && !isMountedRef.current) {
             globalAnimationFlags.isTokenSelectorOpening = false;
        }
    };
  }, [isOpen]);

  useEffect(() => {
      const structuredDemoTokens = Object.entries(demoAssetMap).map(([key, src]) => ({
          id: key,
          displayId: key,
          type: 'demo',
          metadata: { name: `Demo ${key.replace("DEMO_LAYER_", "Asset ")}`, image: src }
      }));
      setDemoTokens(structuredDemoTokens);
  }, []);

  useEffect(() => {
    if (animationState === "content" && internalIsOpen && !triggerImagePreload && !areImagesPreloaded) {
        if (imagePreloadTimerRef.current) clearTimeout(imagePreloadTimerRef.current);
        setIsLoadingImages(true);
        imagePreloadTimerRef.current = setTimeout(() => {
            if (isMountedRef.current && internalIsOpen && animationState === "content") {
                setTriggerImagePreload(true);
            }
        }, IMAGE_PRELOAD_DELAY_AFTER_CONTENT_VISIBLE);
    }
    return () => {
        if (imagePreloadTimerRef.current) clearTimeout(imagePreloadTimerRef.current);
    };
  }, [animationState, internalIsOpen, triggerImagePreload, areImagesPreloaded]);


  useEffect(() => {
      if (triggerImagePreload && demoTokens.length > 0 && !areImagesPreloaded) {
          batchLoadAbortControllerRef.current = new AbortController();
          const signal = batchLoadAbortControllerRef.current.signal;

          const loadBatch = async (startIndex) => {
              if (signal.aborted || !isMountedRef.current) return;

              const batch = demoTokens.slice(startIndex, startIndex + IMAGE_PRELOAD_BATCH_SIZE);
              if (batch.length === 0) {
                  if (isMountedRef.current) {
                      setAreImagesPreloaded(true);
                      setIsLoadingImages(false);
                  }
                  return;
              }

              const promises = batch.map(token => {
                  if (signal.aborted) return Promise.reject(new Error("Aborted"));
                  const imgSrc = token.metadata?.image;
                  if (typeof imgSrc !== 'string' || !imgSrc) return Promise.resolve({ status: 'fulfilled' });
                  return new Promise((resolve) => {
                      const img = new Image();
                      const timeoutId = setTimeout(() => resolve({ status: 'rejected', reason: `Timeout for ${imgSrc}` }), 5000); // 5s timeout per image
                      img.onload = () => { clearTimeout(timeoutId); resolve({ status: 'fulfilled', value: imgSrc }); };
                      img.onerror = () => { clearTimeout(timeoutId); resolve({ status: 'rejected', reason: `Failed for ${imgSrc}` }); };
                      if (signal.aborted) { clearTimeout(timeoutId); resolve({ status: 'rejected', reason: 'Aborted before src set' }); return; }
                      img.src = imgSrc;
                  });
              });

              await Promise.allSettled(promises);
              if (signal.aborted || !isMountedRef.current) return;

              setLoadedImageCount(prev => prev + batch.length);

              if (startIndex + IMAGE_PRELOAD_BATCH_SIZE < demoTokens.length) {
                  setTimeout(() => loadBatch(startIndex + IMAGE_PRELOAD_BATCH_SIZE), IMAGE_PRELOAD_BATCH_DELAY);
              } else {
                  if (isMountedRef.current) {
                      setAreImagesPreloaded(true);
                      setIsLoadingImages(false);
                  }
              }
          };

          loadBatch(0);

          return () => {
              if (batchLoadAbortControllerRef.current) {
                  batchLoadAbortControllerRef.current.abort();
              }
          };
      }
  }, [triggerImagePreload, demoTokens, areImagesPreloaded]);


  useEffect(() => {
    if (contentDelayTimerRef.current) clearTimeout(contentDelayTimerRef.current);
    contentDelayTimerRef.current = null;

    if (internalIsOpen) {
        if (animationState === 'hidden' || animationState === 'exiting') {
            setAnimationState("hidden");
            if (cancelDimmingEffectRef.current) cancelDimmingEffectRef.current();
            cancelDimmingEffectRef.current = manageOverlayDimmingEffect(
                OPEN_CLOSE_ANIMATION_DURATION + CONTENT_VISIBILITY_DELAY + 50,
                { selector: '.main-view' }
            );
            contentDelayTimerRef.current = setTimeout(() => {
                if (internalIsOpen && isMountedRef.current) {
                    setAnimationState("content");
                }
            }, CONTENT_VISIBILITY_DELAY);
        }
    } else { 
        if (animationState !== 'hidden' && animationState !== 'exiting') {
             if (cancelDimmingEffectRef.current) cancelDimmingEffectRef.current();
             cancelDimmingEffectRef.current = manageOverlayDimmingEffect(OPEN_CLOSE_ANIMATION_DURATION + 50, { selector: '.main-view' });
             setAnimationState('exiting');
        }
        setIsPreviewingCanvas(false);
    }
    return () => {
        if (contentDelayTimerRef.current) clearTimeout(contentDelayTimerRef.current);
    };
  }, [internalIsOpen, animationState]);

  const showStatusMessage = useCallback((text, type = 'info', duration = 3000) => {
      setDisplayMessage({ text, type });
      if (statusMessageTimerRef.current) { clearTimeout(statusMessageTimerRef.current); }
      if (duration > 0 && text !== null) {
          statusMessageTimerRef.current = setTimeout(() => {
              if (isMountedRef.current) setDisplayMessage({ text: null, type: 'info' });
          }, duration);
      } else if (text === null) {
          setDisplayMessage({ text: null, type: 'info' });
      }
  }, []);

  const handleClose = useCallback(() => {
    globalAnimationFlags.isTokenSelectorOpening = false;
    if (batchLoadAbortControllerRef.current) batchLoadAbortControllerRef.current.abort();
    onClose();
  }, [onClose]);
  
  const handleBackgroundClick = useCallback((e) => {
      if (isPreviewingCanvas) return;
      if (overlayRef.current && e.target === overlayRef.current) {
          handleClose();
      }
  }, [isPreviewingCanvas, handleClose]);

  const handleTokenPointerDown = useCallback((e) => {
      try {
          e.stopPropagation();
          e.currentTarget.setPointerCapture(e.pointerId);
          if (!isPreviewingCanvas && areImagesPreloaded) {
              const tokenIdentifierForKey = e.currentTarget.dataset.tokenIdKey;
              const tokenName = e.currentTarget.dataset.tokenName;
              const tokenImageSrc = e.currentTarget.dataset.tokenIdValue;
              setSelectedTokens((prev) => ({ ...prev, [selectedLayer]: tokenImageSrc, }));
              const layerName = selectedLayer === 3 ? "top" : selectedLayer === 2 ? "middle" : "bottom";
              showStatusMessage(`Applied ${tokenName || 'token'} to ${layerName} layer`, "success");
              if (onTokenApplied) {
                  onTokenApplied(tokenIdentifierForKey, selectedLayer);
              }
          }
          setIsPreviewingCanvas(true);
      } catch (error) { console.error("[TokenSelector] Error in handleTokenPointerDown:", error); }
  }, [isPreviewingCanvas, selectedLayer, onTokenApplied, showStatusMessage, areImagesPreloaded]);

  const handleTokenPointerLeave = useCallback((e) => {
      try {
          e.stopPropagation();
          setIsPreviewingCanvas(false);
      } catch (error) { console.error("[TokenSelector] Error in handleTokenPointerLeave:", error); }
  }, []);

  const handleTokenPointerUp = useCallback((e) => {
      try {
          e.stopPropagation();
          e.currentTarget.releasePointerCapture(e.pointerId);
          setIsPreviewingCanvas(false);
      } catch (error) { console.error("[TokenSelector] Error in handleTokenPointerUp:", error); }
  }, []);

  const renderTokenItem = useCallback((token) => {
      const uniqueKey = token.id;
      const tokenImageSrc = token.metadata?.image ?? '';
      const isSelected = selectedTokens[selectedLayer] === tokenImageSrc;
      const iconSrc = tokenImageSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      const name = token.metadata?.name || 'Unnamed Token';

      if (!tokenImageSrc) return null;
      return (
        <div
            key={uniqueKey}
            className={`token-item ${isSelected ? "selected" : ""} ${readOnly ? "read-only" : ""}`}
            data-token-id-key={token.id}
            data-token-id-value={tokenImageSrc}
            data-token-name={name} data-token-type={token.type}
            onPointerDown={handleTokenPointerDown} onPointerUp={handleTokenPointerUp} onPointerLeave={handleTokenPointerLeave}
            title={readOnly ? `Viewing Mode - ${name} (Demo tokens usable)` : name}
        >
            <div className="token-image-container">
                <img src={iconSrc} alt={name} className="token-image" crossOrigin={iconSrc?.startsWith("http") ? "anonymous" : undefined} onError={(e) => { e.target.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; }} draggable="false" />
            </div>
            <div className="token-name">{name}</div>
        </div>
      );
  }, [selectedLayer, selectedTokens, readOnly, handleTokenPointerDown, handleTokenPointerUp, handleTokenPointerLeave]);

  const overlayClassName = useMemo(() => {
      let classes = 'overlay token-selector-overlay';
      if (internalIsOpen || animationState === 'exiting') {
          classes += ' visible';
      }
      classes += ` state-${animationState}`;
      if (isPreviewingCanvas) classes += ' preview-mode';
      return classes;
  }, [internalIsOpen, animationState, isPreviewingCanvas]);

  if (!isOpen && animationState === 'hidden') {
      return null;
  }

  let tokenDisplayContent;
  if (isLoadingImages && !areImagesPreloaded) {
    const progressPercent = demoTokens.length > 0 ? Math.round((loadedImageCount / demoTokens.length) * 100) : 0;
    tokenDisplayContent = <div className="loading-message">Preloading assets... ({progressPercent}%)</div>;
  } else if (areImagesPreloaded && demoTokens.length > 0) {
    tokenDisplayContent = (
      <div className="token-section demo-section">
        <div className="tokens-grid">{demoTokens.map(renderTokenItem)}</div>
      </div>
    );
  } else if (!isLoadingImages && demoTokens.length === 0) { // Case for no demo tokens at all
    tokenDisplayContent = <div className="status-message info">No demo tokens available.</div>;
  } else { // Fallback, or initial state before loading starts
    tokenDisplayContent = <div className="loading-message">Initializing...</div>;
  }


  return (
    <>
      <div className={`status-message ${displayMessage.type} ${!displayMessage.text ? 'hidden' : ''}`}>
          {displayMessage.text}
      </div>

      {(internalIsOpen || animationState === 'exiting') && (
          <div ref={overlayRef} className={overlayClassName} onClick={handleBackgroundClick}>
            <div className="overlay-content">
              <div className="overlay-header token-selector-header">
                  <div className="header-center-content">
                      <div className="layer-buttons">
                          <button className={`layer-button ${selectedLayer === 3 ? "active" : ""}`} onClick={() => setSelectedLayer(3)} title="Select Top Layer"> <img src={toplayerIcon} alt="L3" className="layer-button-icon" /> </button>
                          <button className={`layer-button ${selectedLayer === 2 ? "active" : ""}`} onClick={() => setSelectedLayer(2)} title="Select Middle Layer"> <img src={middlelayerIcon} alt="L2" className="layer-button-icon" /> </button>
                          <button className={`layer-button ${selectedLayer === 1 ? "active" : ""}`} onClick={() => setSelectedLayer(1)} title="Select Bottom Layer"> <img src={bottomlayerIcon} alt="L1" className="layer-button-icon" /> </button>
                      </div>
                  </div>
                  <button className="close-button" onClick={handleClose} aria-label="Close token selector">✕</button>
              </div>
              
              {(animationState === 'content' || animationState === 'exiting') && (
                  <div className="overlay-body">
                    {readOnly && ( <div className="visitor-banner"> You are viewing another profile... </div> )}
                    <div className="token-display-area">
                      {tokenDisplayContent}
                    </div>
                  </div>
              )}
            </div>
          </div>
      )}
    </>
  );
};

TokenSelectorOverlay.propTypes = {
  isOpen: PropTypes.bool.isRequired,
  onClose: PropTypes.func.isRequired,
  onTokenApplied: PropTypes.func.isRequired,
  readOnly: PropTypes.bool
};

export default TokenSelectorOverlay;
```

---
### `src\components\Panels\WhitelistCollectionsPanel.jsx`
```jsx
// src/components/Panels/WhitelistCollectionsPanel.jsx
import React, { useState, useEffect, useCallback, useRef } from "react";
import PropTypes from "prop-types";

import Panel from "./Panel"; // Local component
import { useUserSession } from "../../context/UserSessionContext"; // Local context
import { useConfig } from "../../context/ConfigContext"; // Local context

import { RADAR_WHITELIST_KEY } from "../../config/global-config"; // Local config

import { isAddress, stringToHex, hexToString } from "viem"; // Third-party utilities

import "./PanelStyles/WhitelistCollectionsPanel.css"; // Local styles

/**
 * Formats an Ethereum address for display by showing the beginning and end.
 * Returns "N/A" if the input is invalid.
 * @param {string | null | undefined} address - The address string.
 * @param {number} [length=4] - The number of characters to show from the start and end (excluding "0x" and "...").
 * @returns {string} The formatted address or "N/A".
 */
const formatAddress = (address, length = 4) => {
  if (!address || typeof address !== "string" || !address.startsWith("0x")) {
    return "N/A";
  }
  // Ensure length is reasonable for typical address display
  const displayLength = Math.max(2, Math.min(10, length));
  if (address.length <= displayLength * 2 + 2) return address; // Return full address if it's short
  return `${address.substring(0, displayLength + 2)}...${address.substring(address.length - displayLength)}`;
};

/**
 * @typedef {object} WhitelistCollection
 * @property {string} address - The collection contract address.
 * @property {string} name - The name of the collection.
 * @property {string} [description] - An optional description for the collection.
 * @property {string | null} [imageUrl] - An optional URL for the collection's image.
 * @property {string} id - A unique identifier for the collection, typically the address.
 * @property {number} [addedAt] - Timestamp when the collection was added.
 */

/**
 * @typedef {object} WhitelistCollectionsPanelProps
 * @property {boolean} isOpen - Controls whether the panel is currently open or closed.
 * @property {() => void} onClose - Callback function invoked when the panel requests to be closed.
 */

/**
 * WhitelistCollectionsPanel: A UI component for viewing and managing a whitelist of
 * LSP7/LSP8 token collections. If the current user is an admin for the viewed profile,
 * they can add new collections to or remove existing ones from the whitelist.
 * The whitelist data is stored on the Universal Profile using ERC725Y.
 *
 * @param {WhitelistCollectionsPanelProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered WhitelistCollectionsPanel, or null if not `isOpen`.
 */
const WhitelistCollectionsPanel = ({ isOpen, onClose }) => {
  // hostProfileAddress is the UP being viewed, isAdminOfHostProfile checks if visitor is admin of *that* UP.
  // For this panel, we typically want to check if the *visitor* is the RADAR_OFFICIAL_ADMIN_ADDRESS
  // and if they are viewing their *own* profile to manage its whitelist, or if they are the global admin
  // managing another profile's whitelist (if that's a feature).
  // The current `isAdminOfHostProfile` might be misleading if it means "is visitor the owner of host AND admin".
  // Assuming `isAdminOfHostProfile` correctly reflects the permission to edit the *hostProfileAddress*'s whitelist.
  const { hostProfileAddress, isRadarProjectAdmin } = useUserSession(); // Using isRadarProjectAdmin for global admin check
  const { configServiceInstanceReady, configServiceRef } = useConfig();

  /** @type {[Array<WhitelistCollection>, React.Dispatch<React.SetStateAction<Array<WhitelistCollection>>>]} */
  const [collections, setCollections] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [newCollection, setNewCollection] = useState({ address: "", name: "", description: "", imageUrl: "" });
  /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
  const [error, setError] = useState("");
  /** @type {[string, React.Dispatch<React.SetStateAction<string>>]} */
  const [success, setSuccess] = useState("");

  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const statusTimerRef = useRef(null);
  /** @type {React.RefObject<boolean>} */
  const isMountedRef = useRef(false);

  // Determine if the current logged-in user can edit this whitelist.
  // For this panel, typically only the RADAR_OFFICIAL_ADMIN_ADDRESS can manage whitelists.
  // The `hostProfileAddress` is the target for saving the whitelist.
  const canAdministerWhitelist = isRadarProjectAdmin; // Simplified: only global admin can manage any whitelist.

  const displayStatus = useCallback(
    (message, type = "error", duration = 4000) => {
      if (!isMountedRef.current) return;
      setError(type === "error" ? message : "");
      setSuccess(type === "success" ? message : "");
      if (statusTimerRef.current) clearTimeout(statusTimerRef.current);
      if (duration > 0) {
        statusTimerRef.current = setTimeout(() => {
          if (isMountedRef.current) {
            setError("");
            setSuccess("");
          }
          statusTimerRef.current = null;
        }, duration);
      }
    },
    [], // No dependencies as it uses refs and setters
  );

  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      if (statusTimerRef.current) clearTimeout(statusTimerRef.current);
    };
  }, []);

  // Load collections when the panel is opened or relevant dependencies change
  useEffect(() => {
    if (!isOpen || !configServiceInstanceReady || !configServiceRef?.current || !hostProfileAddress) {
      if (!isOpen) { // Reset state if panel is closed
        setCollections([]);
        setError("");
        setSuccess("");
      }
      return;
    }

    const loadCollections = async () => {
      setIsLoading(true);
      setError(""); // Clear previous errors
      setSuccess(""); // Clear previous success messages
      const logPrefix = `[WhitelistPanel Load Addr:${hostProfileAddress.slice(0,6)}]`;

      try {
        const service = configServiceRef.current;
        if (!service) {
            throw new Error("Configuration service is not available.");
        }
        const whitelistDataStringHex = await service.loadDataFromKey(hostProfileAddress, RADAR_WHITELIST_KEY);

        let parsedCollections = [];
        if (whitelistDataStringHex && whitelistDataStringHex !== "0x") {
          try {
            const decodedJsonString = hexToString(/** @type {`0x${string}`} */ (whitelistDataStringHex));
            const tempParsed = JSON.parse(decodedJsonString);
            if (Array.isArray(tempParsed)) {
              // Ensure each collection has a unique `id`, defaulting to address if missing
              parsedCollections = tempParsed.map((c) => ({ ...c, id: c.id || c.address }));
            } else if (import.meta.env.DEV) {
              console.warn(`${logPrefix} Parsed whitelist data is not an array. Data:`, tempParsed);
            }
          } catch (decodeOrParseError) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Error decoding/parsing whitelist hex/JSON:`, decodeOrParseError);
            }
            displayStatus("Failed to parse existing whitelist data.", "error");
          }
        }
        setCollections(parsedCollections);
      } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Error loading whitelist:`, error);
        }
        displayStatus(`Failed to load collections: ${error.message}`, "error");
        setCollections([]); // Reset to empty on error
      } finally {
        if (isMountedRef.current) setIsLoading(false);
      }
    };

    loadCollections();
  }, [isOpen, configServiceInstanceReady, configServiceRef, hostProfileAddress, displayStatus]);

  const handleInputChange = useCallback((e) => {
    const { name, value } = e.target;
    setNewCollection((prev) => ({ ...prev, [name]: value }));
  }, []); // setNewCollection is stable

  const handleAddCollection = useCallback(async () => {
    if (!canAdministerWhitelist) { displayStatus("Permission Denied. Only project admin can manage whitelists.", "error"); return; }
    if (!configServiceInstanceReady || !configServiceRef.current) { displayStatus("Service not ready.", "error"); return; }

    const targetSaveAddress = hostProfileAddress; // Whitelist is saved on the profile being viewed
    if (!targetSaveAddress) { displayStatus("Cannot determine target profile to save whitelist.", "error"); return; }

    const addressToAdd = newCollection.address.trim();
    const nameToAdd = newCollection.name.trim();

    if (!addressToAdd || !nameToAdd) { displayStatus("Collection Address and Name are required.", "error"); return; }
    if (!isAddress(addressToAdd)) { displayStatus("Invalid collection address format.", "error"); return; }
    if (collections.some((c) => c.address?.toLowerCase() === addressToAdd.toLowerCase())) {
      displayStatus("Collection address already exists in the whitelist.", "error");
      return;
    }

    setIsLoading(true); setError(""); setSuccess("");

    try {
      const service = configServiceRef.current;
      if (!service) throw new Error("Configuration service became unavailable.");

      const collectionToAdd = {
        address: addressToAdd,
        name: nameToAdd,
        description: newCollection.description.trim(),
        imageUrl: newCollection.imageUrl.trim() || null,
        id: addressToAdd, // Use address as ID for simplicity
        addedAt: Date.now(),
      };
      const updatedCollections = [...collections, collectionToAdd];
      const jsonString = JSON.stringify(updatedCollections);
      const valueHex = stringToHex(jsonString);

      await service.saveDataToKey(targetSaveAddress, RADAR_WHITELIST_KEY, valueHex);

      if (isMountedRef.current) {
        setCollections(updatedCollections);
        setNewCollection({ address: "", name: "", description: "", imageUrl: "" }); // Reset form
        displayStatus("Collection added successfully!", "success");
      }
    } catch (error) {
      if (import.meta.env.DEV) console.error("[WhitelistPanel] Error adding collection:", error);
      if (isMountedRef.current) displayStatus(`Failed to add collection: ${error.message}`, "error");
    } finally {
      if (isMountedRef.current) setIsLoading(false);
    }
  }, [canAdministerWhitelist, configServiceInstanceReady, configServiceRef, hostProfileAddress, newCollection, collections, displayStatus]);

  const handleRemoveCollection = useCallback(async (collectionIdToRemove) => {
    if (!canAdministerWhitelist) { displayStatus("Permission Denied. Only project admin can manage whitelists.", "error"); return; }
    if (!configServiceInstanceReady || !configServiceRef.current) { displayStatus("Service not ready.", "error"); return; }

    const targetSaveAddress = hostProfileAddress;
     if (!targetSaveAddress) { displayStatus("Cannot determine target profile for whitelist update.", "error"); return; }

    if (!collectionIdToRemove) return;
    if (!window.confirm(`Are you sure you want to remove collection "${collectionIdToRemove}" from the whitelist for this profile?`)) return;

    setIsLoading(true); setError(""); setSuccess("");

    try {
      const service = configServiceRef.current;
      if (!service) throw new Error("Configuration service became unavailable.");

      const updatedCollections = collections.filter((c) => (c.id || c.address) !== collectionIdToRemove);
      const jsonString = JSON.stringify(updatedCollections);
      const valueHex = stringToHex(jsonString);

      await service.saveDataToKey(targetSaveAddress, RADAR_WHITELIST_KEY, valueHex);

      if (isMountedRef.current) {
        setCollections(updatedCollections);
        displayStatus("Collection removed successfully!", "success");
      }
    } catch (error) {
      if (import.meta.env.DEV) console.error("[WhitelistPanel] Error removing collection:", error);
      if (isMountedRef.current) displayStatus(`Failed to remove collection: ${error.message}`, "error");
    } finally {
      if (isMountedRef.current) setIsLoading(false);
    }
  }, [canAdministerWhitelist, configServiceInstanceReady, configServiceRef, hostProfileAddress, collections, displayStatus]);

  if (!isOpen) return null; // Don't render if panel is not open

  return (
    <Panel
      title={canAdministerWhitelist ? "Manage Approved Collections" : "Approved Collections"}
      onClose={onClose}
      className="whitelist-panel"
      width="450px" // Example width, can be adjusted
    >
      <div className="whitelist-panel-content">
        {canAdministerWhitelist && hostProfileAddress && ( // Show admin section only if admin and a profile is being viewed
          <>
            <div className="admin-header">
              <div className="admin-badge">Admin Mode</div>
              <p className="admin-description">
                Add or remove LSP7/LSP8 collection addresses allowed in the Token Selector.
                Changes apply to the whitelist stored on the profile: {formatAddress(hostProfileAddress)}.
              </p>
            </div>
            {error && <div className="status-message error">{error}</div>}
            {success && <div className="status-message success">{success}</div>}
            <div className="add-collection-section section-box"> {/* Added section-box */}
              <h3 className="section-title">Add New Collection</h3>
              <div className="form-group">
                <label htmlFor="address">Collection Address*</label>
                <input type="text" id="address" name="address" className="form-control" value={newCollection.address} onChange={handleInputChange} placeholder="0x..." disabled={isLoading} aria-required="true" />
              </div>
              <div className="form-group">
                <label htmlFor="name">Collection Name*</label>
                <input type="text" id="name" name="name" className="form-control" value={newCollection.name} onChange={handleInputChange} placeholder="Enter collection name" disabled={isLoading} aria-required="true" />
              </div>
              <div className="form-group">
                <label htmlFor="description">Description</label>
                <textarea id="description" name="description" className="form-control" value={newCollection.description} onChange={handleInputChange} placeholder="Brief description (optional)" rows={2} disabled={isLoading}/>
              </div>
              <div className="form-group">
                <label htmlFor="imageUrl">Image URL</label>
                <input type="text" id="imageUrl" name="imageUrl" className="form-control" value={newCollection.imageUrl} onChange={handleInputChange} placeholder="https://... (optional)" disabled={isLoading}/>
              </div>
              <button className="btn btn-block btn-primary" onClick={handleAddCollection} disabled={isLoading || !newCollection.address.trim() || !newCollection.name.trim() || !isAddress(newCollection.address.trim())}>
                {isLoading ? "Adding..." : "Add to Whitelist"}
              </button>
            </div>
          </>
        )}

        <div className="collections-section section-box"> {/* Added section-box */}
          <h3 className="section-title">Current Whitelist {hostProfileAddress ? `on ${formatAddress(hostProfileAddress)}` : ""}</h3>
          {isLoading && collections.length === 0 && (<div className="loading-message">Loading whitelisted collections...</div>)}
          {!isLoading && collections.length === 0 && hostProfileAddress && (<div className="empty-message">No collections whitelisted for this profile yet.</div>)}
          {!hostProfileAddress && (<div className="empty-message">No profile loaded to view whitelist.</div>)}
          
          {collections.length > 0 && (
            <div className="collections-grid">
              {collections.map((collection) => (
                <div key={collection.id || collection.address} className="collection-card">
                  <div className="collection-image">
                    <img
                        src={ collection.imageUrl || `https://via.placeholder.com/80/252525/00f3ff.png?text=${collection.name?.charAt(0)?.toUpperCase() || "?"}` }
                        alt={collection.name || "Collection visual identifier"}
                        onError={(e) => { // Fallback for broken image URLs
                            e.target.onerror = null; // Prevent infinite loop
                            e.target.src = `https://via.placeholder.com/80/252525/00f3ff.png?text=${collection.name?.charAt(0)?.toUpperCase() || "?"}`;
                        }}
                    />
                  </div>
                  <div className="collection-info">
                    <h4 className="collection-name" title={collection.name}> {collection.name || "Unnamed Collection"} </h4>
                    <div className="collection-address" title={collection.address}> {formatAddress(collection.address)} </div>
                    {collection.description && ( <div className="collection-description"> {collection.description} </div> )}
                  </div>
                  {canAdministerWhitelist && hostProfileAddress && ( // Show remove button only if admin and profile loaded
                    <button
                        className="remove-button btn-icon" /* Added btn-icon for consistency */
                        onClick={() => handleRemoveCollection( collection.id || collection.address )}
                        title="Remove from Whitelist"
                        aria-label={`Remove ${collection.name || 'this collection'} from Whitelist`}
                        disabled={isLoading}
                    >
                        ✕
                    </button>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </Panel>
  );
};

WhitelistCollectionsPanel.propTypes = {
  /** Controls whether the panel is currently open or closed. */
  isOpen: PropTypes.bool.isRequired,
  /** Callback function invoked when the panel requests to be closed. */
  onClose: PropTypes.func.isRequired,
};

export default React.memo(WhitelistCollectionsPanel);
```

---
### `src\components\Toolbars\ToolbarStyles\TopRightControls.css`
```css
.top-right-controls-container {
  position: fixed;
  top: var(--space-lg);
  right: var(--space-lg);
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 10px;
  z-index: var(--z-controls); /* Ensure it's above other UI that might fade */
  width: fit-content;
  max-width: 100%;
  background: none;
  pointer-events: auto; /* This container should always be interactive */
}

.top-right-controls-container .toolbar-icon {
  width: var(--icon-size-lg);
  height: var(--icon-size-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-normal);
  background: rgba(0, 243, 255, 0.05);
  border: 1px solid rgba(0, 243, 255, 0.2);
  overflow: visible;
  position: relative;
  padding: 0;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  pointer-events: auto; /* Individual icons also need this */
}

.top-right-controls-container .toolbar-icon:hover {
  background: rgba(0, 243, 255, 0.15);
  border-color: rgba(0, 243, 255, 0.3);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}

.top-right-controls-container .icon-image {
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  transition: all var(--transition-fast);
  opacity: 0.9;
}

.top-right-controls-container .toolbar-icon:hover .icon-image {
  opacity: 1;
  filter: drop-shadow(0 0 5px rgba(0, 243, 255, 0.3));
}

.enhanced-view-icon {
  font-size: 18px;
  color: var(--color-primary);
  transition: all var(--transition-fast);
}

.top-right-controls-container .toolbar-icon:hover .enhanced-view-icon {
  transform: scale(1.1);
  filter: drop-shadow(0 0 3px var(--color-primary-a30));
}

/* This class is added to top-right-controls-container by TopRightControls.jsx when isUiVisible is false */
.top-right-controls-container.ui-hidden .toolbar-icon:not(.fixed-toggle-button) {
  display: none !important; /* Hide other icons when UI is "hidden" */
}

/* Ensure the toggle button itself is always displayed correctly */
.top-right-controls-container .fixed-toggle-button {
  display: flex !important;
}

/* Styles for the toggle button when the rest of the UI is hidden */
.top-right-controls-container.ui-hidden .fixed-toggle-button.show-ui-btn {
  opacity: 0.7; /* Make it slightly less prominent if desired */
  background: rgba(0, 0, 0, 0.2); /* Example background */
  border-color: rgba(var(--color-primary-rgb), 0.4);
}
.top-right-controls-container.ui-hidden .fixed-toggle-button.show-ui-btn:hover {
  opacity: 1;
  background: rgba(var(--color-primary-rgb), 0.15);
}
```

---
### `src\components\Toolbars\ToolbarStyles\VerticalToolbar.css`
```css
.vertical-toolbar-icon {
  position: fixed;
  left: var(--space-lg);
  width: var(--icon-size-lg);
  height: var(--icon-size-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-normal);
  background: rgba(0, 243, 255, 0.05);
  border: 1px solid rgba(0, 243, 255, 0.2);
  overflow: visible;
  z-index: var(--z-controls);
  padding: 0;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
}

.vertical-toolbar-icon:hover {
  background: rgba(0, 243, 255, 0.15);
  border-color: rgba(0, 243, 255, 0.3);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}

.vertical-toolbar-icon.active {
  background: rgba(0, 243, 255, 0.15);
  border-color: rgba(0, 243, 255, 0.5);
  box-shadow: var(--shadow-primary-md);
}

.vertical-toolbar-icon .icon-image {
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  transition: all var(--transition-fast);
  opacity: 0.9;
}

.vertical-toolbar-icon:hover .icon-image,
.vertical-toolbar-icon.active .icon-image {
  opacity: 1;
  filter: drop-shadow(0 0 5px rgba(0, 243, 255, 0.3));
}

.vertical-toolbar-icon.active::after {
  content: "";
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 10px;
  background: transparent;
  animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
  z-index: -1;
}

.vertical-toolbar-icon.active::before {
  content: "";
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border-radius: 30px;
  background: rgba(0, 243, 255, 0.15);
  animation: pulse-core 3s cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite;
  z-index: -1;
}

.notification-orb {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.notification-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  min-width: 16px;
  height: 16px;
  background: #ff3a3a;
  color: white;
  border-radius: 8px;
  font-size: 10px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 3px;
  box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
  z-index: 10;
}

.bell-animation {
  animation: bell-pulse 2s infinite ease-in-out;
}

@keyframes bell-pulse {
  0% {
    transform: scale(1);
  }
  10% {
    transform: scale(1.1);
  }
  20% {
    transform: scale(1);
  }
  100% {
    transform: scale(1);
  }
}
```

---
### `src\components\Toolbars\TopRightControls.jsx`
```jsx
// src/components/Toolbars/TopRightControls.jsx
import React from "react";
import PropTypes from "prop-types";

import "./ToolbarStyles/TopRightControls.css"; // Local styles
import {
  whitelistIcon,
  enlargeIcon,
  learnIcon, // Info icon
  eyeIcon,   // UI hidden icon
  eyeopenIcon, // UI visible icon
} from "../../assets"; // Assuming assets are correctly pathed

/**
 * @typedef {object} TopRightControlsProps
 * @property {boolean} [showWhitelist=false] - Whether to display the whitelist management button. Visibility is ultimately controlled by this prop combined with `isProjectAdminForWhitelist`.
 * @property {boolean} [isProjectAdminForWhitelist=false] - Indicates if the current user has administrative privileges required to see and use the whitelist button.
 * @property {boolean} [showInfo=true] - Whether to display the information overlay button.
 * @property {boolean} [showToggleUI=true] - Whether to display the UI visibility toggle button.
 * @property {boolean} [showEnhancedView=true] - Whether to display the fullscreen/enhanced view toggle button.
 * @property {(() => void)} [onWhitelistClick] - Callback function invoked when the whitelist button is clicked.
 * @property {(() => void)} [onInfoClick] - Callback function invoked when the info button is clicked.
 * @property {(() => void)} [onToggleUI] - Callback function invoked when the UI toggle button is clicked.
 * @property {(() => void)} [onEnhancedView] - Callback function invoked when the fullscreen/enhanced view toggle button is clicked.
 * @property {boolean} [isUiVisible=true] - Current visibility state of the main UI, used to determine the icon for the UI toggle button and apply conditional styling.
 */

/**
 * TopRightControls component renders a set of control icons positioned at the top-right
 * of the screen. It includes buttons for toggling fullscreen/enhanced view,
 * managing whitelisted collections (conditionally shown to admins), accessing an
 * information overlay, and toggling the main UI visibility.
 *
 * @param {TopRightControlsProps} props - The component's props.
 * @returns {JSX.Element | null} The rendered TopRightControls component, or null if it shouldn't be visible (though current logic always renders the container).
 */
const TopRightControls = ({
  showWhitelist = false,
  isProjectAdminForWhitelist = false,
  showInfo = true,
  showToggleUI = true,
  showEnhancedView = true,
  onWhitelistClick,
  onInfoClick,
  onToggleUI,
  onEnhancedView,
  isUiVisible = true,
}) => {
  // The main container's visibility is handled by its parent or CSS based on `isUiVisible` for its children.
  // The `ui-hidden` class on the container itself might be redundant if children are conditionally rendered
  // or also styled based on `isUiVisible`. For this refactor, keeping existing class logic.
  return (
    <div className={`top-right-controls-container ${!isUiVisible ? "ui-hidden" : ""}`}>
      {/* Enhanced View / Fullscreen Toggle Button */}
      {showEnhancedView && isUiVisible && (
        <button
          className="toolbar-icon"
          onClick={onEnhancedView}
          title="Toggle Fullscreen"
          aria-label="Toggle Fullscreen" // Accessibility: Provide an accessible name
        >
          <img
            src={enlargeIcon}
            alt="Toggle Fullscreen" // Alt text for accessibility
            className="enhanced-view-icon icon-image"
          />
        </button>
      )}

      {/* Whitelist Management Button: Conditionally rendered */}
      {showWhitelist && isProjectAdminForWhitelist && isUiVisible && (
        <button
          className="toolbar-icon"
          onClick={onWhitelistClick}
          title="Manage Whitelisted Collections"
          aria-label="Manage Whitelisted Collections"
        >
          <img
            src={whitelistIcon}
            alt="Manage Collections"
            className="icon-image"
          />
        </button>
      )}

      {/* Information Overlay Button */}
      {showInfo && isUiVisible && (
        <button
          className="toolbar-icon"
          onClick={onInfoClick}
          title="Information"
          aria-label="Show Information"
        >
          <img src={learnIcon} alt="Information" className="icon-image" />
        </button>
      )}

      {/* UI Visibility Toggle Button */}
      {showToggleUI && (
        <button
          // `fixed-toggle-button` suggests it might always be visible regardless of `isUiVisible` for other elements.
          // `show-ui-btn` class is applied when UI is hidden, potentially making this button more prominent.
          className={`toolbar-icon fixed-toggle-button ${!isUiVisible ? "show-ui-btn" : ""}`}
          onClick={onToggleUI}
          title={isUiVisible ? "Hide UI" : "Show UI"}
          aria-label={isUiVisible ? "Hide User Interface" : "Show User Interface"}
        >
          <img
            src={isUiVisible ? eyeopenIcon : eyeIcon}
            alt={isUiVisible ? "Hide UI" : "Show UI"}
            className="icon-image"
          />
        </button>
      )}
    </div>
  );
};

TopRightControls.propTypes = {
  showWhitelist: PropTypes.bool,
  isProjectAdminForWhitelist: PropTypes.bool,
  showInfo: PropTypes.bool,
  showToggleUI: PropTypes.bool,
  showEnhancedView: PropTypes.bool,
  onWhitelistClick: PropTypes.func,
  onInfoClick: PropTypes.func,
  onToggleUI: PropTypes.func,
  onEnhancedView: PropTypes.func,
  isUiVisible: PropTypes.bool,
};

// Default export is fine for components.
export default TopRightControls;
```

---
### `src\components\Toolbars\VerticalToolbar.jsx`
```jsx
// src/components/Toolbars/VerticalToolbar.jsx
import React from "react"; // Removed unused useState import
import PropTypes from "prop-types";

import "./ToolbarStyles/VerticalToolbar.css"; // Local styles
import {
  controlsIcon,
  notifyIcon,
  listenIcon, // For Events/Reactions panel
  changetokenIcon, // For Token Selector
  writeIcon, // For Save panel
  wavezIcon, // For Audio panel
} from "../../assets"; // Assuming assets are correctly pathed

/**
 * @typedef {object} VerticalToolbarProps
 * @property {string | null} activePanel - The identifier of the currently active panel, used to highlight the corresponding toolbar button.
 * @property {(panelName: string) => void} setActivePanel - Callback function to open/toggle a panel. This is typically the `openPanel` or `togglePanel` function from a panel manager hook (e.g., `usePanelManager` or `useUIState`).
 * @property {number} [notificationCount=0] - The number of unread notifications, displayed as a badge on the notifications icon.
 */

/**
 * VerticalToolbar: Renders a fixed vertical toolbar, typically on the left side of the screen.
 * It provides icon buttons to open different control panels (e.g., Controls, Notifications, Events, Save, Audio)
 * and to trigger overlays like the Token Selector. It also displays a badge for unread notifications.
 * The visual "active" state of buttons is determined by the `activePanel` prop.
 *
 * @param {VerticalToolbarProps} props - The component's props.
 * @returns {JSX.Element} The rendered VerticalToolbar component.
 */
const VerticalToolbar = ({
  activePanel,
  setActivePanel,
  notificationCount = 0,
}) => {

  /**
   * Handles a click on a toolbar icon, calling `setActivePanel` with the target panel's name.
   * @param {string} panelName - The identifier of the panel to activate.
   */
  const handleIconClick = (panelName) => {
    if (typeof setActivePanel === 'function') {
      setActivePanel(panelName);
    } else if (import.meta.env.DEV) {
      console.warn("[VerticalToolbar] setActivePanel prop is not a function.");
    }
  };

  // Specific handler for the token selector, as it might be treated as an overlay
  // or a special panel type by the panel manager.
  const openTokenSelector = () => {
    handleIconClick("tokens"); // Standardize to use panel name "tokens"
  };

  // Fixed position values for vertical alignment of buttons.
  // Consider moving to CSS if positions are static and don't need JS logic.
  // Using inline styles here as per original, but CSS classes would be more maintainable for complex layouts.
  const buttonPositions = [
    { top: "20px" }, // Controls
    { top: "65px" }, // Notifications
    { top: "110px" }, // Events
    { top: "155px" }, // Token Selector
    { top: "200px" }, // Save Config
    { top: "245px" }, // Audio Visualizer
  ];

  return (
    // Using React.Fragment <>...</> as the root, assuming the toolbar is positioned absolutely by its CSS.
    <>
      <button
        className={`vertical-toolbar-icon ${activePanel === "controls" ? "active" : ""}`}
        onClick={() => handleIconClick("controls")}
        title="Controls"
        aria-label="Open Controls Panel" // Accessibility
        style={buttonPositions[0]}
      >
        <img src={controlsIcon} alt="Controls Panel" className="icon-image" />
      </button>

      <button
        className={`vertical-toolbar-icon ${activePanel === "notifications" ? "active" : ""}`}
        onClick={() => handleIconClick("notifications")}
        title="Notifications"
        aria-label="Open Notifications Panel"
        style={buttonPositions[1]}
      >
        <div className="notification-orb"> {/* Container for icon and badge */}
          <img
            src={notifyIcon}
            alt="Notifications Panel"
            className={`icon-image ${notificationCount > 0 ? "bell-animation" : ""}`}
          />
          {notificationCount > 0 && (
            <div className="notification-badge" aria-label={`${notificationCount} unread notifications`}>
              {notificationCount}
            </div>
          )}
        </div>
      </button>

      <button
        className={`vertical-toolbar-icon ${activePanel === "events" ? "active" : ""}`}
        onClick={() => handleIconClick("events")}
        title="Event Reactions"
        aria-label="Open Event Reactions Panel"
        style={buttonPositions[2]}
      >
        <img src={listenIcon} alt="Event Reactions Panel" className="icon-image" />
      </button>

      <button
        className={`vertical-toolbar-icon ${activePanel === "tokens" ? "active" : ""}`} // Token selector can also have an active state
        onClick={openTokenSelector}
        title="Select Token / Asset"
        aria-label="Open Token Selector"
        style={buttonPositions[3]}
      >
        <img src={changetokenIcon} alt="Select Token" className="icon-image" />
      </button>

      <button
        className={`vertical-toolbar-icon ${activePanel === "save" ? "active" : ""}`}
        onClick={() => handleIconClick("save")}
        title="Save Configuration"
        aria-label="Open Save Configuration Panel"
        style={buttonPositions[4]}
      >
        <img src={writeIcon} alt="Save Configuration" className="icon-image" />
      </button>

      <button
        className={`vertical-toolbar-icon ${activePanel === "audio" ? "active" : ""}`}
        onClick={() => handleIconClick("audio")}
        title="Audio Visualizer Controls"
        aria-label="Open Audio Controls Panel"
        style={buttonPositions[5]}
      >
        <img src={wavezIcon} alt="Audio Controls" className="icon-image" />
      </button>
    </>
  );
};

VerticalToolbar.propTypes = {
  /** Identifier of the currently active panel, to highlight the corresponding button. */
  activePanel: PropTypes.string,
  /** Callback function to open/toggle a panel, invoked with the panel's identifier string. */
  setActivePanel: PropTypes.func.isRequired,
  /** The number of unread notifications, displayed as a badge. */
  notificationCount: PropTypes.number,
};

// Default export is standard for React components.
export default VerticalToolbar;
```

---
### `src\components\UI\PresetSelectorBar.css`
```css
/* src/components/UI/ToolbarStyles/PresetSelectorBar.css (Example path) */
@import "../../styles/variables.css"; /* Ensure this is at the very top */

/* 
  Theme variables for preset selector buttons.
  Uses a yellow/orange palette for active and hover states to provide clear visual feedback.
  Default border is kept neutral to maintain contrast until interaction.
*/
:root {
  /* Active State (Yellow) */
  --color-preset-active-bg: rgba(255, 193, 7, 0.85); /* Yellow background for active preset */
  --color-preset-active-border: rgba(255, 193, 7, 1.0); /* Solid yellow border for active preset */
  --color-preset-active-text: #1a1a2e; /* Dark text for high contrast on yellow */

  /* Hover State (Lighter Yellow/Orange) */
  --color-preset-hover-bg: rgba(255, 204, 51, 0.8); /* Lighter yellow/orange for hover */
  --color-preset-hover-border: rgba(255, 214, 82, 1.0); /* Brighter border on hover */
  --color-preset-hover-text: #1a1a2e; /* Dark text for contrast on hover */

  /* Ping Animation for active preset button */
  --ping-duration: 1.5s;
  --ping-color: rgba(255, 193, 7, 0.7); /* Ping effect color, matches active theme */
  --ping-spread: 5px; /* How far the ping animation spreads */

  /* Default border for preset buttons - uses a general border color variable */
  --color-preset-default-border: var(--color-border);

  /* Slide Animation for preset button container transitions */
  --slide-duration: 300ms;
}

.preset-selector-bar {
  position: fixed;
  bottom: var(--space-md); /* Positioned at the bottom of the viewport */
  left: 50%;
  transform: translateX(-50%); /* Center horizontally */
  z-index: var(--z-controls); /* Ensure it's above canvas but below modals */
  display: flex;
  align-items: center;
  gap: var(--space-xs);
  padding: var(--space-xxs);
  border: none; /* Bar itself has no border, buttons do */
  border-radius: var(--radius-md);
  transition: opacity var(--transition-normal), visibility var(--transition-normal);
  opacity: 1;
  visibility: visible;
  background: transparent; /* Bar background is transparent, buttons have their own */
  /* perspective: 1000px; */ /* Optional: Add perspective for 3D transforms if used */
}

.preset-buttons-container {
  display: flex;
  gap: var(--space-sm);
  transition: transform var(--slide-duration) ease-in-out;
  transform: translateX(0); /* Initial state for sliding animations */
}

/* --- Slide Animations for preset button pagination --- */
@keyframes slideInFromRight {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}
@keyframes slideInFromLeft {
  from { transform: translateX(-100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

/* Apply slide animations to the container */
.preset-buttons-container.slide-in-left {
  animation: slideInFromLeft var(--slide-duration) ease-in-out forwards;
}
.preset-buttons-container.slide-in-right {
  animation: slideInFromRight var(--slide-duration) ease-in-out forwards;
}
/* --- End Slide Animations --- */

.preset-selector-button,
.pagination-button {
  font-family: var(--font-family);
  font-weight: 600;
  color: var(--color-text);
  border: 1px solid var(--color-preset-default-border);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background-color var(--transition-fast), border-color var(--transition-fast), color var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
  flex-shrink: 0; /* Prevent buttons from shrinking if container is too small */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0; /* Padding controlled by width/height and content centering */
  line-height: 1; /* Ensure text is vertically centered */
  background: var(--color-button-secondary-a80); /* Semi-transparent background */
  backdrop-filter: blur(var(--blur-amount)); /* Frosted glass effect */
  -webkit-backdrop-filter: blur(var(--blur-amount)); /* Safari support for backdrop-filter */
  overflow: hidden; /* Clip content like ping animation within button bounds */
  position: relative; /* For positioning pseudo-elements like ping */
}

.preset-selector-button {
  font-size: var(--font-size-xs);
  width: 28px;
  height: 28px;
}

.pagination-button {
  font-size: var(--font-size-sm);
  width: 24px;
  height: 24px;
}

.preset-selector-button:hover:not(:disabled):not(.active),
.pagination-button:hover:not(:disabled) {
  background: var(--color-preset-hover-bg);
  border-color: var(--color-preset-hover-border);
  color: var(--color-preset-hover-text);
  transform: translateY(-1px); /* Slight lift on hover */
}

.preset-selector-button:active:not(:disabled):not(.active),
.pagination-button:active:not(:disabled) {
  background: rgba(255, 180, 0, 0.9); /* Slightly darker/more saturated for active press */
  transform: translateY(0px); /* Reset lift on active press */
  box-shadow: none; /* Remove any hover shadow */
}

.preset-selector-button:disabled,
.pagination-button:disabled {
  color: var(--color-text); /* Maintain text color for readability */
  border-color: var(--color-preset-default-border);
  background: var(--color-button-secondary-a80);
  backdrop-filter: blur(var(--blur-amount));
  -webkit-backdrop-filter: blur(var(--blur-amount));
  cursor: not-allowed;
  pointer-events: none; /* Disable pointer interactions */
  opacity: 0.8; /* Reduce opacity to indicate disabled state */
  animation: none !important; /* Ensure no animations run on disabled state */
  box-shadow: none !important;
  transform: none !important;
}

/* Continuous ping animation for the active preset button */
@keyframes continuous-ping-animation {
  0%, 100% {
    box-shadow: 0 0 0 0px var(--ping-color); /* Start and end with no spread */
  }
  50% {
    /* Spread out with full transparency at midpoint */
    box-shadow: 0 0 0 var(--ping-spread) rgba(255, 193, 7, 0);
  }
}

.preset-selector-button.active {
  background: var(--color-preset-active-bg);
  border-color: var(--color-preset-active-border);
  color: var(--color-preset-active-text);
  cursor: default; /* Indicate it's already active */
  transform: translateY(0px); /* No lift for active state */
  animation: continuous-ping-animation var(--ping-duration) infinite ease-out;
}

/* Ensure disabled active button doesn't show ping animation */
.preset-selector-button.active:disabled {
  background: var(--color-preset-active-bg); /* Maintain active appearance */
  border-color: var(--color-preset-active-border);
  color: var(--color-preset-active-text);
  opacity: 0.7; /* Slightly more reduced opacity for disabled active */
  animation: none;
  box-shadow: none;
  cursor: not-allowed;
  pointer-events: none;
  transform: none;
}
```

---
### `src\components\UI\PresetSelectorBar.jsx`
```jsx
import React, { useMemo, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import './PresetSelectorBar.css';

const ITEMS_PER_PAGE = 5;
const SLIDE_ANIMATION_DURATION_MS = 300;
const MAX_BUTTON_LABEL_LENGTH = 3; // Max characters for the button label

/**
 * Generates a concise display label for a preset button.
 * - If name is "Prefix.Number" (e.g., "RADAR.001"), displays the number (e.g., "1").
 * - If name is "Prefix.Text" (e.g., "MyProject.Scene"), displays the first MAX_BUTTON_LABEL_LENGTH chars of "Text" in uppercase (e.g., "SCE").
 * - If name is "TextOnly" (e.g., "Kalyuga"), displays the first MAX_BUTTON_LABEL_LENGTH chars in uppercase (e.g., "KAL").
 * @param {string} fullName - The full preset name.
 * @returns {string} The generated display label.
 */
const getPresetDisplayLabel = (fullName) => {
  if (!fullName || typeof fullName !== 'string') return '?';

  const nameParts = fullName.split('.');

  if (nameParts.length > 1) {
    // Case 1: "Prefix.Identifier"
    const identifier = nameParts.slice(1).join('.'); // Get everything after the first dot

    if (/^\d+$/.test(identifier)) { // If identifier is purely numeric (e.g., "001", "123")
      const num = parseInt(identifier, 10);
      return num.toString(); // Display "1", "123"
    } else {
      // If identifier is text (e.g., "Kal", "My Scene")
      return identifier.substring(0, MAX_BUTTON_LABEL_LENGTH).toUpperCase();
    }
  } else {
    // Case 2: "FullNameOnly" (no dots)
    return fullName.substring(0, MAX_BUTTON_LABEL_LENGTH).toUpperCase();
  }
};


/**
 * PresetSelectorBar displays a paginated list of saved configuration presets
 * as numbered/labeled buttons. It allows users to load presets by clicking these buttons
 * and navigate through pages of presets if the total number exceeds `ITEMS_PER_PAGE`.
 * The currently active preset is visually highlighted.
 *
 * @param {object} props - Component props.
 * @param {Array<{name: string}>} [props.savedConfigList=[]] - An array of saved preset objects, each expected to have a `name` property.
 * @param {string|null} [props.currentConfigName=null] - The name of the currently active/loaded preset.
 * @param {(presetName: string) => void} props.onPresetSelect - Callback function invoked when a preset button is clicked, passing the preset's name.
 * @param {boolean} [props.isLoading=false] - Indicates if presets are currently being loaded or a transition is in progress, used to disable controls.
 * @returns {JSX.Element|null} The rendered PresetSelectorBar component, or null if no presets are available.
 */
const PresetSelectorBar = ({
  savedConfigList = [],
  currentConfigName,
  onPresetSelect,
  isLoading,
}) => {
  const [currentPage, setCurrentPage] = useState(0);
  const [paginationDirection, setPaginationDirection] = useState(null); // 'prev', 'next', or null

  const sortedList = useMemo(() => {
    const validList = savedConfigList.filter(
      (item) => item && typeof item.name === 'string'
    );
    return [...validList].sort((a, b) => {
      const numA = parseInt(a.name.split('.')[1] || '0', 10);
      const numB = parseInt(b.name.split('.')[1] || '0', 10);
      const valA = isNaN(numA) ? Infinity : numA;
      const valB = isNaN(numB) ? Infinity : numB;
      // If both are numbers, sort numerically
      if (valA !== Infinity && valB !== Infinity) return valA - valB;
      // If one is a number and the other isn't, number comes first
      if (valA !== Infinity) return -1;
      if (valB !== Infinity) return 1;
      // If both are text (or non-standard), sort alphabetically by full name
      return a.name.localeCompare(b.name);
    });
  }, [savedConfigList]);

  useEffect(() => {
    if (currentConfigName && sortedList.length > 0) {
      const currentIndex = sortedList.findIndex(p => p.name === currentConfigName);
      if (currentIndex !== -1) {
        const targetPage = Math.floor(currentIndex / ITEMS_PER_PAGE);
        setCurrentPage(prevPage => {
            if (prevPage !== targetPage) {
                setPaginationDirection(null);
                return targetPage;
            }
            return prevPage;
        });
      }
    } else if (sortedList.length === 0) {
        setCurrentPage(prevPage => {
            if (prevPage !== 0) {
                setPaginationDirection(null);
                return 0;
            }
            return prevPage;
        });
    }
  }, [currentConfigName, sortedList]);

  useEffect(() => {
    let timer;
    if (paginationDirection) {
      timer = setTimeout(() => {
        setPaginationDirection(null);
      }, SLIDE_ANIMATION_DURATION_MS);
    }
    return () => clearTimeout(timer);
  }, [paginationDirection]);

  const totalPages = Math.ceil(sortedList.length / ITEMS_PER_PAGE);
  const startIndex = currentPage * ITEMS_PER_PAGE;
  const endIndex = startIndex + ITEMS_PER_PAGE;

  const visiblePresets = useMemo(() => {
    return sortedList.slice(startIndex, endIndex);
  }, [sortedList, startIndex, endIndex]);

  const handlePrev = () => {
    if (currentPage > 0) {
      setPaginationDirection('prev');
      setCurrentPage((prev) => prev - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages - 1) {
      setPaginationDirection('next');
      setCurrentPage((prev) => prev + 1); // Corrected from prev - 1
    }
  };

  if (!sortedList || sortedList.length === 0) {
    return null;
  }

  const canGoPrev = currentPage > 0;
  const canGoNext = currentPage < totalPages - 1;
  const animationClass = paginationDirection === 'next' ? 'slide-in-left' :
                         paginationDirection === 'prev' ? 'slide-in-right' : '';

  return (
    <div className="preset-selector-bar">
      <button
        type="button"
        className="pagination-button"
        onClick={handlePrev}
        disabled={!canGoPrev || isLoading || !!paginationDirection}
        aria-label="Previous presets"
        title="Previous presets"
      >
        {'<'}
      </button>
      <div className={`preset-buttons-container ${animationClass}`}>
        {visiblePresets.map((preset) => {
          const isActive = preset.name === currentConfigName;
          const displayLabel = getPresetDisplayLabel(preset.name);
          return (
            <button
              type="button"
              key={preset.name}
              className={`preset-selector-button ${isActive ? 'active' : ''}`}
              onClick={() => onPresetSelect(preset.name)}
              disabled={isLoading}
              title={`Load: ${preset.name}`}
            >
              {/* Shortened label on button */}
              {displayLabel}
            </button>
          );
        })}
      </div>
      <button
        type="button"
        className="pagination-button"
        onClick={handleNext}
        disabled={!canGoNext || isLoading || !!paginationDirection}
        aria-label="Next presets"
        title="Next presets"
      >
        {'>'}
      </button>
    </div>
  );
};

PresetSelectorBar.propTypes = {
  savedConfigList: PropTypes.arrayOf(
    PropTypes.shape({
      name: PropTypes.string.isRequired,
    })
  ),
  currentConfigName: PropTypes.string,
  onPresetSelect: PropTypes.func.isRequired,
  isLoading: PropTypes.bool,
};

PresetSelectorBar.defaultProps = {
  savedConfigList: [],
  currentConfigName: null,
  isLoading: false,
};

export default PresetSelectorBar;
```

---
### `src\components\UI\UIOverlay.jsx`
```jsx
// src/components/UI/UIOverlay.jsx
import React, { useCallback, useMemo, useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';

import TopRightControls from '../Toolbars/TopRightControls';
import VerticalToolbar from '../Toolbars/VerticalToolbar';
import PanelWrapper from '../Panels/PanelWrapper';
import EnhancedControlPanel from '../Panels/EnhancedControlPanel';
import NotificationPanel from '../Panels/NotificationPanel';
import EventsPanel from '../Panels/EventsPanel';
import EnhancedSavePanel from '../Panels/EnhancedSavePanel';
import AudioControlPanel from '../Audio/AudioControlPanel';
import TokenSelectorOverlay from '../Panels/TokenSelectorOverlay';
import InfoOverlay from '../Panels/InfoOverlay';
import GlobalMIDIStatus from '../MIDI/GlobalMIDIStatus';
import AudioStatusIcon from '../Audio/AudioStatusIcon';
import PresetSelectorBar from './PresetSelectorBar';

import { useProfileSessionState } from '../../hooks/configSelectors';
import { useToast } from '../../context/ToastContext';
import { ForwardIcon as SequencerIcon } from '@heroicons/react/24/outline';

// Memoized components for performance optimization
const MemoizedTopRightControls = React.memo(TopRightControls);
const MemoizedVerticalToolbar = React.memo(VerticalToolbar);
const MemoizedGlobalMIDIStatus = React.memo(GlobalMIDIStatus);
const MemoizedAudioStatusIcon = React.memo(AudioStatusIcon);
const MemoizedPresetSelectorBar = React.memo(PresetSelectorBar);

const DEFAULT_SEQUENCER_INTERVAL = 10000; // 10 seconds

/**
 * @typedef {import('../../hooks/useUIState').UIState} UIStateHook
 * @typedef {import('../../hooks/useAudioVisualizer').AudioVisualizerAPI} AudioStateHook
 * @typedef {import('../../hooks/configSelectors').ProfileSessionState} ProfileSessionStateHook
 */

/**
 * @typedef {object} UIStatePropTypes
 * @property {string|null} activePanel - Identifier of the currently active panel (e.g., 'controls', 'notifications').
 * @property {string|null} animatingPanel - Identifier of the panel currently undergoing an open/close animation (e.g., the panel name when opening, or "closing" when closing).
 * @property {string} activeLayerTab - Identifier of the active layer control tab (e.g., 'tab1', 'tab2', 'tab3').
 * @property {boolean} infoOverlayOpen - Whether the informational overlay is currently open.
 * @property {boolean} whitelistPanelOpen - Whether the whitelist management panel is currently open (functionality might be conditional).
 * @property {() => void} closePanel - Function to close the currently active side panel.
 * @property {(tabId: string) => void} setActiveLayerTab - Function to set the active layer control tab.
 * @property {() => void} toggleInfoOverlay - Function to toggle the visibility of the informational overlay.
 * @property {() => void} toggleWhitelistPanel - Function to toggle the visibility of the whitelist panel.
 * @property {(panelName: string) => void} openPanel - Function to open a specific side panel by its identifier.
 * @property {() => void} toggleUiVisibility - Function to toggle the visibility of the main UI elements.
 * @property {boolean} isUiVisible - Whether the main UI elements (toolbars, panels) are currently set to be visible.
 * @property {(panelName: string) => void} toggleSidePanel - Function to toggle a specific side panel's visibility.
 */

/**
 * @typedef {object} AudioStatePropTypes
 * @property {boolean} isAudioActive - Whether audio reactivity is currently active.
 * @property {object} audioSettings - Current settings for audio reactivity (structure depends on `useAudioVisualizer`).
 * @property {object} analyzerData - Data from the audio analyzer (structure depends on `useAudioVisualizer`).
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setIsAudioActive - Function to set the audio reactivity state.
 * @property {React.Dispatch<React.SetStateAction<object>>} setAudioSettings - Function to set audio reactivity settings.
 */

/**
 * @typedef {object} ConfigDataPropTypes
 * @property {object} layerConfigs - Configurations for visual layers (structure depends on `VisualConfigContext`).
 * @property {Array<string>} blendModes - Array of available blend mode strings.
 * @property {Array<object>} notifications - Array of notification objects (structure depends on `useNotifications`).
 * @property {number} unreadCount - Number of unread notifications.
 * @property {object} savedReactions - Saved event reactions (structure depends on `ConfigContext`).
 * @property {boolean} canSave - Whether the current user has permissions to save configurations.
 * @property {boolean} isPreviewMode - Whether the application is currently in preview mode.
 * @property {boolean} isParentAdmin - Whether the current user is the project admin (derived from `isRadarProjectAdmin`).
 * @property {string|null} currentConfigName - Name of the currently loaded visual preset.
 * @property {boolean} isTransitioning - Whether a preset transition (e.g., fade in/out) is currently in progress.
 * @property {boolean} isBaseReady - Whether base components and initial data are considered ready for UI display.
 * @property {string} renderState - Current state of the rendering lifecycle (e.g., 'rendered', 'loading_defaults').
 * @property {boolean} canInteract - Whether the user can interact with UI elements (e.g., not in preview, profile loaded).
 * @property {string|null} currentProfileAddress - The address of the Universal Profile currently being viewed.
 * @property {boolean} [isConfigLoading] - Indicates if a configuration preset is currently being loaded.
 */

/**
 * @typedef {object} ActionsPropTypes
 * @property {() => void} onEnhancedView - Callback function for toggling fullscreen or an enhanced view mode.
 * @property {(layerId: string | number, key: string, value: any) => void} onLayerConfigChange - Callback for when a layer's configuration property changes.
 * @property {(id: string | number) => void} onMarkNotificationRead - Callback to mark a specific notification as read.
 * @property {() => void} onClearAllNotifications - Callback to clear all notifications.
 * @property {(eventType: string, reactionData: object) => void} onSaveReaction - Callback to save an event reaction configuration.
 * @property {(eventType: string) => void} onRemoveReaction - Callback to remove an event reaction configuration.
 * @property {(effectConfig: object) => Promise<string | null>} onPreviewEffect - Callback to preview a visual effect.
 * @property {(tokenId: string | object | null, layerId: string | number) => void} onTokenApplied - Callback invoked when a token is applied to a layer.
 * @property {(presetName: string) => void} onPresetSelect - Callback invoked when a preset is selected from the selector.
 * @property {(newIntervalMs: number) => void} [onSetSequencerInterval] - Optional callback to set the sequencer interval.
 */

/**
 * @typedef {object} UIOverlayProps
 * @property {UIStateHook} uiState - State and functions for managing UI visibility and panel states.
 * @property {AudioStateHook} audioState - State and functions for managing audio reactivity.
 * @property {ConfigDataPropTypes} configData - Data related to visual configurations, presets, and user permissions.
 * @property {ActionsPropTypes} actions - Callback functions for various application interactions.
 * @property {Array<{name: string}>} [passedSavedConfigList=[]] - List of saved configuration presets.
 */

/**
 * GeneralConnectPill displays a message prompting users to connect their Universal Profile
 * if no visitor UP address is detected.
 * @returns {JSX.Element | null} The pill component or null.
 */
const GeneralConnectPill = () => {
  const { visitorUPAddress } = useProfileSessionState();
  if (visitorUPAddress) return null;

  return (
    <div className="general-connect-pill">
      Create or connect a Universal Profile to save configurations, use your own tokens, and access all features.
    </div>
  );
};

/**
 * ActivePanelRenderer conditionally renders the currently active side panel based on `uiState.activePanel`.
 * @param {object} props - Component props.
 * @param {UIStateHook} props.uiState - UI state from `useUIState`.
 * @param {AudioStateHook} props.audioState - Audio state from `useAudioVisualizer`.
 * @param {ConfigDataPropTypes} props.configData - Configuration data.
 * @param {ActionsPropTypes} props.actions - Interaction callbacks.
 * @returns {JSX.Element | null} The rendered active panel or null.
 */
const ActivePanelRenderer = ({ uiState, audioState, configData, actions }) => {
    const { activePanel, animatingPanel, activeLayerTab, closePanel, setActiveLayerTab } = uiState;
    const { isAudioActive, audioSettings, analyzerData, setIsAudioActive, setAudioSettings } = audioState;
    const { blendModes, notifications, savedReactions, canSave, isPreviewMode, canInteract, currentProfileAddress } = configData;
    const { onLayerConfigChange, onMarkNotificationRead, onClearAllNotifications, onSaveReaction, onRemoveReaction, onPreviewEffect, onTokenApplied, onSetSequencerInterval } = actions;

    const handleTokenSelectorClose = useCallback(() => {
        closePanel();
    }, [closePanel]);

    const panelWrapperClassName = useMemo(() => {
        if (animatingPanel) {
            if (animatingPanel === "closing") {
                return "animating closing";
            }
            return "animating";
        }
        return "";
    }, [animatingPanel]);

    switch (activePanel) {
        case "controls":
            return (
                <PanelWrapper key="controls-panel" className={panelWrapperClassName}>
                    <EnhancedControlPanel
                        onLayerConfigChange={onLayerConfigChange}
                        blendModes={blendModes}
                        onToggleMinimize={closePanel}
                        activeTab={activeLayerTab}
                        onTabChange={setActiveLayerTab}
                        onSetSequencerInterval={onSetSequencerInterval} // Pass down the new prop
                    />
                </PanelWrapper>
            );
        case "notifications":
            return (
                <PanelWrapper key="notifications-panel" className={panelWrapperClassName}>
                    <NotificationPanel
                        notifications={notifications}
                        onClose={closePanel}
                        onMarkAsRead={onMarkNotificationRead}
                        onClearAll={onClearAllNotifications}
                    />
                </PanelWrapper>
            );
        case "events":
            return canInteract ? (
                <PanelWrapper key="events-panel" className={panelWrapperClassName}>
                    <EventsPanel
                        onSaveReaction={onSaveReaction}
                        onRemoveReaction={onRemoveReaction}
                        reactions={savedReactions}
                        onClose={closePanel}
                        readOnly={!canSave}
                        onPreviewEffect={onPreviewEffect}
                    />
                </PanelWrapper>
            ) : null;
        case "save":
            return currentProfileAddress && !isPreviewMode ? (
                <PanelWrapper key="save-panel" className={panelWrapperClassName}>
                    <EnhancedSavePanel onClose={closePanel} />
                </PanelWrapper>
            ) : null;
        case "audio":
            return (
                <PanelWrapper key="audio-panel" className={panelWrapperClassName}>
                    <AudioControlPanel
                        onClose={closePanel}
                        isAudioActive={isAudioActive}
                        setIsAudioActive={setIsAudioActive}
                        audioSettings={audioSettings}
                        setAudioSettings={setAudioSettings}
                        analyzerData={analyzerData}
                    />
                </PanelWrapper>
            );
        case "tokens":
            return canInteract ? (
                <TokenSelectorOverlay
                    key="token-selector-overlay"
                    isOpen={activePanel === "tokens"}
                    onClose={handleTokenSelectorClose}
                    onTokenApplied={onTokenApplied}
                    readOnly={!canInteract}
                />
            ) : null;
        default:
            return null;
    }
};
ActivePanelRenderer.propTypes = {
    uiState: PropTypes.object.isRequired,
    audioState: PropTypes.object.isRequired,
    configData: PropTypes.object.isRequired,
    actions: PropTypes.object.isRequired,
};
const MemoizedActivePanelRenderer = React.memo(ActivePanelRenderer);

/**
 * OverlayRenderer conditionally renders modal-like overlays (e.g., InfoOverlay).
 * @param {object} props - Component props.
 * @param {UIStateHook} props.uiState - UI state from `useUIState`.
 * @returns {JSX.Element} The rendered overlays.
 */
const OverlayRenderer = ({ uiState }) => {
    const { infoOverlayOpen, toggleInfoOverlay } = uiState;
    return (
        <>
            {infoOverlayOpen && (
                <InfoOverlay isOpen={infoOverlayOpen} onClose={toggleInfoOverlay} />
            )}
        </>
    );
};
OverlayRenderer.propTypes = {
    uiState: PropTypes.object.isRequired,
};
const MemoizedOverlayRenderer = React.memo(OverlayRenderer);

/**
 * UIOverlay is the main component responsible for rendering all user interface elements
 * that overlay the core visual canvas. This includes toolbars, panels, and modal overlays.
 * It orchestrates the visibility and interaction of these elements based on application state.
 * It now includes a preset sequencer feature with a customizable interval.
 *
 * @param {UIOverlayProps} props - The component's props.
 * @returns {JSX.Element} The rendered UIOverlay component.
 */
function UIOverlay(props) {
  const {
    uiState,
    audioState,
    configData: propConfigData,
    actions,
    passedSavedConfigList,
  } = props;

  const { addToast } = useToast();
  const { canInteract: sessionCanInteract, currentProfileAddress: sessionCurrentProfileAddress, visitorUPAddress } = useProfileSessionState();

  const configData = useMemo(() => ({
    ...propConfigData,
    canInteract: sessionCanInteract,
    currentProfileAddress: sessionCurrentProfileAddress,
  }), [propConfigData, sessionCanInteract, sessionCurrentProfileAddress]);

  const {
    isUiVisible,
    activePanel,
    toggleSidePanel,
    toggleInfoOverlay,
    toggleWhitelistPanel,
    toggleUiVisibility
  } = uiState;

  const { isAudioActive } = audioState;
  const {
    isParentAdmin,
    isPreviewMode,
    unreadCount,
    isTransitioning,
    isBaseReady,
    currentProfileAddress,
  } = configData;
  const { onEnhancedView, onPresetSelect } = actions;

  const [isSequencerActive, setIsSequencerActive] = useState(false);
  const sequencerIntervalRef = useRef(null);
  const nextPresetIndexRef = useRef(0);
  const [sequencerIntervalMs, setSequencerIntervalMs] = useState(DEFAULT_SEQUENCER_INTERVAL);


  const configDataRef = useRef(configData);
  useEffect(() => {
    configDataRef.current = configData;
  }, [configData]);

  const passedSavedConfigListRef = useRef(passedSavedConfigList);
  useEffect(() => {
    passedSavedConfigListRef.current = passedSavedConfigList;
  }, [passedSavedConfigList]);

  const onPresetSelectRef = useRef(onPresetSelect);
  useEffect(() => {
    onPresetSelectRef.current = onPresetSelect;
  }, [onPresetSelect]);


  const actualShouldShowUI = useMemo(() => {
    return isBaseReady || configData.renderState === 'prompt_connect';
  } , [isBaseReady, configData.renderState]);

  const showPresetBar = useMemo(() => {
    return actualShouldShowUI && isUiVisible && !activePanel && !!currentProfileAddress;
  }, [actualShouldShowUI, isUiVisible, activePanel, currentProfileAddress]);


  const loadNextPresetInSequence = useCallback((isInitialCall = false) => {
    const { renderState, isConfigLoading, isTransitioning, currentConfigName: currentLoadedConfigNameValue } = configDataRef.current;
    const currentPassedSavedConfigList = passedSavedConfigListRef.current;
    const currentOnPresetSelect = onPresetSelectRef.current;

    if (import.meta.env.DEV) {
        console.log(`[Sequencer LoadNext${isInitialCall ? " (Initial Call)" : " (Interval Tick)"}] Index: ${nextPresetIndexRef.current}, Conditions: isConfigLoading=${isConfigLoading}, renderState=${renderState}, isTransitioning=${isTransitioning}`);
    }

    if (isConfigLoading || renderState !== 'rendered' || isTransitioning) {
      if (import.meta.env.DEV) {
        console.log(`[Sequencer] Load SKIPPED: isConfigLoading=${isConfigLoading}, renderState=${renderState}, isTransitioning=${isTransitioning}`);
      }
      return;
    }

    if (!currentPassedSavedConfigList || currentPassedSavedConfigList.length === 0) {
        return;
    }

    let presetToLoad = currentPassedSavedConfigList[nextPresetIndexRef.current];
    let currentIndexToLoad = nextPresetIndexRef.current;

    if (presetToLoad && presetToLoad.name === currentLoadedConfigNameValue && currentPassedSavedConfigList.length > 1) {
        if (import.meta.env.DEV) {
            console.log(`[Sequencer] Next preset (${presetToLoad.name}) is same as current. Advancing index for this attempt.`);
        }
        currentIndexToLoad = (nextPresetIndexRef.current + 1) % currentPassedSavedConfigList.length;
        presetToLoad = currentPassedSavedConfigList[currentIndexToLoad];
    }

    if (presetToLoad && presetToLoad.name) {
      if (import.meta.env.DEV) {
        console.log(`[Sequencer] >>> Loading preset [${currentIndexToLoad}]: ${presetToLoad.name}`);
      }
      currentOnPresetSelect(presetToLoad.name);
      nextPresetIndexRef.current = (currentIndexToLoad + 1) % currentPassedSavedConfigList.length;
    } else {
        if (import.meta.env.DEV) {
            console.warn(`[Sequencer] Preset at index ${currentIndexToLoad} is invalid. Resetting index to 0.`);
        }
        nextPresetIndexRef.current = 0;
    }
  }, []);

  useEffect(() => {
    if (isSequencerActive) {
      const currentPassedSavedConfigList = passedSavedConfigListRef.current;
      if (!currentPassedSavedConfigList || currentPassedSavedConfigList.length === 0) {
        return;
      }
      const { renderState, isConfigLoading, isTransitioning } = configDataRef.current;
      if (!isConfigLoading && renderState === 'rendered' && !isTransitioning) {
        if (import.meta.env.DEV) console.log("[Sequencer] Attempting initial load on activation.");
        loadNextPresetInSequence(true);
      } else {
        if (import.meta.env.DEV) console.log("[Sequencer] Skipping initial load on activation, conditions not met.");
      }
    }
  }, [isSequencerActive, loadNextPresetInSequence]);

  useEffect(() => {
    if (sequencerIntervalRef.current) {
      clearInterval(sequencerIntervalRef.current);
      sequencerIntervalRef.current = null;
    }

    if (isSequencerActive) {
      const currentPassedSavedConfigList = passedSavedConfigListRef.current;
      if (!currentPassedSavedConfigList || currentPassedSavedConfigList.length === 0) {
        addToast("No saved presets available to sequence.", "warning");
        setIsSequencerActive(false);
        return;
      }
      sequencerIntervalRef.current = setInterval(() => loadNextPresetInSequence(false), sequencerIntervalMs);
    } else {
      nextPresetIndexRef.current = 0;
    }

    return () => {
      if (sequencerIntervalRef.current) {
        clearInterval(sequencerIntervalRef.current);
        sequencerIntervalRef.current = null;
      }
    };
  }, [isSequencerActive, loadNextPresetInSequence, addToast, sequencerIntervalMs]);


  const handleToggleSequencer = () => {
    if (configData.isConfigLoading) {
        addToast("Cannot toggle sequencer while a preset is loading.", "warning");
        return;
    }
    if (!configData.currentProfileAddress) {
        addToast("Connect a profile to use the preset sequencer.", "warning");
        return;
    }
    setIsSequencerActive(prev => {
        if (!prev) {
            nextPresetIndexRef.current = 0;
        }
        return !prev;
    });
  };

  const handleSetSequencerInterval = useCallback((newIntervalMs) => {
    const newInterval = Number(newIntervalMs);
    if (!isNaN(newInterval) && newInterval >= 1000) {
        setSequencerIntervalMs(newInterval);
        addToast(`Sequencer interval set to ${newInterval / 1000}s.`, "info");
    } else {
        addToast("Invalid interval. Must be at least 1000ms.", "warning");
    }
  }, [addToast]);

  const actionsWithSequencerControl = useMemo(() => ({
    ...actions,
    onSetSequencerInterval: handleSetSequencerInterval,
  }), [actions, handleSetSequencerInterval]);

  const mainUiContainerClass = `ui-elements-container ${actualShouldShowUI && isUiVisible ? "visible" : "hidden-by-opacity"}`;

  return (
    <>
      {actualShouldShowUI && (
        <MemoizedTopRightControls
          showWhitelist={false}
          isProjectAdminForWhitelist={isParentAdmin}
          showInfo={true}
          showToggleUI={true}
          showEnhancedView={true}
          onWhitelistClick={toggleWhitelistPanel}
          onInfoClick={toggleInfoOverlay}
          onToggleUI={toggleUiVisibility}
          onEnhancedView={onEnhancedView}
          isUiVisible={isUiVisible}
        />
      )}
      <div className={mainUiContainerClass}>
        {actualShouldShowUI && isUiVisible && (
          <>
            <div className="bottom-right-icons">
              <button
                className={`toolbar-icon sequencer-toggle-button ${isSequencerActive ? "active" : ""}`}
                onClick={handleToggleSequencer}
                title={isSequencerActive ? `Stop Preset Sequencer (Interval: ${sequencerIntervalMs / 1000}s)` : `Start Preset Sequencer (Interval: ${sequencerIntervalMs / 1000}s)`}
                aria-label={isSequencerActive ? "Stop Preset Sequencer" : "Start Preset Sequencer"}
                disabled={configData.isConfigLoading || !configData.currentProfileAddress}
              >
                <SequencerIcon className="icon-image" />
              </button>
              <MemoizedAudioStatusIcon isActive={isAudioActive} onClick={() => uiState.openPanel('audio')} />
              <MemoizedGlobalMIDIStatus />
            </div>
            {isPreviewMode && (
              <div className="preview-mode-indicator">
                <span>👁️</span> Preview Mode
              </div>
            )}
            <MemoizedVerticalToolbar
              activePanel={activePanel}
              setActivePanel={toggleSidePanel}
              notificationCount={unreadCount}
            />
            <MemoizedActivePanelRenderer
                uiState={uiState}
                audioState={audioState}
                configData={configData}
                actions={actionsWithSequencerControl}
            />
            {showPresetBar && (
              <MemoizedPresetSelectorBar
                savedConfigList={passedSavedConfigList}
                currentConfigName={configData.currentConfigName}
                onPresetSelect={onPresetSelect}
                isLoading={isTransitioning || configData.isConfigLoading}
              />
            )}
          </>
        )}
      </div>
      {actualShouldShowUI && (
        <MemoizedOverlayRenderer uiState={uiState} />
      )}
      {actualShouldShowUI && !visitorUPAddress && (
         <GeneralConnectPill />
      )}
    </>
  );
}

UIOverlay.propTypes = {
  /** State and functions for managing UI visibility and panel states. */
  uiState: PropTypes.object.isRequired,
  /** State and functions for managing audio reactivity. */
  audioState: PropTypes.object.isRequired,
  /** Data related to visual configurations, presets, and user permissions. */
  configData: PropTypes.object.isRequired,
  /** Callback functions for various application interactions. */
  actions: PropTypes.object.isRequired,
  /** List of saved configuration presets. */
  passedSavedConfigList: PropTypes.array,
};

UIOverlay.defaultProps = {
  passedSavedConfigList: [],
};


export default React.memo(UIOverlay);
```

---
### `src\config\fallback-config.js`
```js
// src/config/fallback-config.js

// No need to import specific images here if using tokenAssignments keys

/**
 * Default configuration object used when no specific profile configuration
 * (named preset or default pointer) is loaded.
 * Defines initial layer parameters and assigns default demo tokens.
 */
export default {
  version: "1.1", // Increment version number if desired
  layers: {
    // Keep the desired visual parameters from the original showcase/fallback
    1: { // Bottom Layer
      enabled: true,
      speed: 0.01,
      size: 4.7,
      xaxis: -629,
      yaxis: -1240,
      drift: 0.4,
      direction: -1,
      angle: -194.21,
      blendMode: "exclusion",
      driftSpeed: 0.3,
      opacity: 0.25,
    },
    2: { // Middle Layer
      enabled: true,
      speed: 0.01,
      size: 2,
      xaxis: 1771,
      yaxis: 1371,
      drift: 0.5,
      direction: -1,
      angle: -90,
      blendMode: "overlay",
      driftSpeed: 0.4,
      opacity: 1,
    },
    3: { // Top Layer
      enabled: true,
      speed: 0.01,
      size: 1.8,
      xaxis: 2229,
      yaxis: 1886,
      drift: 15.4,
      direction: 1,
      angle: 63.385,
      blendMode: "normal",
      driftSpeed: 0.3,
      opacity: 1,
    },
  },
  // --- UPDATED: Use tokenAssignments to specify the default visuals ---
  tokenAssignments: {
    // Assign the key for Layer4.webp to all visual layers
    // Assuming the key in demoAssetMap is "DEMO_LAYER_4"
    1: "DEMO_LAYER_4", // Bottom Layer uses Layer4.webp
    2: "DEMO_LAYER_4", // Middle Layer uses Layer4.webp
    3: "DEMO_LAYER_4", // Top Layer uses Layer4.webp
  },
  // --- REMOVED the potentially confusing 'assets' property ---
  // assets: { ... },
  reactions: {}, // Keep default empty reactions
};
```

---
### `src\config\global-config.js`
```js
import { keccak256, stringToBytes, numberToHex, bytesToHex } from "viem";
import { LSP1_TYPE_IDS as StandardLSP1TypeIds } from "@lukso/lsp-smart-contracts";

/**
 * Global configuration constants and helper functions for the RADAR application.
 * Defines ERC725Y storage keys, IPFS gateway, LSP1 event type mappings,
 * blend modes, user roles, and key generation functions.
 */

// IPFS Gateway Configuration
export const IPFS_GATEWAY =
  import.meta.env.VITE_IPFS_GATEWAY ||
  "https://api.universalprofile.cloud/ipfs/";

// RADAR Application Specific ERC725Y Storage Keys
export const RADAR_NAMED_CONFIG_MAP_KEY_PREFIX = 
  "0x44f0a644f86a60b95927";
export const RADAR_SAVED_CONFIG_LIST_KEY =
  "0xb705191a8b41d1f6b4bd88156334f8218a5d70f6a579c9c5a0a6871d2e398a9a";
export const RADAR_DEFAULT_CONFIG_NAME_KEY =
  "0xaf9518865d704640a115a21518b109f9a37c0ab1f6865c84d6a150f5f6693e19";
export const RADAR_MIDI_MAP_KEY =
  "0x9e5e3b0c7c8a4f6d1d9d63429a9743e3f38270f5a8c2633e7e6dfb01fc17e3bd";
export const RADAR_EVENT_REACTIONS_KEY =
  "0x0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b";
export const RADAR_WHITELIST_KEY =
  "0x5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b";

/**
 * The Universal Profile address designated as the RADAR project administrator.
 * This address has special privileges, e.g., managing the global collection whitelist.
 * @type {string}
 */
export const RADAR_OFFICIAL_ADMIN_ADDRESS = import.meta.env.VITE_RADAR_OFFICIAL_ADMIN_ADDRESS || "0x0000000000000000000000000000000000000000"; // Fallback to zero address

if (!import.meta.env.VITE_RADAR_OFFICIAL_ADMIN_ADDRESS && import.meta.env.DEV) {
  console.warn(
    "⚠️ [RADAR Config] VITE_RADAR_OFFICIAL_ADMIN_ADDRESS is not defined in your .env file. Admin-specific features (like the Whitelist Panel if enabled) will not be available to any user. Please set this variable to your designated admin UP address."
  );
}


// Helper Functions for Dynamic ERC725Y Keys
/**
 * Generates the ERC725Y key for an element in the RADAR.SavedConfigurationList array.
 * @param {number} index - The index of the element in the array.
 * @returns {string} The ERC725Y key.
 * @throws {Error} If the index is invalid.
 */
export function getRadarConfigListElementKey(index) {
  if (typeof index !== "number" || index < 0 || !Number.isInteger(index))
    throw new Error("Invalid index for Radar Config List");
  const arrayKeyPrefix = RADAR_SAVED_CONFIG_LIST_KEY.substring(0, 34);
  const hexIndex = numberToHex(BigInt(index), { size: 16 }).slice(2);
  return `${arrayKeyPrefix}${hexIndex}`;
}

/**
 * Generates the ERC725Y key for a named configuration in the RADAR.NamedConfiguration map.
 * Includes a workaround for potential issues with `keccak256` output in Viem.
 * @param {string} configName - The name of the configuration.
 * @returns {string} The ERC725Y key.
 * @throws {Error} If the configName is invalid or key generation fails.
 */
export function getNamedConfigMapKey(configName) {
  if (!configName || typeof configName !== "string") {
    // console.error(`[getNamedConfigMapKey] Invalid configName input:`, configName, `(Type: ${typeof configName})`);
    throw new Error("Invalid configName");
  }

  // console.log(`[getNamedConfigMapKey] Input configName: "${configName}" (Length: ${configName.length})`);

  const nameBytes = stringToBytes(configName);
  // console.log(`[getNamedConfigMapKey] nameBytes (output of stringToBytes):`, nameBytes);

  const nameHashBytesRaw = keccak256(nameBytes, "bytes");
  // console.log(`[getNamedConfigMapKey] nameHashBytesRaw (direct output of keccak256):`, nameHashBytesRaw);
  // console.log(`[getNamedConfigMapKey] Is nameHashBytesRaw Uint8Array?`, nameHashBytesRaw instanceof Uint8Array);
  // console.log(`[getNamedConfigMapKey] Does nameHashBytesRaw contain undefined?`, [...nameHashBytesRaw].some(x => typeof x === 'undefined'));


  // --- DEVELOPER NOTE & WORKAROUND for Viem/keccak256 output issue ---
  //
  // **Symptom Observed:**
  // An error "Generated nameHashPart contains invalid characters: 00undefined..." was encountered.
  // This indicated that `nameHashPart`, which should be a pure hexadecimal string, contained
  // the literal string "undefined".
  //
  // **Diagnosis Steps & Hypothesis:**
  // 1. Logged intermediate values: `configName`, `nameBytes`, `nameHashBytesRaw` (direct output of `keccak256`),
  //    `nameHashHex` (output of `bytesToHex`), and `nameHashPart`.
  // 2. The critical observation would be that `nameHashHex` (output of `bytesToHex(nameHashBytesRaw)`)
  //    itself contained "undefined" literals.
  // 3. This led to the hypothesis that `nameHashBytesRaw` (the output of `viem/keccak256`)
  //    was not a "clean" or standard `Uint8Array` as expected by `bytesToHex`.
  //    It might have been an array-like object, a proxy, or a `Uint8Array` instance
  //    that somehow contained actual `undefined` values within its byte sequence.
  //    `bytesToHex` would then attempt to convert these `undefined` values into a hex
  //    representation, resulting in the literal string "undefined".
  //
  // **Verification (Conceptual - how one would debug this):**
  //   - `console.log(nameHashBytesRaw instanceof Uint8Array);` // Might return true, but still be problematic.
  //   - `console.log([...nameHashBytesRaw].some(x => typeof x === 'undefined'));` // Check for actual undefined elements.
  //   - Inspecting `nameHashBytesRaw` in the debugger.
  //
  // **The Fix (Workaround):**
  // Explicitly create a new, standard `Uint8Array` from the raw output of `keccak256`.
  // This ensures that:
  //   a) The object passed to `bytesToHex` is a true native `Uint8Array`.
  //   b) Any `undefined` values within `nameHashBytesRaw` are converted to `0` (zero),
  //      which is a valid byte value and will be correctly hex-encoded by `bytesToHex`.
  //
  // This workaround proved effective in resolving the "invalid characters" error.
  // It's a defensive measure against potential inconsistencies in how typed arrays
  // are handled or returned by underlying libraries or due to environment/polyfill interactions.
  //
  const nameHashBytes = new Uint8Array(nameHashBytesRaw);
  // --- END DEVELOPER NOTE & WORKAROUND ---

  // console.log(`[getNamedConfigMapKey] nameHashBytes (after new Uint8Array()):`, nameHashBytes);
  // console.log(`[getNamedConfigMapKey] Is nameHashBytes (after wrap) Uint8Array?`, nameHashBytes instanceof Uint8Array);
  // console.log(`[getNamedConfigMapKey] Does nameHashBytes (after wrap) contain undefined?`, [...nameHashBytes].some(x => typeof x === 'undefined'));

  const nameHashHex = bytesToHex(nameHashBytes);
  // console.log(`[getNamedConfigMapKey] nameHashHex (output of bytesToHex(nameHashBytes)): "${nameHashHex}" (Length: ${nameHashHex.length})`);

  const nameHashPart = nameHashHex.slice(2, 42);
  // console.log(`[getNamedConfigMapKey] nameHashPart (slice(2, 42) of nameHashHex): "${nameHashPart}" (Length: ${nameHashPart.length})`);

  const mapKey = `${RADAR_NAMED_CONFIG_MAP_KEY_PREFIX}0000${nameHashPart}`;
  if (mapKey.length !== 66 || !mapKey.startsWith("0x")) {
    throw new Error(`Generated mapKey is invalid (length/prefix): ${mapKey}`);
  }
  if (!/^[0-9a-fA-F]+$/.test(nameHashPart)) {
    // console.error(`[getNamedConfigMapKey] Regex test failed for nameHashPart: "${nameHashPart}"`);
    throw new Error(
      `Generated nameHashPart contains invalid characters: ${nameHashPart}`,
    );
  }
  return mapKey;
}

// LSP1 Event Type Mappings
export const EVENT_TYPE_MAP = {
  lyx_received: StandardLSP1TypeIds.LSP0ValueReceived,
  follower_gained: "0x71e02f9f05bcd5816ec4f3134aa2e5a916669537ec6c77fe66ea595fabc2d51a", // Custom
  follower_lost: "0x9d3c0b4012b69658977b099bdaa51eff0f0460f421fba96d15669506c00d1c4f", // Custom
  lsp7_received: "0x20804611b3e2ea21c480dc465142210acf4a2485947541770ec1fb87dee4a55c", // Custom
  lsp8_received: "0x0b084a55ebf70fd3c06fd755269dac2212c4d3f0f4d09079780bfa50c1b2984d", // Custom
};
export const TYPE_ID_TO_EVENT_MAP = Object.fromEntries(
  Object.entries(EVENT_TYPE_MAP).map(([eventName, typeId]) => [
    typeId.toLowerCase(),
    eventName,
  ]),
);

// Canvas Blend Modes
export const BLEND_MODES = [
  "normal", "multiply", "screen", "overlay", "darken",
  "lighten", "color-dodge", "color-burn", "difference", "exclusion",
];

// User Roles (Legacy, primarily for conceptual understanding, session logic is more nuanced)
export const USER_ROLES = {
  PROFILE_OWNER: "profile_owner",
  VISITOR: "visitor",
};
```

---
### `src\config\midiConstants.js`
```js
export const INTERPOLATED_MIDI_PARAMS = ['xaxis', 'yaxis', 'angle'];
```

---
### `src\config\RADAR-erc725y-schema.json`
```json
[
  {
    "name": "RADAR.NamedConfiguration:<configName>",
    "key": "0x44f0a644f86a60b959270000<bytes20 nameHash>",
    "keyType": "Mapping",
    "valueType": "bytes",
    "valueContent": "JSONURL"
  },
  {
    "name": "RADAR.SavedConfigurationList[]",
    "key": "0xb705191a8b41d1f6b4bd88156334f8218a5d70f6a579c9c5a0a6871d2e398a9a",
    "keyType": "Array",
    "valueType": "string",
    "valueContent": "String"
  },
  {
    "name": "RADAR.DefaultConfigurationName",
    "key": "0xaf9518865d704640a115a21518b109f9a37c0ab1f6865c84d6a150f5f6693e19",
    "keyType": "Singleton",
    "valueType": "string",
    "valueContent": "String"
  },
  {
    "name": "RADAR.MIDI.ParameterMap",
    "key": "0x9e5e3b0c7c8a4f6d1d9d63429a9743e3f38270f5a8c2633e7e6dfb01fc17e3bd",
    "keyType": "Singleton",
    "valueType": "bytes",
    "valueContent": "JSONURL"
  },
  {
    "name": "RADAR.EventReactions",
    "key": "0x0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b",
    "keyType": "Singleton",
    "valueType": "bytes",
    "valueContent": "JSONURL"
  },
  {
    "name": "RADAR.WhitelistedCollections",
    "key": "0x5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b",
    "keyType": "Singleton",
    "valueType": "bytes",
    "valueContent": "JSONURL"
  }
]
```

---
### `src\config\uiConstants.js`
```js
/** Color for the canvas click ping effect. */
export const PING_COLOR = "var(--color-primary, #00FFCC)";

/** Stroke width for the canvas click ping effect circle. */
export const PING_STROKE_WIDTH = 1.5;

/** CSS selectors for elements that should NOT trigger the canvas click ping effect. */
export const NO_PING_SELECTORS = ['.ui-container', '.status-display', '.fps-counter'].join(', ');
```

---
### `src\context\ConfigContext.jsx`
```jsx
// src/context/ConfigContext.jsx
import React, {
  createContext,
  useContext,
  useMemo,
  // Removed useState, useEffect, useCallback, useRef as they are not directly used in this file
} from "react";
import PropTypes from "prop-types";

import useConfigState from "../hooks/useConfigState"; // Local hook
import { useUserSession } from "./UserSessionContext"; // Local context

/**
 * @typedef {import('../hooks/useConfigState').ConfigStateAPI} ConfigContextValue - The shape of the context value, derived from `useConfigState`.
 * This includes state related to the ConfigurationService instance, global settings like
 * event reactions and MIDI maps, their loading/saving status, and pending changes.
 */

/**
 * Default values for the ConfigContext.
 * These values are used if a component tries to consume the context
 * without a `ConfigProvider` higher up in the tree.
 * @type {ConfigContextValue}
 */
const defaultConfigContextValue = {
  configServiceInstanceReady: false,
  configServiceRef: { current: null }, // React.RefObject needs a 'current' property
  savedReactions: {},
  midiMap: {},
  isSavingGlobal: false,
  globalSaveError: null,
  globalSaveSuccess: false,
  isLoadingGlobals: false,
  globalLoadError: null,
  hasPendingChanges: false,
  setHasPendingChanges: () => {
    if (import.meta.env.DEV) {
      console.warn("setHasPendingChanges called on default ConfigContext value. Ensure ConfigProvider is an ancestor.");
    }
  },
  saveGlobalReactions: async () => {
    if (import.meta.env.DEV) {
      console.warn("saveGlobalReactions called on default ConfigContext value.");
    }
    return { success: false, error: "Provider not initialized" };
  },
  saveGlobalMidiMap: async () => {
    if (import.meta.env.DEV) {
      console.warn("saveGlobalMidiMap called on default ConfigContext value.");
    }
    return { success: false, error: "Provider not initialized" };
  },
  updateSavedReaction: () => {
    if (import.meta.env.DEV) {
      console.warn("updateSavedReaction called on default ConfigContext value.");
    }
  },
  deleteSavedReaction: () => {
    if (import.meta.env.DEV) {
      console.warn("deleteSavedReaction called on default ConfigContext value.");
    }
  },
  updateMidiMap: () => {
    if (import.meta.env.DEV) {
      console.warn("updateMidiMap called on default ConfigContext value.");
    }
  },
};

const ConfigContext = createContext(defaultConfigContextValue);

/**
 * Provides configuration-related state to its children components.
 * This includes the ConfigurationService instance, global settings (reactions, MIDI map),
 * their loading/saving status, and management of pending changes.
 * It utilizes the `useConfigState` hook for its core logic, driven by the
 * `hostProfileAddress` from `UserSessionContext`.
 *
 * @param {object} props - The component props.
 * @param {React.ReactNode} props.children - The child components to be rendered within this provider.
 * @returns {JSX.Element} The ConfigProvider component.
 */
export const ConfigProvider = ({ children }) => {
  const { hostProfileAddress } = useUserSession();
  const configStateHookValues = useConfigState(hostProfileAddress); // Renamed for clarity

  // The contextValue directly uses all properties returned by useConfigState.
  // useMemo is appropriate here because configStateHookValues is memoized by useConfigState itself.
  const contextValue = useMemo(
    () => ({
      ...configStateHookValues,
    }),
    [configStateHookValues]
  );

  return (
    <ConfigContext.Provider value={contextValue}>
      {children}
    </ConfigContext.Provider>
  );
};

ConfigProvider.propTypes = {
    children: PropTypes.node.isRequired,
};

/**
 * Custom hook to consume the `ConfigContext`.
 * Provides access to global configuration state and management functions.
 * Throws an error if used outside of a `ConfigProvider`.
 *
 * @returns {ConfigContextValue} The current value of the ConfigContext.
 * @throws {Error} If the hook is not used within a `ConfigProvider`.
 */
export const useConfig = () => {
  const context = useContext(ConfigContext);
  if (context === undefined) {
    // Error for developers if context is used incorrectly
    const err = new Error("useConfig must be used within a ConfigProvider component.");
    if (import.meta.env.DEV) {
        // Log additional details in development for easier debugging
        console.error("useConfig context details: Attempted to use context but found undefined. This usually means ConfigProvider is missing as an ancestor of the component calling useConfig.", err.stack);
    }
    throw err;
  }
  return context;
};
```

---
### `src\context\MIDIContext.jsx`
```jsx
// src/context/MIDIContext.jsx
import React, {
  createContext, useContext, useState, useEffect, useCallback, useRef, useMemo
} from 'react';
import PropTypes from 'prop-types';

import { useConfig } from './ConfigContext'; // Local context
import { useUpProvider } from './UpProvider'; // Local context
import { usePresetManagement } from './PresetManagementContext'; // Local context

import { RADAR_MIDI_MAP_KEY } from '../config/global-config'; // Local config
import { sliderParams } from '../components/Panels/EnhancedControlPanel'; // Local component-specific config

import { hexToString } from 'viem'; // Third-party library

// Constants & Config
const MAX_MONITOR_ENTRIES = 100;
const PENDING_ACTION_EXPIRY_MS = 1000; // ms for pending layer/param selection to auto-clear
const MIDI_CONNECT_TIMEOUT_MS = 10000; // ms to wait for MIDI connection before timing out
const CATCH_MODE_NORMALIZATION_EPSILON = 0.01; // Tolerance for considering MIDI value "at" preset target for catch mode

/**
 * @typedef {object} MIDIDevice
 * @property {string} id - The unique ID of the MIDI device.
 * @property {string} name - The name of the MIDI device.
 * @property {string} manufacturer - The manufacturer of the MIDI device.
 * @property {'connected'|'disconnected'} state - The connection state of the MIDI device.
 */

/**
 * @typedef {object} MIDIMappingData
 * @property {'cc'|'note'|'pitchbend'} type - The type of MIDI message.
 * @property {number} number - The MIDI note number or CC number.
 * @property {number} channel - The MIDI channel (0-15).
 */

/**
 * @typedef {Object.<string, MIDIMappingData>} LayerParamMappings
 * Key is parameter name (e.g., 'opacity', 'speed'), value is `MIDIMappingData`.
 */

/**
 * @typedef {Object.<string, LayerParamMappings>} ControllerMIDIMap
 * Key is layer ID string (e.g., '1', '2', '3'), value is `LayerParamMappings`.
 */

/**
 * @typedef {object} MIDIMonitorEntry
 * @property {string} timestamp - Formatted timestamp of the MIDI message.
 * @property {number} status - The MIDI status byte.
 * @property {number} data1 - The first MIDI data byte.
 * @property {number} data2 - The second MIDI data byte.
 * @property {number} channel - The MIDI channel (1-16).
 * @property {string} type - The human-readable type of the MIDI message.
 */

/**
 * @typedef {object} CatchModeParamState
 * @property {number} value - The target parameter value from the loaded preset (actual scale, not normalized).
 * @property {boolean} caught - True if the physical MIDI control has "caught up" to or passed this value.
 * @property {number | null} lastMidiValue - The last known normalized (0-1) MIDI value for this parameter, used for crossing detection.
 */

/**
 * @typedef {Object.<string, CatchModeParamState>} CatchModeTargetValues
 * An object where keys are strings in the format 'layerId_paramName' (e.g., '1_speed'),
 * and values are `CatchModeParamState` objects. This state manages the soft takeover
 * behavior for each MIDI-mapped parameter after a preset load.
 */

/**
 * @typedef {object} MIDIContextValue
 * @property {MIDIAccess | null} midiAccess - The raw MIDIAccess object from the Web MIDI API.
 * @property {boolean} isConnected - True if at least one MIDI input device is connected.
 * @property {boolean} isConnecting - True if a MIDI connection attempt is currently in progress.
 * @property {Error | string | null} error - Any error related to MIDI connection or setup.
 * @property {Array<MIDIDevice>} midiInputs - An array of available MIDI input devices.
 * @property {ControllerMIDIMap} midiMap - The active MIDI controller mappings loaded from the user's profile or being built.
 * @property {Object.<string, {layerSelect?: MIDIMappingData}>} layerMappings - Mappings for layer selection via MIDI. (Structure might need refinement based on usage)
 * @property {object} globalMappings - Mappings for global controls via MIDI. (Structure might need refinement)
 * @property {{param: string, layer: string|number} | null} midiLearning - Object indicating the parameter and layer currently in MIDI learn mode, or null.
 * @property {string|number|null} learningLayer - The layer ID currently in MIDI learn mode for layer selection, or null.
 * @property {number} selectedChannel - The currently selected MIDI channel filter (0 for Omni, 1-16 for specific channels).
 * @property {Array<MIDIMonitorEntry>} midiMonitorData - An array of recent MIDI messages for display in the monitor.
 * @property {boolean} showMidiMonitor - Whether the MIDI monitor UI should be visible.
 * @property {{layer: number, timestamp: number} | null} pendingLayerSelect - Information about a pending layer selection action triggered by MIDI.
 * @property {{layer: number, param: string, value: number, timestamp: number} | null} pendingParamUpdate - Information about a pending parameter update action triggered by MIDI.
 * @property {() => Promise<MIDIAccess | null>} connectMIDI - Function to initiate connection to MIDI devices.
 * @property {(forceFullDisconnect?: boolean) => void} disconnectMIDI - Function to disconnect from MIDI devices.
 * @property {(param: string, layer: string|number) => void} startMIDILearn - Function to start MIDI learn mode for a specific parameter and layer.
 * @property {() => void} stopMIDILearn - Function to stop MIDI learn mode for parameters.
 * @property {(layer: string|number) => void} startLayerMIDILearn - Function to start MIDI learn mode for layer selection.
 * @property {() => void} stopLayerMIDILearn - Function to stop MIDI learn mode for layer selection.
 * @property {() => void} clearAllMappings - Function to clear all stored MIDI mappings for the current controller.
 * @property {(channel: number) => void} setChannelFilter - Function to set the MIDI channel filter.
 * @property {() => void} clearMIDIMonitor - Function to clear the MIDI monitor data.
 * @property {(layer: string|number, mappingData: MIDIMappingData) => void} mapLayerToMIDI - Function to map a MIDI control to layer selection.
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setShowMidiMonitor - Function to toggle the visibility of the MIDI monitor.
 * @property {() => void} clearPendingActions - Function to clear any pending layer selection or parameter update actions.
 * @property {(param: string, layer: string|number, mappingData: MIDIMappingData) => void} mapParameterToMIDI - Function to map a MIDI control to a specific parameter on a layer.
 */

/** @type {MIDIContextValue} */
const defaultContextValue = {
  midiAccess: null,
  isConnected: false,
  isConnecting: false,
  error: null,
  midiInputs: [],
  midiMap: {}, // Represents activeControllerMidiMap
  layerMappings: { "1": {}, "2": {}, "3": {} },
  globalMappings: {},
  midiLearning: null,
  learningLayer: null,
  selectedChannel: 0,
  midiMonitorData: [],
  showMidiMonitor: false,
  pendingLayerSelect: null,
  pendingParamUpdate: null,
  connectMIDI: async () => { if (import.meta.env.DEV) console.warn("connectMIDI called on default MIDIContext"); return null; },
  disconnectMIDI: () => { if (import.meta.env.DEV) console.warn("disconnectMIDI called on default MIDIContext"); },
  startMIDILearn: () => { if (import.meta.env.DEV) console.warn("startMIDILearn called on default MIDIContext"); },
  stopMIDILearn: () => { if (import.meta.env.DEV) console.warn("stopMIDILearn called on default MIDIContext"); },
  startLayerMIDILearn: () => { if (import.meta.env.DEV) console.warn("startLayerMIDILearn called on default MIDIContext"); },
  stopLayerMIDILearn: () => { if (import.meta.env.DEV) console.warn("stopLayerMIDILearn called on default MIDIContext"); },
  clearAllMappings: () => { if (import.meta.env.DEV) console.warn("clearAllMappings called on default MIDIContext"); },
  setChannelFilter: () => { if (import.meta.env.DEV) console.warn("setChannelFilter called on default MIDIContext"); },
  clearMIDIMonitor: () => { if (import.meta.env.DEV) console.warn("clearMIDIMonitor called on default MIDIContext"); },
  mapLayerToMIDI: () => { if (import.meta.env.DEV) console.warn("mapLayerToMIDI called on default MIDIContext"); },
  setShowMidiMonitor: () => { if (import.meta.env.DEV) console.warn("setShowMidiMonitor called on default MIDIContext"); },
  clearPendingActions: () => { if (import.meta.env.DEV) console.warn("clearPendingActions called on default MIDIContext"); },
  mapParameterToMIDI: () => { if (import.meta.env.DEV) console.warn("mapParameterToMIDI called on default MIDIContext"); },
};

const MIDIContext = createContext(defaultContextValue);

/**
 * Normalizes a raw MIDI value (0-127 for CC/Note, 0-16383 for Pitch Bend) to a 0-1 range.
 * @param {number} value - The raw MIDI value.
 * @param {'cc' | 'note' | 'pitchbend'} [type='cc'] - The type of MIDI message.
 * @returns {number} The normalized value (0-1).
 */
const normalizeMIDIValue = (value, type = 'cc') => {
  if (type === 'pitchbend') {
    return Math.max(0, Math.min(1, value / 16383)); // 14-bit range for pitch bend
  }
  return Math.max(0, Math.min(1, value / 127)); // 7-bit range for CC and Note Velocity
};

/**
 * Converts a MIDI status byte to a human-readable message type string.
 * @param {number} status - The MIDI status byte.
 * @returns {string} The human-readable MIDI message type.
 */
const getMidiMessageType = (status) => {
  const type = status & 0xF0; // Mask out channel bits
  switch (type) {
    case 0x80: return 'Note Off';
    case 0x90: return 'Note On';
    case 0xA0: return 'Poly Aftertouch';
    case 0xB0: return 'Control Change';
    case 0xC0: return 'Program Change';
    case 0xD0: return 'Channel Aftertouch';
    case 0xE0: return 'Pitch Bend';
    case 0xF0: // System Common Messages
      switch (status) { // Check full status byte for specific system messages
        case 0xF0: return 'SysEx Start';
        case 0xF1: return 'MIDI Time Code Qtr Frame';
        case 0xF2: return 'Song Position Pointer';
        case 0xF3: return 'Song Select';
        // 0xF4, 0xF5 are undefined
        case 0xF6: return 'Tune Request';
        case 0xF7: return 'SysEx End';
        // System Real-Time Messages
        case 0xF8: return 'Timing Clock';
        // 0xF9 is undefined
        case 0xFA: return 'Start';
        case 0xFB: return 'Continue';
        case 0xFC: return 'Stop';
        // 0xFD is undefined
        case 0xFE: return 'Active Sensing';
        case 0xFF: return 'System Reset';
        default: return 'System Common'; // For unlisted 0xFx messages
      }
    default: return `Unknown (${type.toString(16)})`;
  }
};


/**
 * Provides MIDI connectivity, mapping, learning, and monitoring capabilities to the application.
 * It manages access to MIDI devices, handles incoming messages, allows mapping MIDI controls
 * to application parameters, and supports a "soft takeover" or "parameter catch" mode
 * to prevent value jumps when presets are loaded.
 *
 * @param {object} props - The component props.
 * @param {React.ReactNode} props.children - The child components to be rendered within this provider.
 * @returns {JSX.Element} The MIDIProvider component.
 */
export function MIDIProvider({ children }) {
  const {
    updateMidiMap: configUpdateMidiMap, // This is from ConfigContext, used to persist the controller's map
    configServiceRef,
    configServiceInstanceReady,
  } = useConfig();
  const { accounts } = useUpProvider();
  const controllerAddress = useMemo(() => accounts?.[0], [accounts]); // Address of the UP controlling the visuals

  const { configLoadNonce, loadedLayerConfigsFromPreset } = usePresetManagement();

  /** @type {[MIDIAccess | null, React.Dispatch<React.SetStateAction<MIDIAccess|null>>]} */
  const [midiAccess, setMidiAccess] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  /** @type {[Error | string | null, React.Dispatch<React.SetStateAction<Error|string|null>>]} */
  const [error, setError] = useState(null);
  /** @type {[Array<MIDIDevice>, React.Dispatch<React.SetStateAction<Array<MIDIDevice>>>]} */
  const [midiInputs, setMidiInputs] = useState([]);
  /** @type {[Object.<string, {layerSelect?: MIDIMappingData}>, React.Dispatch<React.SetStateAction<Object.<string, {layerSelect?: MIDIMappingData}>>>]} */
  const [layerMappings, setLayerMappings] = useState({ "1": {}, "2": {}, "3": {} }); // Local, ephemeral mappings for UI interaction
  /** @type {[object, React.Dispatch<React.SetStateAction<object>>]} */
  const [globalMappings, setGlobalMappings] = useState({}); // Local, ephemeral mappings
  /** @type {[{param: string, layer: string|number} | null, React.Dispatch<React.SetStateAction<{param: string, layer: string|number} | null>>]} */
  const [midiLearning, setMidiLearning] = useState(null);
  /** @type {[string|number|null, React.Dispatch<React.SetStateAction<string|number|null>>]} */
  const [learningLayer, setLearningLayer] = useState(null);
  const [selectedChannel, setSelectedChannel] = useState(0); // 0 for Omni
  /** @type {[Array<MIDIMonitorEntry>, React.Dispatch<React.SetStateAction<Array<MIDIMonitorEntry>>>]} */
  const [midiMonitorData, setMidiMonitorData] = useState([]);
  const [showMidiMonitor, setShowMidiMonitor] = useState(false);
  /** @type {[{layer: number, timestamp: number} | null, React.Dispatch<React.SetStateAction<{layer: number, timestamp: number} | null>>]} */
  const [pendingLayerSelect, setPendingLayerSelect] = useState(null);
  /** @type {[{layer: number, param: string, value: number, timestamp: number} | null, React.Dispatch<React.SetStateAction<{layer: number, param: string, value: number, timestamp: number} | null>>]} */
  const [pendingParamUpdate, setPendingParamUpdate] = useState(null);
  /** @type {[ControllerMIDIMap, React.Dispatch<React.SetStateAction<ControllerMIDIMap>>]} */
  const [activeControllerMidiMap, setActiveControllerMidiMap] = useState({}); // The map loaded from/saved to the controller's UP

  /** @type {[CatchModeTargetValues, React.Dispatch<React.SetStateAction<CatchModeTargetValues>>]} */
  const [catchModeTargetValues, setCatchModeTargetValues] = useState({});

  /** @type {React.RefObject<CatchModeTargetValues>} */
  const catchModeTargetValuesRef = useRef(catchModeTargetValues);
  /** @type {React.RefObject<ControllerMIDIMap>} */
  const activeControllerMidiMapRef = useRef(activeControllerMidiMap);
  /** @type {React.RefObject<Object.<string, {layerSelect?: MIDIMappingData}>>} */
  const layerMappingsRef = useRef(layerMappings);
  /** @type {React.RefObject<object>} */
  const globalMappingsRef = useRef(globalMappings);
  /** @type {React.RefObject<{param: string, layer: string|number} | null>} */
  const midiLearningRef = useRef(midiLearning);
  /** @type {React.RefObject<string|number|null>} */
  const learningLayerRef = useRef(learningLayer);
  /** @type {React.RefObject<number>} */
  const selectedChannelRef = useRef(selectedChannel);
  /** @type {React.RefObject<boolean>} */
  const connectionInProgressRef = useRef(false);
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const pendingTimeoutRef = useRef(null);
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const connectTimeoutRef = useRef(null);
  /** @type {React.RefObject<boolean>} */
  const isUnmountingRef = useRef(false);
  /** @type {React.RefObject<MIDIAccess | null>} */
  const midiAccessRefForCallbacks = useRef(midiAccess);
  /** @type {React.RefObject<((message: WebMidi.MIDIInputEvent) => void) | null>} */
  const handleMIDIMessageRef = useRef(null); // Will hold the memoized handleMIDIMessage

  useEffect(() => { activeControllerMidiMapRef.current = activeControllerMidiMap; }, [activeControllerMidiMap]);
  useEffect(() => { catchModeTargetValuesRef.current = catchModeTargetValues; }, [catchModeTargetValues]);
  useEffect(() => { midiAccessRefForCallbacks.current = midiAccess; }, [midiAccess]);
  useEffect(() => { layerMappingsRef.current = layerMappings; }, [layerMappings]);
  useEffect(() => { globalMappingsRef.current = globalMappings; }, [globalMappings]);
  useEffect(() => { midiLearningRef.current = midiLearning; }, [midiLearning]);
  useEffect(() => { learningLayerRef.current = learningLayer; }, [learningLayer]);
  useEffect(() => { selectedChannelRef.current = selectedChannel; }, [selectedChannel]);

  // Initialize catch mode targets when a new preset is loaded
  useEffect(() => {
    if (configLoadNonce > 0 && loadedLayerConfigsFromPreset && activeControllerMidiMapRef.current) {
      if (import.meta.env.DEV) {
        console.log(`[MIDIContext] Preset loaded (nonce: ${configLoadNonce}). Initializing catch mode targets.`);
      }
      const newCatchTargets = {};
      for (const layerIdStr in activeControllerMidiMapRef.current) {
        const layerParams = activeControllerMidiMapRef.current[layerIdStr];
        if (layerParams) {
          for (const paramName in layerParams) {
            const presetValue = loadedLayerConfigsFromPreset[layerIdStr]?.[paramName];
            if (typeof presetValue === 'number') {
              const catchKey = `${layerIdStr}_${paramName}`;
              newCatchTargets[catchKey] = {
                value: presetValue,
                caught: false,
                lastMidiValue: null,
              };
            } else if (import.meta.env.DEV && activeControllerMidiMapRef.current[layerIdStr]?.[paramName]) {
              // console.warn(`[MIDIContext Catch Init] No preset value for mapped L${layerIdStr}-${paramName}. It won't enter catch mode.`);
            }
          }
        }
      }
      setCatchModeTargetValues(newCatchTargets);
    }
  }, [configLoadNonce, loadedLayerConfigsFromPreset]);

  // Handle forced end of loading (e.g., from external event)
  useEffect(() => {
    const handleForceEndLoading = () => {
      if (connectionInProgressRef.current) {
        if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current);
        setIsConnecting(false);
        connectionInProgressRef.current = false;
        setError("Connection attempt force-ended.");
        if (import.meta.env.DEV) console.log("[MIDIContext] Connection attempt force-ended by event.");
      }
    };
    document.addEventListener('force-end-loading', handleForceEndLoading);
    return () => document.removeEventListener('force-end-loading', handleForceEndLoading);
  }, []); // No dependencies, runs once

  // Auto-clear pending actions after a timeout
  useEffect(() => {
    if (pendingLayerSelect || pendingParamUpdate) {
      if (pendingTimeoutRef.current) clearTimeout(pendingTimeoutRef.current);
      pendingTimeoutRef.current = setTimeout(() => {
        setPendingLayerSelect(null);
        setPendingParamUpdate(null);
        pendingTimeoutRef.current = null;
      }, PENDING_ACTION_EXPIRY_MS);
    }
    return () => { if (pendingTimeoutRef.current) clearTimeout(pendingTimeoutRef.current); };
  }, [pendingLayerSelect, pendingParamUpdate]);

  // Load MIDI map for the current controllerAddress when it changes or service becomes ready
  useEffect(() => {
    const loadControllerMap = async () => {
      const logPrefix = `[MIDIContext LoadControllerMap Addr:${controllerAddress?.slice(0, 6) || 'N/A'}]`;
      if (controllerAddress && configServiceInstanceReady && configServiceRef.current) {
        if (import.meta.env.DEV) console.log(`${logPrefix} Attempting to load controller MIDI map (Instance Ready: ${configServiceInstanceReady})...`);
        try {
          const hexData = await configServiceRef.current.loadDataFromKey(controllerAddress, RADAR_MIDI_MAP_KEY);
          if (hexData && hexData !== '0x') {
            if (import.meta.env.DEV) console.log(`${logPrefix} Received hexData: ${hexData.substring(0, 100)}...`);
            const jsonString = hexToString(/** @type {`0x${string}`} */ (hexData));
            if (import.meta.env.DEV) console.log(`${logPrefix} Decoded JSON string: ${jsonString.substring(0, 100)}...`);
            const parsedMap = JSON.parse(jsonString);
            if (parsedMap && typeof parsedMap === 'object') {
              setActiveControllerMidiMap(parsedMap);
              if (import.meta.env.DEV) console.log(`${logPrefix} Controller MIDI map loaded and parsed successfully:`, parsedMap);
            } else {
              setActiveControllerMidiMap({});
              if (import.meta.env.DEV) console.warn(`${logPrefix} Parsed MIDI map invalid structure. Parsed:`, parsedMap, ". Map reset.");
            }
          } else {
            setActiveControllerMidiMap({});
            if (import.meta.env.DEV) console.log(`${logPrefix} No MIDI map data found (hexData is null or '0x'). Controller map reset.`);
          }
        } catch (error) {
          if (import.meta.env.DEV) console.error(`${logPrefix} Error loading or parsing controller MIDI map:`, error);
          setActiveControllerMidiMap({});
          if (import.meta.env.DEV) console.log(`${logPrefix} Controller map reset due to error.`);
        }
      } else {
        setActiveControllerMidiMap({}); // Reset if no address or service not ready
        if (import.meta.env.DEV) {
          if (!controllerAddress) console.log(`${logPrefix} Skipped: No controller address. Map reset.`);
          else if (!configServiceInstanceReady) console.log(`${logPrefix} Skipped: Config service INSTANCE not ready (Flag value: ${configServiceInstanceReady}). Map reset.`);
          else if (configServiceInstanceReady && !configServiceRef.current) console.log(`${logPrefix} Skipped: Config service INSTANCE ready but ref.current is null. Map reset.`);
          // else console.log(`${logPrefix} Skipped: Unknown reason, conditions not met. Map reset.`); // This log can be noisy
        }
      }
    };
    loadControllerMap();
  }, [controllerAddress, configServiceInstanceReady, configServiceRef]);


  const mapParameterToMIDI = useCallback((param, layer, mappingData) => {
    setActiveControllerMidiMap(prevControllerMap => {
      const baseMap = prevControllerMap || {};
      const updatedActiveMap = {
        ...baseMap,
        [String(layer)]: {
          ...(baseMap[String(layer)] || {}),
          [param]: mappingData
        }
      };
      if (typeof configUpdateMidiMap === 'function') {
        configUpdateMidiMap(updatedActiveMap); // Persist this to ConfigContext/on-chain
      } else if (import.meta.env.DEV) {
        console.error("[MIDIContext] mapParameterToMIDI: configUpdateMidiMap is not a function!");
      }
      return updatedActiveMap;
    });
  }, [configUpdateMidiMap]);

  const mapLayerToMIDI = useCallback((layer, mappingData) => {
    // This updates local ephemeral state for UI, not persisted controller map
    setLayerMappings(prev => ({ ...prev, [String(layer)]: { ...(prev[String(layer)] || {}), layerSelect: mappingData } }));
  }, []); // setLayerMappings is stable

  const startMIDILearn = useCallback((param, layer) => { setMidiLearning({ param: param, layer: layer }); setLearningLayer(null); }, []);
  const stopMIDILearn = useCallback(() => { if (midiLearningRef.current) setMidiLearning(null); }, []); // midiLearningRef for condition
  const startLayerMIDILearn = useCallback((layer) => { setLearningLayer(layer); setMidiLearning(null); }, []);
  const stopLayerMIDILearn = useCallback(() => { if (learningLayerRef.current !== null) setLearningLayer(null); }, []); // learningLayerRef for condition

  const handleMIDIMessage = useCallback((message) => {
    if (!message || !message.data || message.data.length === 0) return;
    const [status, data1, data2] = message.data;
    const msgChan = status & 0x0F; // MIDI channel (0-15)
    const msgType = getMidiMessageType(status);
    const timestamp = Date.now();

    setMidiMonitorData(prev => {
      const newEntry = { timestamp: new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute:'2-digit', second:'2-digit', fractionalSecondDigits: 3 }), status, data1, data2, channel: msgChan + 1, type: msgType };
      const updated = [...prev, newEntry];
      return updated.length > MAX_MONITOR_ENTRIES ? updated.slice(-MAX_MONITOR_ENTRIES) : updated;
    });

    if (selectedChannelRef.current > 0 && (msgChan + 1) !== selectedChannelRef.current) return; // Channel filter

    const isCC = msgType === 'Control Change';
    const isNoteOn = msgType === 'Note On' && data2 > 0; // Note On with velocity > 0
    const isPitch = msgType === 'Pitch Bend';
    const currentLearningState = midiLearningRef.current;

    if (currentLearningState) { // Parameter learn mode
      if (isCC || isNoteOn || isPitch) {
        const mappingData = { type: isCC ? 'cc' : (isNoteOn ? 'note' : 'pitchbend'), number: data1, channel: msgChan };
        mapParameterToMIDI(currentLearningState.param, currentLearningState.layer, mappingData);
        stopMIDILearn();
      }
      return;
    }
    if (learningLayerRef.current !== null) { // Layer select learn mode
      if (isNoteOn) {
        const mappingData = { type: 'note', number: data1, channel: msgChan };
        mapLayerToMIDI(learningLayerRef.current, mappingData);
        stopLayerMIDILearn();
      }
      return;
    }

    let actionTaken = false;
    let catchStateModified = false;

    if (isNoteOn) { // Layer selection via MIDI Note On
      Object.entries(layerMappingsRef.current).forEach(([layerId, mapping]) => {
        const lsm = mapping.layerSelect;
        if (lsm?.type === 'note' && lsm.number === data1 && (lsm.channel === undefined || lsm.channel === msgChan)) {
          actionTaken = true;
          setPendingLayerSelect({ layer: parseInt(layerId, 10), timestamp });
        }
      });
    }

    if ((isCC || isPitch || isNoteOn) && !actionTaken) { // Parameter control
      const currentControllerMap = activeControllerMidiMapRef.current || {};
      Object.entries(currentControllerMap).forEach(([layerIdStr, layerParams]) => {
        if (typeof layerParams !== 'object' || layerParams === null) return;
        Object.entries(layerParams).forEach(([paramName, mappingData]) => {
          if (!mappingData) return;
          let isMatch = false;
          let rawValue = data2;
          let midiMsgTypeForNormalization = 'cc'; // Default

          if (mappingData.type === 'cc' && isCC && mappingData.number === data1 && (mappingData.channel === undefined || mappingData.channel === msgChan)) {
            isMatch = true; rawValue = data2; midiMsgTypeForNormalization = 'cc';
          } else if (mappingData.type === 'note' && isNoteOn && mappingData.number === data1 && (mappingData.channel === undefined || mappingData.channel === msgChan)) {
            isMatch = true; rawValue = data2; midiMsgTypeForNormalization = 'note';
          } else if (mappingData.type === 'pitchbend' && isPitch && (mappingData.channel === undefined || mappingData.channel === msgChan)) {
            isMatch = true; rawValue = (data2 << 7) | data1; midiMsgTypeForNormalization = 'pitchbend';
          }

          if (isMatch) {
            actionTaken = true;
            const currentNormalizedMidiVal = normalizeMIDIValue(rawValue, midiMsgTypeForNormalization);
            const catchKey = `${layerIdStr}_${paramName}`;
            const paramCatchState = catchModeTargetValuesRef.current[catchKey];

            if (paramCatchState) { // Parameter is under catch mode
              let { value: presetValueActual, caught, lastMidiValue: lastNormalizedMidiVal } = paramCatchState;
              if (!caught) {
                const sliderConfig = sliderParams.find(p => p.prop === paramName);
                if (sliderConfig) {
                  const { min: sliderMin, max: sliderMax } = sliderConfig;
                  let normalizedPresetValue = 0.5;
                  if (sliderMax > sliderMin) {
                    normalizedPresetValue = (presetValueActual - sliderMin) / (sliderMax - sliderMin);
                    normalizedPresetValue = Math.max(0, Math.min(1, normalizedPresetValue));
                  }

                  let hasCaught = false;
                  if (lastNormalizedMidiVal !== null) {
                    const wentUpwards = lastNormalizedMidiVal <= normalizedPresetValue && currentNormalizedMidiVal >= normalizedPresetValue;
                    const wentDownwards = lastNormalizedMidiVal >= normalizedPresetValue && currentNormalizedMidiVal <= normalizedPresetValue;
                    hasCaught = wentUpwards || wentDownwards;
                  } else {
                    if (Math.abs(currentNormalizedMidiVal - normalizedPresetValue) < CATCH_MODE_NORMALIZATION_EPSILON) {
                      hasCaught = true;
                    }
                  }

                  if (hasCaught) {
                    if(import.meta.env.DEV) console.log(`[MIDI Catch] L${layerIdStr}-${paramName} CAUGHT! PresetValNorm: ${normalizedPresetValue.toFixed(3)}, LastMidiNorm: ${lastNormalizedMidiVal?.toFixed(3)}, CurrMidiNorm: ${currentNormalizedMidiVal.toFixed(3)}`);
                    catchModeTargetValuesRef.current[catchKey] = { ...paramCatchState, caught: true, lastMidiValue: currentNormalizedMidiVal };
                    catchStateModified = true;
                    setPendingParamUpdate({ layer: parseInt(layerIdStr, 10), param: paramName, value: currentNormalizedMidiVal, timestamp });
                  } else {
                     if(import.meta.env.DEV && lastNormalizedMidiVal !== null) {
                        // console.log(`[MIDI Catch] L${layerIdStr}-${paramName} NOT caught. PresetValNorm: ${normalizedPresetValue.toFixed(3)}, LastMidiNorm: ${lastNormalizedMidiVal?.toFixed(3)}, CurrMidiNorm: ${currentNormalizedMidiVal.toFixed(3)}`);
                     }
                    catchModeTargetValuesRef.current[catchKey] = { ...paramCatchState, lastMidiValue: currentNormalizedMidiVal };
                    catchStateModified = true;
                  }
                } else {
                  if(import.meta.env.DEV) console.warn(`[MIDI Catch] No sliderConfig for ${paramName}, applying MIDI directly.`);
                  setPendingParamUpdate({ layer: parseInt(layerIdStr, 10), param: paramName, value: currentNormalizedMidiVal, timestamp });
                }
              } else { // Already caught
                catchModeTargetValuesRef.current[catchKey] = { ...paramCatchState, lastMidiValue: currentNormalizedMidiVal };
                catchStateModified = true;
                setPendingParamUpdate({ layer: parseInt(layerIdStr, 10), param: paramName, value: currentNormalizedMidiVal, timestamp });
              }
            } else { // Parameter not under catch mode
              setPendingParamUpdate({ layer: parseInt(layerIdStr, 10), param: paramName, value: currentNormalizedMidiVal, timestamp });
            }
          }
        });
      });
    }
    if (catchStateModified) {
      setCatchModeTargetValues({ ...catchModeTargetValuesRef.current });
    }
  }, [mapLayerToMIDI, mapParameterToMIDI, stopMIDILearn, stopLayerMIDILearn]); // Removed setCatchModeTargetValues as it's updated via ref and then spread

  useEffect(() => { handleMIDIMessageRef.current = handleMIDIMessage; }, [handleMIDIMessage]);

  const setupMIDIListeners = useCallback((access) => {
    if (!access) return;
    access.inputs.forEach(input => {
      const messageHandlerWrapper = (message) => { if (handleMIDIMessageRef.current) { handleMIDIMessageRef.current(message); } };
      if (input.onmidimessage) { input.onmidimessage = null; } // Clear previous if any
      input.onmidimessage = messageHandlerWrapper;
    });
  }, []); // handleMIDIMessageRef is stable

  const handleStateChange = useCallback((event) => {
    if (!event || !event.port || event.port.type !== "input") return;
    const currentMidiAccess = midiAccessRefForCallbacks.current;
    if (!currentMidiAccess) return;

    const currentInputs = [];
    let anyConnected = false;
    currentMidiAccess.inputs.forEach(input => {
      currentInputs.push({ id: input.id, name: input.name || `Input ${input.id}`, manufacturer: input.manufacturer || 'Unknown', state: input.state });
      if (input.state === 'connected') {
        anyConnected = true;
        const messageHandlerWrapper = (message) => { if (handleMIDIMessageRef.current) { handleMIDIMessageRef.current(message); } };
        if (!input.onmidimessage) { // Re-attach if it was lost or never set
          input.onmidimessage = messageHandlerWrapper;
        }
      } else { // Disconnected
        if (input.onmidimessage) {
          input.onmidimessage = null;
        }
      }
    });
    setMidiInputs(currentInputs);
    setIsConnected(wasConnected => {
      if (wasConnected !== anyConnected) {
        if (anyConnected) setError(null);
        // else setError("All MIDI devices disconnected."); // This can be noisy if a device is unplugged intentionally
        return anyConnected;
      }
      return wasConnected;
    });
  }, []); // midiAccessRefForCallbacks, handleMIDIMessageRef are stable

  const connectMIDI = useCallback(async () => {
    if (connectionInProgressRef.current) return midiAccessRefForCallbacks.current;
    if (isConnected && midiAccessRefForCallbacks.current) return midiAccessRefForCallbacks.current;
    if (typeof navigator === 'undefined' || !navigator.requestMIDIAccess) {
      setError("Web MIDI API not supported");
      return null;
    }
    connectionInProgressRef.current = true;
    setIsConnecting(true);
    setError(null);

    if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current);
    connectTimeoutRef.current = setTimeout(() => {
      if (isConnecting && connectionInProgressRef.current) { // Check both flags
        setError("MIDI connection timed out.");
        setIsConnecting(false);
        connectionInProgressRef.current = false;
        if (import.meta.env.DEV) console.warn("[MIDIContext] MIDI connection timed out.");
      }
    }, MIDI_CONNECT_TIMEOUT_MS);

    let access = null;
    try {
      access = await navigator.requestMIDIAccess({ sysex: false }); // Request MIDI access
      if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current);
      connectTimeoutRef.current = null;

      if (isUnmountingRef.current) { // Check if component unmounted during await
          if (import.meta.env.DEV) console.log("[MIDIContext] connectMIDI: Unmounted during access request. Aborting setup.");
          connectionInProgressRef.current = false; setIsConnecting(false);
          return null;
      }

      setMidiAccess(access);
      const inputs = [];
      let anyDeviceConnected = false;
      access.inputs.forEach(input => {
        inputs.push({ id: input.id, name: input.name || `Input ${input.id}`, manufacturer: input.manufacturer || 'Unknown', state: input.state });
        if (input.state === 'connected') anyDeviceConnected = true;
      });
      setMidiInputs(inputs);
      setupMIDIListeners(access);
      access.onstatechange = handleStateChange; // Attach state change handler

      setIsConnected(anyDeviceConnected);
      setIsConnecting(false);
      connectionInProgressRef.current = false;
      if (!anyDeviceConnected) {
        setError("No MIDI devices found or connected.");
        if (import.meta.env.DEV) console.log("[MIDIContext] No MIDI devices found or connected after access grant.");
      } else if (import.meta.env.DEV) {
        console.log("[MIDIContext] MIDI connected successfully.");
      }
      return access;
    } catch (err) {
      if (connectTimeoutRef.current) clearTimeout(connectTimeoutRef.current);
      connectTimeoutRef.current = null;
      const errorMessage = err.message || err.name || 'Unknown MIDI access error';
      setError(`MIDI access failed: ${errorMessage}`);
      if (import.meta.env.DEV) console.error("[MIDIContext] MIDI access failed:", err);
      setMidiAccess(null);
      setIsConnected(false);
      setIsConnecting(false);
      connectionInProgressRef.current = false;
      return null;
    }
  }, [isConnected, setupMIDIListeners, handleStateChange, isConnecting]); // isConnecting added

  const disconnectMIDI = useCallback((forceFullDisconnect = false) => {
    const isDevelopment = import.meta.env.DEV;
    const isFinalUnmount = isUnmountingRef.current && forceFullDisconnect;
    const currentMidiAccess = midiAccessRefForCallbacks.current;

    if(isDevelopment) console.log(`[MIDIContext] disconnectMIDI called. Force: ${forceFullDisconnect}, isDev: ${isDevelopment}, isUnmounting: ${isUnmountingRef.current}`);

    if (currentMidiAccess) {
      if (currentMidiAccess.onstatechange) {
        currentMidiAccess.onstatechange = null;
        if(isDevelopment) console.log("[MIDIContext] Cleared onstatechange listener.");
      }
      currentMidiAccess.inputs.forEach(input => {
        if (input.onmidimessage) {
          input.onmidimessage = null;
          if(isDevelopment) console.log(`[MIDIContext] Cleared onmidimessage for input: ${input.id}`);
        }
      });
    }

    if (connectTimeoutRef.current) { clearTimeout(connectTimeoutRef.current); connectTimeoutRef.current = null; }
    if (pendingTimeoutRef.current) { clearTimeout(pendingTimeoutRef.current); pendingTimeoutRef.current = null; }
    connectionInProgressRef.current = false; // Ensure this is reset

    // Full disconnect logic for production, forced, or unmounting scenarios
    if (forceFullDisconnect || isFinalUnmount || !isDevelopment) {
      setMidiAccess(null);
      setIsConnected(false);
      setIsConnecting(false);
      setMidiInputs([]);
      setError(null);
      // setShowMidiMonitor(false); // Consider if this should be reset here or managed by UI state
      if(isDevelopment) console.log("[MIDIContext] Full MIDI Disconnect executed: States reset.");
    } else { // Soft disconnect for development (keeps state for easier debugging)
      setIsConnecting(false); // At least mark as not connecting
      if(isDevelopment) console.log("[MIDIContext] Soft MIDI Disconnect (dev mode, no force). isConnecting set to false.");
    }
  }, []); // midiAccessRefForCallbacks is stable

  const clearAllMappings = useCallback(() => {
    // Consider adding a confirmation dialog for the user
    if (window.confirm("Are you sure you want to reset ALL persistent MIDI parameter mappings for the current controller? This cannot be undone easily.")) {
      if(typeof configUpdateMidiMap === 'function') {
        configUpdateMidiMap({}); // Update the persisted map in ConfigContext
      }
      setActiveControllerMidiMap({}); // Clear local active map
      setLayerMappings({ "1": {}, "2": {}, "3": {} }); // Reset ephemeral UI mappings
      setGlobalMappings({}); // Reset ephemeral UI mappings
      setCatchModeTargetValues({}); // Reset catch mode state
      if (import.meta.env.DEV) console.log("[MIDIContext] All MIDI mappings cleared.");
    }
  }, [configUpdateMidiMap]);

  const setChannelFilter = useCallback((channel) => {
    const ch = parseInt(String(channel), 10);
    if (!isNaN(ch) && ch >= 0 && ch <= 16) { // 0 for Omni, 1-16 for channels
      setSelectedChannel(ch);
    } else if (import.meta.env.DEV) {
      console.warn(`[MIDIContext] Invalid channel for setChannelFilter: ${channel}`);
    }
  }, []); // setSelectedChannel is stable

  const clearMIDIMonitor = useCallback(() => { setMidiMonitorData([]); }, []);
  const clearPendingActions = useCallback(() => {
    setPendingLayerSelect(null);
    setPendingParamUpdate(null);
    if (pendingTimeoutRef.current) {
      clearTimeout(pendingTimeoutRef.current);
      pendingTimeoutRef.current = null;
    }
  }, []); // Setters are stable

  // Cleanup on unmount
  useEffect(() => {
    isUnmountingRef.current = false; // Set to false on mount/re-render
    return () => {
      isUnmountingRef.current = true; // Set to true when unmounting
      disconnectMIDI(true); // Force full disconnect on unmount
    };
  }, [disconnectMIDI]); // disconnectMIDI is memoized

  const contextValue = useMemo(() => ({
    midiAccess, isConnected, isConnecting, error, midiInputs,
    midiMap: activeControllerMidiMap, // This is the active map for the current controller
    layerMappings, globalMappings, midiLearning, learningLayer, selectedChannel,
    midiMonitorData, showMidiMonitor, pendingLayerSelect, pendingParamUpdate,
    setShowMidiMonitor, // Direct setter
    connectMIDI, disconnectMIDI, startMIDILearn, stopMIDILearn,
    startLayerMIDILearn, stopLayerMIDILearn, clearAllMappings, setChannelFilter,
    clearMIDIMonitor, mapParameterToMIDI, mapLayerToMIDI, clearPendingActions,
  }), [
    midiAccess, isConnected, isConnecting, error, midiInputs, activeControllerMidiMap,
    layerMappings, globalMappings, midiLearning, learningLayer, selectedChannel,
    midiMonitorData, showMidiMonitor, pendingLayerSelect, pendingParamUpdate,
    connectMIDI, disconnectMIDI, clearAllMappings, mapParameterToMIDI, mapLayerToMIDI,
    setChannelFilter, clearMIDIMonitor, setShowMidiMonitor, clearPendingActions, stopMIDILearn,
    startMIDILearn, startLayerMIDILearn, stopLayerMIDILearn
    // Note: setActiveControllerMidiMap, setLayerMappings, etc. are not part of the public context API
  ]);

  return (
    <MIDIContext.Provider value={contextValue}>
      {children}
    </MIDIContext.Provider>
  );
}

MIDIProvider.propTypes = {
  children: PropTypes.node.isRequired,
};

/**
 * Custom hook to consume the `MIDIContext`.
 * Provides access to MIDI state, device information, mappings, and control functions.
 * Throws an error if used outside of a `MIDIProvider`.
 *
 * @returns {MIDIContextValue} The current value of the MIDIContext.
 * @throws {Error} If the hook is not used within a `MIDIProvider`.
 */
export function useMIDI() {
  const context = useContext(MIDIContext);
  if (context === undefined) { // Check for undefined, which is the value if no provider is found
    const err = new Error('useMIDI must be used within a MIDIProvider component.');
    if (import.meta.env.DEV) {
        console.error("useMIDI context details: Attempted to use context but found undefined. This usually means MIDIProvider is missing as an ancestor of the component calling useMIDI.", err.stack);
    }
    throw err;
  }
  // The check `context === defaultContextValue` might be too strict if the default object reference is somehow used initially.
  // `context === undefined` is the standard and most reliable check for a missing provider.
  return context;
}
```

---
### `src\context\PresetManagementContext.jsx`
```jsx
// src/context/PresetManagementContext.jsx
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from "react";
import PropTypes from "prop-types";

import { useUserSession } from "./UserSessionContext"; // Local context
import { useConfig } from "./ConfigContext"; // Local context
import { useToast } from "./ToastContext"; // Local context

import fallbackConfig from "../config/fallback-config.js"; // Local config

/**
 * Transforms a list of preset name strings into an array of objects,
 * each with a `name` property. Used for populating selection UI.
 * @param {string[]} list - An array of preset name strings.
 * @returns {Array<{name: string}>} An array of preset objects, or an empty array if input is invalid.
 */
const transformStringListToObjects = (list) => {
  if (!Array.isArray(list)) return [];
  return list.filter((item) => typeof item === "string" && item.trim() !== "").map((name) => ({ name }));
};

/**
 * Returns a default template object for a single visual layer's configuration.
 * This ensures a consistent structure for all layers.
 * @returns {object} The default layer configuration template.
 */
const getMinimalLayerConfigTemplate = () => ({
  enabled: true,
  blendMode: "normal",
  opacity: 1.0,
  size: 1.0,
  speed: 0.01,
  drift: 0,
  driftSpeed: 0.1,
  angle: 0,
  xaxis: 0,
  yaxis: 0,
  direction: 1,
  driftState: { x: 0, y: 0, phase: Math.random() * Math.PI * 2, enabled: false },
});

/**
 * Ensures that a given layer configuration object contains all necessary properties,
 * falling back to a default template for any missing ones. This guarantees
 * that downstream components always receive a consistently structured layer config.
 * @param {object | null | undefined} layerConfig - The partial or potentially incomplete layer configuration.
 * @param {object} defaultLayerConfigTemplate - The default template to use for missing properties.
 * @returns {object} A complete layer configuration object.
 */
const ensureCompleteLayerConfigStructure = (
  layerConfig,
  defaultLayerConfigTemplate,
) => {
  const completeConfig = { ...defaultLayerConfigTemplate };
  if (layerConfig && typeof layerConfig === "object") {
    for (const key in defaultLayerConfigTemplate) { // Iterate over template keys to ensure all are considered
      if (
        Object.prototype.hasOwnProperty.call(layerConfig, key) &&
        layerConfig[key] !== null &&
        layerConfig[key] !== undefined
      ) {
        if (key === "driftState" && typeof layerConfig[key] === 'object' && defaultLayerConfigTemplate.driftState && typeof defaultLayerConfigTemplate.driftState === 'object') {
          completeConfig[key] = {
            ...defaultLayerConfigTemplate.driftState,
            ...(layerConfig[key] || {}),
          };
        } else {
          completeConfig[key] = layerConfig[key];
        }
      }
      // If key is in template but not in layerConfig (or is null/undefined), it keeps the default template value.
    }
  }
  // Final check for 'enabled' if it somehow got missed and is in the template
  if (
    typeof completeConfig.enabled !== "boolean" &&
    Object.prototype.hasOwnProperty.call(defaultLayerConfigTemplate, "enabled")
  ) {
    completeConfig.enabled = defaultLayerConfigTemplate.enabled;
  }
  return completeConfig;
};

/**
 * @typedef {object} PresetManagementContextValue
 * @property {string | null} currentConfigName - Name of the currently loaded visual preset. Null if no preset is active or during initial load.
 * @property {Array<{name: string}>} savedConfigList - An array of objects, each representing a saved visual preset with a `name` property.
 * @property {boolean} isLoading - True when loading a preset or the list of presets.
 * @property {Error | string | null} loadError - Contains an error object or message from the last preset load attempt, or null if successful.
 * @property {boolean} isSaving - True when a save or delete operation for a preset is in progress.
 * @property {Error | string | null} saveError - Contains an error object or message from the last preset save/delete attempt, or null if successful.
 * @property {boolean} saveSuccess - True if the last save/delete operation was successful.
 * @property {boolean} isInitiallyResolved - True once the initial attempt to load a preset (either default or fallback) has completed upon component mount or profile change.
 * @property {number} configLoadNonce - A number that increments each time a new configuration preset is successfully processed and applied. Used by consumers to detect new preset data.
 * @property {object | null} loadedLayerConfigsFromPreset - The layer configurations (e.g., for layers 1, 2, 3) loaded from the most recent preset or fallback. Structure: `{ "1": LayerConfig, "2": LayerConfig, ... }`.
 * @property {object | null} loadedTokenAssignmentsFromPreset - The token assignments (mapping layer IDs to token identifiers) loaded from the most recent preset or fallback. Structure: `{ "1": Assignment, "2": Assignment, ... }`.
 * @property {(name: string) => Promise<{success: boolean, error?: string, config?: object | null}>} loadNamedConfig - Loads a specific named configuration by its name.
 * @property {() => Promise<{success: boolean, error?: string, config?: object | null}>} loadDefaultConfig - Loads the configuration designated as the default for the current profile.
 * @property {() => Promise<{success: boolean, list?: Array<{name: string}>, error?: string}>} loadSavedConfigList - Reloads the list of saved configuration names from the current profile.
 * @property {(nameToSave: string, setAsDefault: boolean, includeReactions: boolean, includeMidi: boolean, layerConfigsToSave: object, tokenAssignmentsToSave: object) => Promise<{success: boolean, error?: string}>} saveVisualPreset - Saves the provided visual configuration (layers, tokens, and optionally global reactions/MIDI) as a named preset.
 * @property {(nameToDelete: string) => Promise<{success: boolean, error?: string}>} deleteNamedConfig - Deletes a named configuration from the current profile.
 */

/** @type {PresetManagementContextValue} */
export const defaultPresetManagementContextValue = { // Renamed for clarity
  currentConfigName: null,
  savedConfigList: [],
  isLoading: true,
  loadError: null,
  isSaving: false,
  saveError: null,
  saveSuccess: false,
  isInitiallyResolved: false,
  configLoadNonce: 0,
  loadedLayerConfigsFromPreset: null,
  loadedTokenAssignmentsFromPreset: null,
  loadNamedConfig: async () => {
    if (import.meta.env.DEV) console.warn("loadNamedConfig called on default PresetManagementContext");
    return { success: false, error: "PresetManagementProvider not initialized" };
  },
  loadDefaultConfig: async () => {
    if (import.meta.env.DEV) console.warn("loadDefaultConfig called on default PresetManagementContext");
    return { success: false, error: "PresetManagementProvider not initialized" };
  },
  loadSavedConfigList: async () => {
    if (import.meta.env.DEV) console.warn("loadSavedConfigList called on default PresetManagementContext");
    return { success: false, error: "PresetManagementProvider not initialized" };
  },
  saveVisualPreset: async () => {
    if (import.meta.env.DEV) console.warn("saveVisualPreset called on default PresetManagementContext");
    return { success: false, error: "PresetManagementProvider not initialized" };
  },
  deleteNamedConfig: async () => {
    if (import.meta.env.DEV) console.warn("deleteNamedConfig called on default PresetManagementContext");
    return { success: false, error: "PresetManagementProvider not initialized" };
  },
};

const PresetManagementContext = createContext(defaultPresetManagementContextValue);

/**
 * Provides context for managing visual presets (configurations).
 * This includes loading, saving, deleting, and listing presets,
 * as well as managing the state related to these operations (loading, errors, etc.).
 * It interacts with `ConfigurationService` (via `useConfig`) to persist and retrieve
 * preset data from the user's Universal Profile.
 *
 * @param {object} props - Component props.
 * @param {React.ReactNode} props.children - Child components that will consume this context.
 * @returns {JSX.Element} The PresetManagementProvider component.
 */
export const PresetManagementProvider = ({ children }) => {
  const { hostProfileAddress } = useUserSession();
  const {
    configServiceRef,
    configServiceInstanceReady,
    savedReactions: globalSavedReactions, // From ConfigContext
    midiMap: globalMidiMap,             // From ConfigContext
    setHasPendingChanges,
  } = useConfig();
  const { addToast } = useToast();

  const [currentConfigName, setCurrentConfigName] = useState(null);
  const [savedConfigList, setSavedConfigList] = useState([]);
  const [isLoading, setIsLoading] = useState(true); // True initially
  const [isInitiallyResolved, setIsInitiallyResolved] = useState(false);
  const [configLoadNonce, setConfigLoadNonce] = useState(0);
  const [loadError, setLoadError] = useState(null);
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState(null);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [loadedLayerConfigsFromPreset, setLoadedLayerConfigsFromPreset] = useState(null);
  const [loadedTokenAssignmentsFromPreset, setLoadedTokenAssignmentsFromPreset] = useState(null);

  /** @type {React.RefObject<string | null>} */
  const prevProfileAddressRef = useRef(hostProfileAddress);
  /** @type {React.RefObject<boolean>} */
  const initialDefaultLoadAttemptedForCurrentAddressRef = useRef(false);

  const applyLoadedPresetData = useCallback(
    (loadedData, _loadedForAddress, targetName = null) => {
      const minimalLayerTemplate = getMinimalLayerConfigTemplate();
      let finalName = null;
      let finalLayersForPreset = {}; // Initialize as object
      let finalTokensForPreset = {}; // Initialize as object

      if (loadedData?.error) {
        setLoadError(loadedData.error);
        // Avoid toast for "no default" or "not found" as these are handled by fallback
        if (loadedData.error && !String(loadedData.error).toLowerCase().includes("no default") && !String(loadedData.error).toLowerCase().includes("not found")) {
            addToast(`Error loading preset: ${loadedData.error}`, 'error');
        }
        finalName = targetName || "ErrorState";
        const fallbackLayersData = fallbackConfig.layers || {};
        for (const layerId of ['1', '2', '3']) { // Ensure all layers have a structure
          finalLayersForPreset[layerId] = ensureCompleteLayerConfigStructure(fallbackLayersData[layerId], minimalLayerTemplate);
        }
        finalTokensForPreset = fallbackConfig.tokenAssignments || {};
      } else if (loadedData?.config) {
        finalName = loadedData.config.name ?? targetName ?? "Unnamed Preset";
        const loadedLayers = loadedData.config.layers || {}; // Use 'layers' as per mapping in ConfigService
        for (const layerId of ['1', '2', '3']) {
          finalLayersForPreset[layerId] = ensureCompleteLayerConfigStructure(loadedLayers[layerId], minimalLayerTemplate);
        }
        finalTokensForPreset = loadedData.config.tokenAssignments || {}; // Use 'tokenAssignments'
        setLoadError(null);
      } else { // Fallback to default application config
        finalName = "Fallback";
        const fallbackLayersData = fallbackConfig.layers || {};
        for (const layerId of ['1', '2', '3']) {
          finalLayersForPreset[layerId] = ensureCompleteLayerConfigStructure(fallbackLayersData[layerId], minimalLayerTemplate);
        }
        finalTokensForPreset = fallbackConfig.tokenAssignments || {};
        setLoadError(null);
      }

      setLoadedLayerConfigsFromPreset(finalLayersForPreset);
      setLoadedTokenAssignmentsFromPreset(finalTokensForPreset);
      if (finalName !== currentConfigName) setCurrentConfigName(finalName);
      if (setHasPendingChanges) setHasPendingChanges(false);

      setConfigLoadNonce(prevNonce => prevNonce + 1);
      if (!isInitiallyResolved) {
        setIsInitiallyResolved(true);
      }
      setIsLoading(false);
    },
    [addToast, currentConfigName, isInitiallyResolved, setHasPendingChanges]
  );

  const loadSavedConfigListInternal = useCallback(async () => {
    const service = configServiceRef.current;
    const addressToLoad = hostProfileAddress;
    const isReady = !!service && configServiceInstanceReady;

    if (!isReady || !addressToLoad) {
      const errorMsg = !isReady ? "Service not ready for list." : "No profile address for list.";
      addToast(errorMsg, "warning"); setSavedConfigList([]);
      return { success: false, error: errorMsg };
    }
    try {
      const stringList = await service.loadSavedConfigurations(addressToLoad);
      const objectList = transformStringListToObjects(stringList);
      setSavedConfigList(objectList);
      return { success: true, list: objectList };
    } catch (error) {
      const errorMsg = error.message || "Failed to load list.";
      addToast(`Failed to load preset list: ${errorMsg}`, 'error');
      if (import.meta.env.DEV) console.error(`[PresetManagementContext] Failed to load preset list:`, error);
      setSavedConfigList([]);
      return { success: false, error: errorMsg };
    }
  }, [hostProfileAddress, addToast, configServiceInstanceReady, configServiceRef]);

  const performPresetLoadInternal = useCallback(
    async (address, configName = null, customKey = null, reason = "manual") => {
      const service = configServiceRef.current;
      const isReady = !!service && configServiceInstanceReady;

      setIsLoading(true);
      setLoadError(null);

      if (!address) {
        applyLoadedPresetData(null, `no_target_address_in_performLoad_${reason}`, null);
        return { success: true, config: fallbackConfig };
      }
      if (!isReady) {
        addToast("Preset service not ready. Applying client fallback.", "warning");
        applyLoadedPresetData(null, `service_not_ready_in_performLoad_${reason}`, address); // Pass address for context
        return { success: false, error: "Service not ready." };
      }

      try {
        const loadedData = await service.loadConfiguration(address, configName, customKey);
        applyLoadedPresetData({ config: loadedData.config, error: loadedData.error }, address, configName || "Default");

        const loadSuccessful = !loadedData?.error && !!loadedData?.config;
        if (loadSuccessful) {
          loadSavedConfigListInternal().catch((listError) => {
            if (import.meta.env.DEV) {
              console.error(`[PresetManagementContext performPresetLoadInternal] Error from loadSavedConfigListInternal after successful preset load:`, listError);
            }
          });
        }
        return { success: loadSuccessful, error: loadedData?.error, config: loadedData?.config };
      } catch (error) {
        const errorMsg = error.message || "Unknown load error";
        applyLoadedPresetData({ error: errorMsg }, address, configName || "Default");
        return { success: false, error: errorMsg };
      }
    },
    [configServiceInstanceReady, applyLoadedPresetData, addToast, loadSavedConfigListInternal, configServiceRef]
  );

  useEffect(() => {
    const currentAddress = hostProfileAddress;
    const serviceIsReady = configServiceInstanceReady;

    if (currentAddress !== prevProfileAddressRef.current) {
        prevProfileAddressRef.current = currentAddress;
        initialDefaultLoadAttemptedForCurrentAddressRef.current = false;

        setIsLoading(true);
        setIsInitiallyResolved(false);
        setConfigLoadNonce(0);
        setCurrentConfigName(null);
        setLoadedLayerConfigsFromPreset(null);
        setLoadedTokenAssignmentsFromPreset(null);
        setLoadError(null);
        if (setHasPendingChanges) setHasPendingChanges(false);

        if (!currentAddress) {
            applyLoadedPresetData(null, "profile_disconnected", "Fallback");
            setSavedConfigList([]);
            return;
        }
    }

    if (currentAddress && serviceIsReady && !initialDefaultLoadAttemptedForCurrentAddressRef.current && !isInitiallyResolved) {
        initialDefaultLoadAttemptedForCurrentAddressRef.current = true;
        setIsLoading(true);

        performPresetLoadInternal(currentAddress, null, null, "initial_default_load_for_profile")
            .catch(error => {
                if (import.meta.env.DEV) {
                    console.error(`[PresetManagementContext] Critical error during initial performPresetLoadInternal for ${currentAddress.slice(0,6)}:`, error);
                }
                applyLoadedPresetData({ error: "Critical initial load error" }, currentAddress);
            });
    }
  }, [hostProfileAddress, configServiceInstanceReady, isInitiallyResolved, performPresetLoadInternal, applyLoadedPresetData, setHasPendingChanges]);

  const saveVisualPreset = useCallback(
    async (nameToSave, setAsDefault, includeReactions, includeMidi, layerConfigsToSave, tokenAssignmentsToSave) => {
      const service = configServiceRef.current;
      const addressToSave = hostProfileAddress;
      const isReady = !!service && configServiceInstanceReady && service.checkReadyForWrite();

      if (!isReady || !addressToSave) {
        const errorMsg = !isReady ? "Write service not ready." : "No profile address.";
        addToast(errorMsg, "error"); return { success: false, error: errorMsg };
      }
      if (!nameToSave?.trim()) {
        addToast("Preset name cannot be empty.", "warning"); return { success: false, error: "Preset name required." };
      }
      setIsSaving(true); setSaveError(null); setSaveSuccess(false);

      const minimalLayerTemplate = getMinimalLayerConfigTemplate();
      const completeLayerConfigsForSave = {};
      for (const layerId of ['1', '2', '3']) {
        completeLayerConfigsForSave[layerId] = ensureCompleteLayerConfigStructure(layerConfigsToSave[layerId] || {}, minimalLayerTemplate);
      }

      const dataToSave = {
        layers: completeLayerConfigsForSave, // This will be stored as 'l' by ConfigService
        tokenAssignments: tokenAssignmentsToSave || {}, // This will be stored as 'tA'
        reactions: includeReactions ? globalSavedReactions : undefined,
        midi: includeMidi ? globalMidiMap : undefined,
      };

      try {
        const result = await service.saveConfiguration(addressToSave, dataToSave, nameToSave, setAsDefault, true, includeReactions, includeMidi, null);
        if (result.success) {
          addToast(`Preset '${nameToSave}' saved successfully!`, 'success');
          setSaveSuccess(true);
          if (setHasPendingChanges) setHasPendingChanges(false);
          if (currentConfigName !== nameToSave || setAsDefault) {
             setCurrentConfigName(nameToSave);
          }
          await loadSavedConfigListInternal();
        } else { throw new Error(result.error || "Save configuration failed."); }
        return result;
      } catch (error) {
        const errorMsg = error.message || "Unknown save error."; setSaveError(errorMsg);
        addToast(`Error saving preset: ${errorMsg}`, 'error');
        if (import.meta.env.DEV) console.error(`[PresetManagementContext] Error saving preset:`, error);
        setSaveSuccess(false); return { success: false, error: errorMsg };
      } finally {
        setIsSaving(false);
      }
    },
    [hostProfileAddress, globalSavedReactions, globalMidiMap, addToast, loadSavedConfigListInternal, configServiceInstanceReady, configServiceRef, setHasPendingChanges, currentConfigName]
  );

  const deleteNamedConfig = useCallback(
    async (nameToDelete) => {
      const service = configServiceRef.current;
      const addressToDeleteFrom = hostProfileAddress;
      const isReady = !!service && configServiceInstanceReady && service.checkReadyForWrite();
      if (!isReady || !addressToDeleteFrom) {
        const errorMsg = !isReady ? "Write service not ready." : "No profile address.";
        addToast(errorMsg, "error"); return { success: false, error: errorMsg };
      }
      if (!nameToDelete) {
        addToast("No preset name provided to delete.", "warning"); return { success: false, error: "No name provided." };
      }
      setIsSaving(true); setSaveError(null); setSaveSuccess(false);
      try {
        const result = await service.deleteConfiguration(addressToDeleteFrom, nameToDelete);
        if (result.success) {
          addToast(`Preset '${nameToDelete}' deleted.`, 'success');
          setSaveSuccess(true);
          await loadSavedConfigListInternal();
          if (currentConfigName === nameToDelete) {
            await performPresetLoadInternal(addressToDeleteFrom, null, null, `delete_cleanup_for_${nameToDelete}`);
          }
        } else { throw new Error(result.error || "Delete operation failed."); }
        return result;
      } catch (error) {
        const errorMsg = error.message || "Unknown delete error."; setSaveError(errorMsg);
        addToast(`Error deleting preset: ${errorMsg}`, 'error');
        if (import.meta.env.DEV) console.error(`[PresetManagementContext] Error deleting preset:`, error);
        setSaveSuccess(false); return { success: false, error: errorMsg };
      } finally {
        setIsSaving(false);
      }
    },
    [hostProfileAddress, performPresetLoadInternal, addToast, loadSavedConfigListInternal, currentConfigName, configServiceInstanceReady, configServiceRef]
  );

  const loadNamedConfig = useCallback((name) =>
    performPresetLoadInternal(hostProfileAddress, name, null, `load_named:${name}`),
    [performPresetLoadInternal, hostProfileAddress]
  );

  const loadDefaultConfig = useCallback(() =>
    performPresetLoadInternal(hostProfileAddress, null, null, "load_profile_default"),
    [performPresetLoadInternal, hostProfileAddress]
  );

  const contextValue = useMemo(() => ({
    currentConfigName,
    savedConfigList,
    isLoading,
    loadError,
    isSaving,
    saveError,
    saveSuccess,
    isInitiallyResolved,
    configLoadNonce,
    loadedLayerConfigsFromPreset,
    loadedTokenAssignmentsFromPreset,
    loadNamedConfig,
    loadDefaultConfig,
    loadSavedConfigList: loadSavedConfigListInternal,
    saveVisualPreset,
    deleteNamedConfig,
  }), [
    currentConfigName, savedConfigList, isLoading, loadError, isSaving, saveError, saveSuccess,
    isInitiallyResolved, configLoadNonce, loadedLayerConfigsFromPreset, loadedTokenAssignmentsFromPreset,
    loadNamedConfig, loadDefaultConfig, loadSavedConfigListInternal, saveVisualPreset, deleteNamedConfig
  ]);

  return (
    <PresetManagementContext.Provider value={contextValue}>
      {children}
    </PresetManagementContext.Provider>
  );
};

PresetManagementProvider.propTypes = {
  children: PropTypes.node.isRequired,
};

/**
 * Custom hook to consume the PresetManagementContext.
 * Provides access to the current preset's state (name, loaded data),
 * the list of saved presets, loading/saving states, and functions to manage presets.
 *
 * @returns {PresetManagementContextValue} The preset management context value.
 * @throws {Error} If used outside of a PresetManagementProvider.
 */
export const usePresetManagement = () => {
  const context = useContext(PresetManagementContext);
  if (context === undefined) { // Standard check for missing provider
    const err = new Error("usePresetManagement must be used within a PresetManagementProvider");
    if (import.meta.env.DEV) {
        console.error("usePresetManagement context details: Attempted to use context but found undefined. This usually means PresetManagementProvider is missing as an ancestor.", err.stack);
    }
    throw err;
  }
  return context;
};
```

---
### `src\context\ToastContext.jsx`
```jsx
// src/context/ToastContext.jsx
import React, { createContext, useState, useCallback, useContext, useMemo } from 'react';
import PropTypes from 'prop-types';

/**
 * @typedef {'info' | 'success' | 'warning' | 'error'} ToastType - The type of the toast, influencing its appearance.
 */

/**
 * @typedef {object} ToastMessage
 * @property {number} id - Unique identifier for the toast message.
 * @property {string | React.ReactNode} content - The content of the toast message. Can be a string or a React node.
 * @property {ToastType} type - The type of the toast (e.g., 'info', 'success').
 * @property {number | null} duration - The duration in milliseconds for which the toast should be visible. If null, it remains until manually dismissed.
 */

/**
 * @typedef {object} ToastContextValue
 * @property {(content: string | React.ReactNode, type?: ToastType, duration?: number | null) => void} addToast - Function to add a new toast notification.
 * @property {(id: number) => void} removeToast - Function to remove a toast notification by its ID.
 * @property {Array<ToastMessage>} toasts - An array of the currently active toast notifications.
 */

/**
 * Default context value for ToastContext.
 * Provides no-op functions and an empty toasts array if used outside a provider.
 * @type {ToastContextValue}
 */
const defaultToastContextValue = {
  addToast: (content, type, duration) => {
    if (import.meta.env.DEV) {
      console.warn("addToast called on default ToastContext. Ensure ToastProvider is an ancestor.", { content, type, duration });
    }
  },
  removeToast: (id) => {
    if (import.meta.env.DEV) {
      console.warn("removeToast called on default ToastContext. Ensure ToastProvider is an ancestor.", { id });
    }
  },
  toasts: [],
};

const ToastContext = createContext(defaultToastContextValue);

/** @type {number} Simple counter to generate unique IDs for toast messages. */
let idCounter = 0;

/**
 * ToastProvider: Manages the state for displaying toast notifications.
 * It provides functions to add and remove toasts, and exposes the current list of toasts
 * to consuming components. Toasts can have a type, content, and an optional auto-dismiss duration.
 *
 * @param {object} props - The component props.
 * @param {React.ReactNode} props.children - The child components that will have access to this context.
 * @returns {JSX.Element} The ToastProvider component.
 */
export const ToastProvider = ({ children }) => {
  /** @type {[Array<ToastMessage>, React.Dispatch<React.SetStateAction<Array<ToastMessage>>>]} */
  const [toasts, setToasts] = useState([]);

  /**
   * Removes a toast notification from the list by its unique ID.
   * This function is memoized for stability.
   * @param {number} id - The ID of the toast to remove.
   */
  const removeToast = useCallback((id) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []); // setToasts is stable

  /**
   * Adds a new toast notification to the list.
   * If a `duration` is provided, the toast will automatically be removed after that time.
   * This function is memoized and depends on the stable `removeToast` callback.
   * @param {string | React.ReactNode} content - The message or React node to display in the toast.
   * @param {ToastType} [type='info'] - The type of the toast, affecting its style.
   * @param {number | null} [duration=5000] - The duration in milliseconds for the toast to be visible.
   *                                         Pass `null` or `0` for a toast that does not auto-dismiss.
   */
  const addToast = useCallback((content, type = 'info', duration = 5000) => {
    const id = idCounter++; // Generate a new unique ID
    setToasts((prevToasts) => [...prevToasts, { id, content, type, duration }]);

    // Set a timer to automatically remove the toast if a positive duration is provided
    if (duration && duration > 0) {
      setTimeout(() => {
        removeToast(id); // Call the stable removeToast function
      }, duration);
    }
  }, [removeToast]); // Depends on the stable removeToast callback

  // Memoize the context value to prevent unnecessary re-renders of consumers
  // when the provider's parent re-renders but these specific values haven't changed.
  const contextValue = useMemo(() => ({
    addToast,
    removeToast,
    toasts
  }), [addToast, removeToast, toasts]);

  return (
    <ToastContext.Provider value={contextValue}>
      {children}
    </ToastContext.Provider>
  );
};

ToastProvider.propTypes = {
  children: PropTypes.node.isRequired,
};

/**
 * Custom hook to consume the `ToastContext`.
 * Provides access to the `addToast` and `removeToast` functions, and the `toasts` array.
 * It ensures that the hook is used within a `ToastProvider` and throws an error if not.
 *
 * @returns {ToastContextValue} The current value of the ToastContext.
 * @throws {Error} If the hook is not used within a `ToastProvider`.
 */
export const useToast = () => {
  const context = useContext(ToastContext);
  if (context === undefined) { // Standard check for missing provider
    const err = new Error('useToast must be used within a ToastProvider component.');
    if (import.meta.env.DEV) {
        console.error("useToast context details: Attempted to use context but found undefined. This usually means ToastProvider is missing as an ancestor of the component calling useToast.", err.stack);
    }
    throw err;
  }
  return context;
};
```

---
### `src\context\UpProvider.jsx`
```jsx
// src/context/UpProvider.jsx
import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useMemo,
  useCallback,
} from "react";
import PropTypes from 'prop-types';

import { createClientUPProvider } from "@lukso/up-provider"; // Lukso UP Provider
import {
  createWalletClient,
  createPublicClient,
  custom, // For Viem transport with EIP-1193 provider
  http,   // For Viem public client transport
  numberToHex,
  getAddress, // <<< ADDED IMPORT
} from "viem";
import { lukso, luksoTestnet } from "viem/chains"; // Supported Viem chain definitions

/**
 * Normalizes a chain ID to its hexadecimal string representation (e.g., "0x2a").
 * Handles number, decimal string, or hex string inputs.
 * @param {string|number|null|undefined} chainId - The chain ID to normalize.
 * @returns {string|null} The normalized hex chain ID (lowercase) or null if input is invalid.
 */
const normalizeChainId = (chainId) => {
  if (chainId === null || chainId === undefined) return null;
  if (typeof chainId === "number") {
    return numberToHex(chainId);
  }
  if (typeof chainId === "string") {
    const lower = chainId.toLowerCase().trim();
    if (/^0x[0-9a-f]+$/.test(lower)) return lower; // Already hex
    try {
      const num = parseInt(lower, 10); // Try parsing as decimal
      if (!isNaN(num) && num >= 0) return numberToHex(num);
    // eslint-disable-next-line no-unused-vars
    } catch (_) {
      // Ignore parse error, try hex without 0x
    }
    if (/^[0-9a-f]+$/.test(lower)) return `0x${lower}`; // Add 0x if missing
  }
  if (import.meta.env.DEV) {
    console.warn("[UpProvider] Invalid chainId format provided for normalization:", chainId);
  }
  return null;
};

// Supported chains configuration, keyed by normalized chain ID
const VIEM_CHAINS = {
  [/** @type {string} */ (normalizeChainId(lukso.id))]: lukso,
  [/** @type {string} */ (normalizeChainId(luksoTestnet.id))]: luksoTestnet,
};

// RPC URLs from environment variables with fallbacks
const LUKSO_MAINNET_RPC = import.meta.env.VITE_LUKSO_MAINNET_RPC_URL || "https://rpc.mainnet.lukso.network";
const LUKSO_TESTNET_RPC = import.meta.env.VITE_LUKSO_TESTNET_RPC_URL || "https://rpc.testnet.lukso.network";

const RPC_URLS = {
  [/** @type {string} */ (normalizeChainId(lukso.id))]: LUKSO_MAINNET_RPC,
  [/** @type {string} */ (normalizeChainId(luksoTestnet.id))]: LUKSO_TESTNET_RPC,
};

// Map of supported chain objects, keyed by normalized chain ID
const SUPPORTED_CHAINS = {
  [/** @type {string} */ (normalizeChainId(lukso.id))]: VIEM_CHAINS[/** @type {string} */ (normalizeChainId(lukso.id))],
  [/** @type {string} */ (normalizeChainId(luksoTestnet.id))]: VIEM_CHAINS[/** @type {string} */ (normalizeChainId(luksoTestnet.id))],
};

// --- Context Definition ---
/**
 * @typedef {object} UpProviderState
 * @property {object|null} provider - The raw EIP-1193 UP Provider instance from `@lukso/up-provider`. Null if `createClientUPProvider` fails.
 * @property {import('viem').WalletClient|null} walletClient - Viem Wallet Client configured for the UP. Null if provider, chain, or EOA is unavailable/invalid.
 * @property {import('viem').PublicClient|null} publicClient - Viem Public Client for the current chain. Null if chain is unsupported or RPC URL is missing.
 * @property {string|null} chainId - The current hexadecimal chain ID (e.g., '0x2a' for LUKSO Mainnet), or null if unsupported/disconnected.
 * @property {Array<string>} accounts - Array of EOA addresses controlled by the user, provided by the UP extension. `accounts[0]` is typically the active EOA.
 * @property {Array<string>} contextAccounts - Array of UP addresses relevant to the current context (e.g., the profile being viewed). `contextAccounts[0]` is the primary context UP.
 * @property {boolean} walletConnected - True if the provider is considered connected (valid chain, EOA accounts, and context UP accounts are present).
 * @property {boolean} isConnecting - Always false in this implementation; connection status is derived from events and available data. Kept for potential API consistency if other providers manage explicit connection states.
 * @property {Error|null} initializationError - Error object if `createClientUPProvider` failed during initial module load.
 * @property {Error|null} fetchStateError - Error object from Viem public or wallet client creation attempts.
 * @property {boolean} hasCriticalError - True if `initializationError` is present, indicating a fundamental issue with the UP provider setup.
 */

/** @type {React.Context<UpProviderState | undefined>} */
const UpContext = createContext(undefined);

// --- UP Provider Instance Creation ---
let upProviderInstance = null;
/** @type {Error | null} */
let upProviderInitializationError = null;

if (typeof window !== "undefined" && typeof window.ethereum !== "undefined") {
  try {
    upProviderInstance = createClientUPProvider();
  } catch (error) {
    if (import.meta.env.DEV) {
        console.error("[UpProvider] CRITICAL: Error creating Client UP Provider instance:", error);
    }
    upProviderInitializationError = error instanceof Error ? error : new Error(String(error));
  }
} else if (typeof window !== "undefined" && import.meta.env.DEV) {
    console.warn("[UpProvider] window.ethereum (Universal Profile Extension) not detected. UP Provider not initialized.");
    upProviderInitializationError = new Error("Universal Profile Extension (window.ethereum) not detected.");
}


/**
 * Custom hook `useUpProvider` to consume `UpContext`.
 * @returns {UpProviderState} The current state of the UpProvider.
 * @throws {Error} If used outside of an `UpProvider`.
 */
export function useUpProvider() {
  const context = useContext(UpContext);
  if (context === undefined) {
    const err = new Error("useUpProvider must be used within an UpProvider component.");
    if (import.meta.env.DEV) {
        console.error("useUpProvider context details: Attempted to use context but found undefined. This usually means UpProvider is missing as an ancestor.", err.stack);
    }
    throw err;
  }
  return context;
}

/**
 * `UpProvider` component.
 * @param {object} props - Component props.
 * @param {React.ReactNode} props.children - Child components that will consume this context.
 * @returns {JSX.Element} The UpProvider component.
 */
export function UpProvider({ children }) {
  const [provider] = useState(upProviderInstance);
  const [initializationError] = useState(upProviderInitializationError);
  /** @type {[string | null, React.Dispatch<React.SetStateAction<string | null>>]} */
  const [chainId, setChainId] = useState(null);
  /** @type {[Array<string>, React.Dispatch<React.SetStateAction<Array<string>>>]} */
  const [accounts, setAccounts] = useState([]);
  /** @type {[Array<string>, React.Dispatch<React.SetStateAction<Array<string>>>]} */
  const [contextAccounts, setContextAccounts] = useState([]);
  const [walletConnected, setWalletConnected] = useState(false);
  /** @type {[Error | null, React.Dispatch<React.SetStateAction<Error | null>>]} */
  const [fetchStateError, setFetchStateError] = useState(null);

  const hasCriticalError = useMemo(() => !!initializationError, [initializationError]);
  const currentChain = useMemo(() => chainId && SUPPORTED_CHAINS[chainId] ? SUPPORTED_CHAINS[chainId] : null, [chainId]);
  const connectedEOA = useMemo(() => (accounts?.length > 0 ? accounts[0] : null), [accounts]);

  const publicClient = useMemo(() => {
    if (!currentChain || !chainId) return null;
    try {
      const rpcUrl = RPC_URLS[chainId];
      if (!rpcUrl) {
        throw new Error(`No configured RPC URL for chain ${chainId}`);
      }
      const transport = http(rpcUrl, { retryCount: 3 });
      return createPublicClient({ chain: currentChain, transport });
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("[UpProvider] Error creating public client:", error);
      }
      setFetchStateError(error instanceof Error ? error : new Error(String(error)));
      return null;
    }
  }, [currentChain, chainId]);

  const walletClient = useMemo(() => {
    if (hasCriticalError || !provider || !currentChain || !connectedEOA) return null;
    try {
      const eoaForClient = getAddress(/** @type {`0x${string}`} */ (connectedEOA)); // Ensure checksummed and cast for Viem
      return createWalletClient({ chain: currentChain, transport: custom(provider), account: eoaForClient });
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("[UpProvider] Error creating wallet client:", error);
      }
      setFetchStateError(error instanceof Error ? error : new Error(String(error)));
      return null;
    }
  }, [provider, currentChain, connectedEOA, hasCriticalError]);

  const updateConnectedStatus = useCallback(() => {
    const connected = !!chainId &&
                      !!SUPPORTED_CHAINS[chainId] &&
                      accounts.length > 0 &&
                      contextAccounts.length > 0;
    setWalletConnected(connected);
  }, [chainId, accounts, contextAccounts]);

  useEffect(() => {
    if (initializationError) {
      if (import.meta.env.DEV) {
        console.error("[UpProvider] Setup skipped due to UP provider initialization error.");
      }
      setWalletConnected(false);
      return;
    }
    if (!provider) {
      if (import.meta.env.DEV) {
        console.warn("[UpProvider] Setup skipped: Client UP Provider instance not available (likely no UP extension).");
      }
      setWalletConnected(false);
      return;
    }

    /** @type {{ current: boolean }} */
    const mountedRef = { current: true };

    try {
      const _initialAccounts = provider.accounts || [];
      const _initialContextAccounts = provider.contextAccounts || [];
      if (mountedRef.current) {
        setAccounts(_initialAccounts);
        setContextAccounts(_initialContextAccounts);
      }

      provider.request({ method: "eth_chainId" })
        .then(rawChainId => {
          if (!mountedRef.current) return;
          const normalizedId = normalizeChainId(rawChainId);
          const isValid = !!normalizedId && normalizedId !== "0x0" && !!SUPPORTED_CHAINS[normalizedId];
          setChainId(isValid ? normalizedId : null);
          updateConnectedStatus();
        })
        .catch(err => {
            if (import.meta.env.DEV) console.warn("[UpProvider] Error fetching initial chainId:", err);
            if (mountedRef.current) { setChainId(null); updateConnectedStatus(); }
        });
      updateConnectedStatus();
    } catch (err) {
      if (import.meta.env.DEV) console.error("[UpProvider] Error accessing initial provider properties:", err);
      provider.request({ method: "eth_accounts" })
        .then(_fallbackAccounts => {
          if (!mountedRef.current) return;
          setAccounts(_fallbackAccounts || []);
          updateConnectedStatus();
        })
        .catch(fallbackErr => {
            if (import.meta.env.DEV) console.warn("[UpProvider] Error fetching initial accounts (fallback):", fallbackErr);
            if (mountedRef.current) { setAccounts([]); updateConnectedStatus(); }
        });
    }

    const handleAccountsChanged = (_newAccounts) => {
      if (!mountedRef.current) return;
      const newAccs = Array.isArray(_newAccounts) ? _newAccounts : [];
      setAccounts(newAccs);
      updateConnectedStatus();
    };

    const handleChainChanged = (rawChainId) => {
      if (!mountedRef.current) return;
      const normalizedId = normalizeChainId(rawChainId);
      const isValidChain = !!normalizedId && normalizedId !== "0x0" && !!SUPPORTED_CHAINS[normalizedId];
      setChainId(isValidChain ? normalizedId : null);
      if (!isValidChain) {
          if (import.meta.env.DEV) console.warn("[UpProvider Event] Chain changed to invalid/unsupported. Clearing accounts.");
          setAccounts([]);
          setContextAccounts([]);
      }
      updateConnectedStatus();
    };

    const handleContextAccountsChanged = (_newContextAccounts) => {
      if (!mountedRef.current) return;
      const newContextAccs = Array.isArray(_newContextAccounts) ? _newContextAccounts : [];
      setContextAccounts(newContextAccs);
      updateConnectedStatus();
    };

    provider.on("accountsChanged", handleAccountsChanged);
    provider.on("chainChanged", handleChainChanged);
    provider.on("contextAccountsChanged", handleContextAccountsChanged);

    return () => {
      mountedRef.current = false;
      if (provider?.removeListener) {
        provider.removeListener("accountsChanged", handleAccountsChanged);
        provider.removeListener("chainChanged", handleChainChanged);
        provider.removeListener("contextAccountsChanged", handleContextAccountsChanged);
      }
    };
  }, [provider, initializationError, updateConnectedStatus]);

  const contextValue = useMemo(
    () => ({
      provider,
      walletClient,
      publicClient,
      chainId,
      accounts,
      contextAccounts,
      walletConnected,
      isConnecting: false,
      initializationError,
      fetchStateError,
      hasCriticalError,
    }),
    [
      provider, walletClient, publicClient, chainId, accounts, contextAccounts,
      walletConnected, initializationError, fetchStateError, hasCriticalError,
    ],
  );

  return (
    <UpContext.Provider value={contextValue}>{children}</UpContext.Provider>
  );
}

UpProvider.propTypes = {
    children: PropTypes.node.isRequired,
};
```

---
### `src\context\UpServerProvider.js`
```js
// src/utils/upHostConnector.js (Example filename, adjust as needed)
import { createUPProviderConnector } from "@lukso/up-provider";

/**
 * Initializes the Universal Profile (UP) Provider Connector for the host environment (the main window).
 * This setup allows embedded iframes (MiniApps), which use the client-side UP Provider,
 * to securely connect and interact with the user's UP browser extension via this host application.
 *
 * This function should only be called when the application is determined to be running
 * in the top-level window context (i.e., not inside an iframe).
 *
 * The connector listens for new communication channels from MiniApps and enables them.
 * It relies on the standard EIP-1193 events (`chainChanged`, `accountsChanged`) being relayed
 * by the connector to inform MiniApps of state changes, rather than pushing initial state directly,
 * to prevent potential state conflicts or race conditions.
 *
 * @returns {void}
 */
export function initializeHostUPConnector() {
  try {
    // Attempt to get the host's EIP-1193 provider (typically the UP extension)
    const hostProvider = window.lukso || window.ethereum;
    if (!hostProvider) {
      // This is a critical issue if the host is expected to have a UP extension.
      if (import.meta.env.DEV) {
        console.error("[UP Host Connector] No host provider (window.lukso or window.ethereum) found. UP Connector cannot be initialized.");
      }
      return;
    }

    // The RPC URL provided here is a fallback or for specific configurations.
    // The hostProvider (UP extension) itself dictates the actual network connection.
    // Using a Mainnet RPC is a common default if no other specific network is targeted by the host setup.
    const connector = createUPProviderConnector(hostProvider, [
      "https://rpc.lukso.network", // LUKSO Mainnet RPC endpoint (can be made configurable if needed)
      // Add other RPCs if your host application might switch networks and needs to inform the connector.
    ]);

    // Listen for new channels created by MiniApps attempting to connect.
    connector.on("channelCreated", (id, channel) => {
      // When a MiniApp (identified by `id`) creates a channel, enable it.
      // The `channel.enable = true` step is crucial for establishing communication.
      //
      // IMPORTANT: Do NOT push initial state (like chainId or accounts) directly to the channel here.
      // The client UP Provider in the MiniApp should request this information using standard
      // EIP-1193 methods (e.g., `eth_chainId`, `eth_accounts`) after connection, or listen for
      // standard EIP-1193 events (`chainChanged`, `accountsChanged`) that the connector
      // should automatically relay from the hostProvider. Pushing state here can lead to
      // race conditions or state inconsistencies, potentially disabling the connect button
      // in the MiniApp or causing other unexpected behavior.
      try {
        channel.enable = true; // Enable the communication channel with the MiniApp.
        if (import.meta.env.DEV) {
          // console.log(`[UP Host Connector] Enabled communication channel for MiniApp ID: ${id}`);
        }
      } catch (error) {
        // This is a critical error if a channel cannot be enabled.
        if (import.meta.env.DEV) {
          console.error(`[UP Host Connector] CRITICAL: Error enabling channel for MiniApp ID ${id}:`, error);
        }
        // Consider additional error handling, e.g., attempting to disconnect the problematic channel
        // if (channel && typeof channel.disconnect === 'function') {
        //   channel.disconnect();
        // }
      }
    });

    if (import.meta.env.DEV) {
      // console.log("[UP Host Connector] Initialized successfully and listening for MiniApp connections.");
    }

  } catch (error) {
    // This indicates a fatal error during the connector's own initialization.
    if (import.meta.env.DEV) {
      console.error("[UP Host Connector] FATAL: Error initializing UPProviderConnector:", error);
    }
  }
}
```

---
### `src\context\UserSessionContext.jsx`
```jsx
// src/context/UserSessionContext.jsx
import React, { createContext, useContext, useState, useMemo, useCallback } from 'react';
import PropTypes from 'prop-types';

import { useUpProvider } from './UpProvider'; // Local context
import { RADAR_OFFICIAL_ADMIN_ADDRESS } from '../config/global-config.js'; // Local config

import { isAddress } from 'viem'; // Third-party utility

/**
 * @typedef {object} UserSessionContextValue
 * @property {string | null} hostProfileAddress - The Universal Profile address currently being viewed or configured. This is typically derived from `contextAccounts[0]` of `useUpProvider`.
 * @property {string | null} visitorProfileAddress - The Universal Profile address of the current user/visitor interacting with the application. This is typically derived from `accounts[0]` of `useUpProvider`.
 * @property {boolean} isHostProfileOwner - True if the `visitorProfileAddress` is the same as the `hostProfileAddress`, indicating the visitor owns the profile being viewed.
 * @property {boolean} isRadarProjectAdmin - True if the `visitorProfileAddress` matches the `RADAR_OFFICIAL_ADMIN_ADDRESS`, granting special administrative privileges.
 * @property {boolean} isPreviewMode - True if the application is currently operating in a special preview or demonstration mode, which might restrict certain actions like saving.
 * @property {boolean} canSaveToHostProfile - True if the current user (visitor) has permissions to save changes to the `hostProfileAddress`. This is typically true if the visitor is the owner and not in preview mode.
 * @property {() => void} togglePreviewMode - Function to toggle the `isPreviewMode` state.
 */

/**
 * Default values for the UserSessionContext.
 * These are used if a component tries to consume the context without a `UserSessionProvider` higher up in the tree.
 * @type {UserSessionContextValue}
 */
export const defaultUserSessionContextValue = { // Renamed for clarity
  hostProfileAddress: null,
  visitorProfileAddress: null,
  isHostProfileOwner: false,
  isRadarProjectAdmin: false,
  isPreviewMode: false,
  canSaveToHostProfile: false,
  togglePreviewMode: () => {
    if (import.meta.env.DEV) {
      console.warn("togglePreviewMode called on default UserSessionContext. Ensure UserSessionProvider is an ancestor.");
    }
  },
};

const UserSessionContext = createContext(defaultUserSessionContextValue);

/**
 * Provides user session context, including information about the host profile being viewed,
 * the visitor's profile, ownership status, administrative privileges (if applicable),
 * and the application's preview mode state. It derives most of its core data from `useUpProvider`.
 *
 * @param {object} props - The component props.
 * @param {React.ReactNode} props.children - The child components that will have access to this context.
 * @returns {JSX.Element} The UserSessionProvider component.
 */
export const UserSessionProvider = ({ children }) => {
  const { accounts, contextAccounts } = useUpProvider();
  const [isPreviewMode, setIsPreviewMode] = useState(false);

  const hostProfileAddress = useMemo(() => {
    const address = contextAccounts && contextAccounts.length > 0 && isAddress(contextAccounts[0])
      ? contextAccounts[0]
      : null;
    // if (import.meta.env.DEV) {
      // console.log("[UserSessionProvider] Calculated hostProfileAddress:", address, "from contextAccounts:", contextAccounts);
    // }
    return address;
  }, [contextAccounts]);

  const visitorProfileAddress = useMemo(() => {
    const address = accounts && accounts.length > 0 && isAddress(accounts[0])
      ? accounts[0]
      : null;
    // if (import.meta.env.DEV) {
      // console.log("[UserSessionProvider] Calculated visitorProfileAddress:", address, "from accounts:", accounts);
    // }
    return address;
  }, [accounts]);

  const isHostProfileOwner = useMemo(() => {
    if (!visitorProfileAddress || !hostProfileAddress) {
      return false;
    }
    return visitorProfileAddress.toLowerCase() === hostProfileAddress.toLowerCase();
  }, [visitorProfileAddress, hostProfileAddress]);

  const isRadarProjectAdmin = useMemo(() => {
    if (!visitorProfileAddress || !RADAR_OFFICIAL_ADMIN_ADDRESS) return false;
    // Validate the configured admin address format once
    if (!isAddress(RADAR_OFFICIAL_ADMIN_ADDRESS)) {
        if (import.meta.env.DEV) {
            console.warn("[UserSessionContext] RADAR_OFFICIAL_ADMIN_ADDRESS in global-config.js is not a valid Ethereum address. isRadarProjectAdmin will always be false.");
        }
        return false;
    }
    return visitorProfileAddress.toLowerCase() === RADAR_OFFICIAL_ADMIN_ADDRESS.toLowerCase();
  }, [visitorProfileAddress]); // RADAR_OFFICIAL_ADMIN_ADDRESS is a constant, not a dependency for re-memoization

  const canSaveToHostProfile = useMemo(() => {
    // User can save if they are the owner of the host profile AND not in preview mode.
    // Admin status could grant save permissions even if not owner, but that's not implemented here.
    return isHostProfileOwner && !isPreviewMode;
  }, [isHostProfileOwner, isPreviewMode]);

  const togglePreviewMode = useCallback(() => {
    setIsPreviewMode(prev => !prev);
  }, []); // setIsPreviewMode is stable

  const contextValue = useMemo(() => {
    const val = {
      hostProfileAddress,
      visitorProfileAddress,
      isHostProfileOwner,
      isRadarProjectAdmin,
      isPreviewMode,
      canSaveToHostProfile,
      togglePreviewMode,
    };
    // if (import.meta.env.DEV) {
      // console.log("[UserSessionProvider] Providing contextValue:", val);
    // }
    return val;
  }, [
    hostProfileAddress,
    visitorProfileAddress,
    isHostProfileOwner,
    isRadarProjectAdmin,
    isPreviewMode,
    canSaveToHostProfile,
    togglePreviewMode,
  ]);

  return (
    <UserSessionContext.Provider value={contextValue}>
      {children}
    </UserSessionContext.Provider>
  );
};

UserSessionProvider.propTypes = {
  children: PropTypes.node.isRequired,
};

/**
 * Custom hook to consume the `UserSessionContext`.
 * Provides access to host and visitor profile information, ownership status,
 * admin status, preview mode, and save permissions.
 * Throws an error if used outside of a `UserSessionProvider`.
 *
 * @returns {UserSessionContextValue} The user session context value.
 * @throws {Error} If the hook is not used within a `UserSessionProvider`.
 */
export const useUserSession = () => {
  const context = useContext(UserSessionContext);
  if (context === undefined) { // Standard check for missing provider
    const err = new Error('useUserSession must be used within a UserSessionProvider component.');
    if (import.meta.env.DEV) {
        console.error("useUserSession context details: Attempted to use context but found undefined. This usually means UserSessionProvider is missing as an ancestor.", err.stack);
    }
    throw err;
  }
  return context;
};
```

---
### `src\context\VisualConfigContext.jsx`
```jsx
// src/context/VisualConfigContext.jsx
import React, {
    createContext,
    useContext,
    useState,
    useEffect,
    useCallback,
    useMemo,
  } from "react";
  import PropTypes from "prop-types";

  import { useConfig } from "./ConfigContext"; // Local context
  import { usePresetManagement } from "./PresetManagementContext"; // Local context

  /**
   * @typedef {object} LayerDriftState
   * @property {number} x - Current x offset for drift.
   * @property {number} y - Current y offset for drift.
   * @property {number} phase - Current phase for drift calculation.
   * @property {boolean} enabled - Whether drift is currently active for this layer.
   */

  /**
   * @typedef {object} LayerConfig
   * @property {boolean} enabled - Whether the layer is enabled for rendering.
   * @property {string} blendMode - The CSS `mix-blend-mode` for the layer.
   * @property {number} opacity - The opacity of the layer (0.0 to 1.0).
   * @property {number} size - The size multiplier for the layer's visual content.
   * @property {number} speed - The speed of continuous rotation or other animations.
   * @property {number} drift - The magnitude of the drift effect.
   * @property {number} driftSpeed - The speed of the drift oscillation.
   * @property {number} angle - The base rotation angle of the layer in degrees.
   * @property {number} xaxis - The base X-axis offset for the layer.
   * @property {number} yaxis - The base Y-axis offset for the layer.
   * @property {number} direction - Direction multiplier for speed (-1 or 1).
   * @property {LayerDriftState} driftState - State object managing the drift effect's current position and phase.
   */

  /**
   * @typedef {Object.<string, LayerConfig>} AllLayerConfigs
   * An object where keys are layer IDs (e.g., "1", "2", "3") and values are `LayerConfig` objects.
   */

  /**
   * @typedef {Object.<string, string | object | null>} TokenAssignments
   * An object where keys are layer IDs and values are the assigned token identifiers or image URLs.
   * The value can be a string (e.g., token address, demo key, direct URL) or an object for more complex assignments.
   */

  /**
   * @typedef {object} VisualConfigContextValue
   * @property {AllLayerConfigs} layerConfigs - The current configurations for all visual layers.
   * @property {TokenAssignments} tokenAssignments - The current token/image assignments for all visual layers.
   * @property {(layerId: string | number, key: keyof LayerConfig, value: any) => void} updateLayerConfig - Function to update a specific property of a layer's configuration.
   * @property {(layerId: string | number, tokenId: string | object | null) => void} updateTokenAssignment - Function to update the token or image assigned to a specific layer.
   */


  /**
   * Returns a default template object for a single visual layer's configuration.
   * This ensures a consistent structure for all layers.
   * @returns {LayerConfig} The default layer configuration template.
   */
  const getDefaultLayerConfigTemplate = () => ({
    enabled: true,
    blendMode: "normal",
    opacity: 1.0,
    size: 1.0,
    speed: 0.01,
    drift: 0,
    driftSpeed: 0.1,
    angle: 0,
    xaxis: 0,
    yaxis: 0,
    direction: 1,
    driftState: {
      x: 0,
      y: 0,
      phase: Math.random() * Math.PI * 2, // Random initial phase for variety
      enabled: false,
    },
  });

  /**
   * Returns a default configuration object for all layers.
   * @returns {AllLayerConfigs} The default configurations for layers "1", "2", and "3".
   */
  const getDefaultLayerConfigs = () => ({
    "1": getDefaultLayerConfigTemplate(),
    "2": getDefaultLayerConfigTemplate(),
    "3": getDefaultLayerConfigTemplate(),
  });

  /**
   * Default values for the VisualConfigContext.
   * These are used if a component tries to consume the context without a `VisualConfigProvider`.
   * @type {VisualConfigContextValue}
   */
  export const defaultVisualConfigContextValue = { // Renamed for clarity
    layerConfigs: getDefaultLayerConfigs(),
    tokenAssignments: {},
    updateLayerConfig: (layerId, key, value) => {
      if (import.meta.env.DEV) {
        console.warn("VisualConfigContext: updateLayerConfig called on default context.", { layerId, key, value });
      }
    },
    updateTokenAssignment: (layerId, tokenId) => {
      if (import.meta.env.DEV) {
        console.warn("VisualConfigContext: updateTokenAssignment called on default context.", { layerId, tokenId });
      }
    },
  };

  const VisualConfigContext = createContext(defaultVisualConfigContextValue);

  /**
   * Provides context for managing the visual configurations of different layers
   * and their associated token/image assignments. It synchronizes its state with
   * loaded presets from `PresetManagementContext` and signals pending changes
   * to `ConfigContext`.
   *
   * @param {object} props - The component props.
   * @param {React.ReactNode} props.children - Child components that will consume this context.
   * @returns {JSX.Element} The VisualConfigProvider component.
   */
  export const VisualConfigProvider = ({ children }) => {
    const { setHasPendingChanges: setGlobalHasPendingChanges } = useConfig();
    const {
      configLoadNonce, // Used to detect when a new preset has been loaded
      loadedLayerConfigsFromPreset,
      loadedTokenAssignmentsFromPreset,
    } = usePresetManagement();

    /** @type {[AllLayerConfigs, React.Dispatch<React.SetStateAction<AllLayerConfigs>>]} */
    const [layerConfigs, setLayerConfigsInternal] = useState(() => {
      // Initialize with preset data if available, otherwise defaults
      return loadedLayerConfigsFromPreset || getDefaultLayerConfigs();
    });

    /** @type {[TokenAssignments, React.Dispatch<React.SetStateAction<TokenAssignments>>]} */
    const [tokenAssignments, setTokenAssignmentsInternal] = useState(() => {
      return loadedTokenAssignmentsFromPreset || {};
    });

    // Effect to synchronize with loaded preset data from PresetManagementContext
    useEffect(() => {
      if (import.meta.env.DEV) {
        // console.log(`[VisualConfigContext useEffect] Nonce: ${configLoadNonce}. Syncing with PresetManagement.`);
        // console.log(`[VisualConfigContext useEffect] Received loadedLayerConfigsFromPreset:`, loadedLayerConfigsFromPreset ? JSON.parse(JSON.stringify(loadedLayerConfigsFromPreset)) : null);
        // console.log(`[VisualConfigContext useEffect] Received loadedTokenAssignmentsFromPreset:`, loadedTokenAssignmentsFromPreset ? JSON.parse(JSON.stringify(loadedTokenAssignmentsFromPreset)) : null);
      }

      // When a new preset is loaded (indicated by configLoadNonce changing),
      // update the local layerConfigs and tokenAssignments.
      // The PresetManagementContext is responsible for ensuring loadedLayerConfigsFromPreset
      // has a complete structure for each layer.
      if (loadedLayerConfigsFromPreset) {
        if (import.meta.env.DEV) {
            // console.log("[VisualConfigContext useEffect] Setting layerConfigs from preset.");
        }
        setLayerConfigsInternal(loadedLayerConfigsFromPreset);
      } else {
        // This case might occur if PresetManagementContext resets to no loaded preset
        if (import.meta.env.DEV) {
            // console.log("[VisualConfigContext useEffect] No loadedLayerConfigsFromPreset, setting to default layers.");
        }
        setLayerConfigsInternal(getDefaultLayerConfigs());
      }

      if (loadedTokenAssignmentsFromPreset) {
        if (import.meta.env.DEV) {
            // console.log("[VisualConfigContext useEffect] Setting tokenAssignments from preset.");
        }
        setTokenAssignmentsInternal(loadedTokenAssignmentsFromPreset);
      } else {
        if (import.meta.env.DEV) {
            // console.log("[VisualConfigContext useEffect] No loadedTokenAssignmentsFromPreset, setting to {}.");
        }
        setTokenAssignmentsInternal({});
      }
      // configLoadNonce is the primary trigger for this effect.
      // loadedLayerConfigsFromPreset and loadedTokenAssignmentsFromPreset are data associated with that nonce.
    }, [
      configLoadNonce,
      loadedLayerConfigsFromPreset,
      loadedTokenAssignmentsFromPreset,
    ]);

    /**
     * Updates a specific property of a layer's configuration.
     * Also signals that there are pending global changes.
     * @param {string | number} layerId - The ID of the layer to update.
     * @param {keyof LayerConfig} key - The configuration key to update.
     * @param {any} value - The new value for the configuration property.
     */
    const updateLayerConfig = useCallback(
      (layerId, key, value) => {
        setLayerConfigsInternal((prevConfigs) => ({
          ...prevConfigs,
          [String(layerId)]: {
            ...(prevConfigs[String(layerId)] || getDefaultLayerConfigTemplate()), // Ensure layer exists
            [key]: value,
          },
        }));
        if (setGlobalHasPendingChanges) {
          setGlobalHasPendingChanges(true);
        }
      },
      [setGlobalHasPendingChanges], // setGlobalHasPendingChanges is from useConfig, assumed stable
    );

    /**
     * Updates the token or image assigned to a specific layer.
     * Also signals that there are pending global changes.
     * @param {string | number} layerId - The ID of the layer to update.
     * @param {string | object | null} tokenId - The new token identifier, image URL, or null to clear.
     */
    const updateTokenAssignment = useCallback(
      (layerId, tokenId) => {
        setTokenAssignmentsInternal((prevAssignments) => ({
          ...prevAssignments,
          [String(layerId)]: tokenId, // tokenId can be null to clear assignment
        }));
        if (setGlobalHasPendingChanges) {
          setGlobalHasPendingChanges(true);
        }
      },
      [setGlobalHasPendingChanges], // setGlobalHasPendingChanges is from useConfig, assumed stable
    );

    const contextValue = useMemo(
      () => ({
        layerConfigs,
        tokenAssignments,
        updateLayerConfig,
        updateTokenAssignment,
      }),
      [layerConfigs, tokenAssignments, updateLayerConfig, updateTokenAssignment],
    );

    return (
      <VisualConfigContext.Provider value={contextValue}>
        {children}
      </VisualConfigContext.Provider>
    );
  };

  VisualConfigProvider.propTypes = {
    children: PropTypes.node.isRequired,
  };

  /**
   * Custom hook to consume the `VisualConfigContext`.
   * Provides access to the current layer configurations, token assignments,
   * and functions to update them.
   *
   * @returns {VisualConfigContextValue} The visual configuration context value.
   * @throws {Error} If used outside of a `VisualConfigProvider`.
   */
  export const useVisualConfig = () => {
    const context = useContext(VisualConfigContext);
    if (context === undefined) { // Standard check for missing provider
      const err = new Error(
        "useVisualConfig must be used within a VisualConfigProvider"
      );
      if (import.meta.env.DEV) {
        console.error("useVisualConfig context details: Attempted to use context but found undefined. This usually means VisualConfigProvider is missing as an ancestor.", err.stack);
      }
      throw err;
    }
    return context;
  };
```

---
### `src\dump_to_md.py`
```py
import os
from pathlib import Path

# === CONFIGURATION ===
project_root = Path(__file__).resolve().parent.parent  # you're in src/, go one level up
exclude_dirs = {"node_modules", "dist", "assets", ".git", ".vscode", "__pycache__"}
exclude_files = {"package-lock.json"}

output_file = project_root / "full_codebase_dump.md"
allowed_suffixes = {".js", ".jsx", ".ts", ".tsx", ".css", ".json", ".html", ".md", ".py"}

# === FORMATTER ===
def format_file(file_path: Path):
    suffix = file_path.suffix.lstrip(".")
    try:
        content = file_path.read_text(encoding="utf-8")
    except Exception as e:
        content = f"Error reading file: {e}"
    return f"\n---\n### `{file_path.relative_to(project_root)}`\n```{suffix}\n{content}\n```\n"

# === FILE COLLECTOR ===
def collect_files(root: Path):
    files = []
    for path in root.rglob("*"):
        if (
            path.is_file() and
            path.suffix in allowed_suffixes and
            not any(part in exclude_dirs for part in path.parts) and
            path.name not in exclude_files
        ):
            files.append(path)
    return sorted(files)

# === MAIN ===
if __name__ == "__main__":
    print("🔍 Scanning project files...")
    all_files = collect_files(project_root)
    print(f"📄 Found {len(all_files)} files.")

    print(f"✍️ Writing to {output_file.name}...")
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("# 📦 Full Codebase Dump\n")
        for file in all_files:
            f.write(format_file(file))
    
    print("✅ Full markdown dump complete!")

```

---
### `src\effects\ColorOverlayEffect.js`
```js
// src/effects/ColorOverlayEffect.js
import VisualEffect from "./VisualEffect"; // Local base class

/**
 * @typedef {object} ColorOverlayConfig
 * @property {string} [color='rgba(255, 0, 0, 0.3)'] - The color of the overlay (CSS color string).
 * @property {number} [pulseCount=3] - The number of times the overlay will pulse (fade in and out).
 * @property {number} [duration=3000] - The total duration of the effect in milliseconds.
 * @property {number} [fadeOutDuration] - Duration for the final fade out of the overlay. Defaults to 40% of `duration`.
 * @property {string} [easing='cubic-bezier(0.4, 0, 0.2, 1)'] - CSS easing function for the pulse transitions.
 * @property {string} [mixBlendMode='overlay'] - CSS mix-blend-mode for the overlay.
 */

/**
 * Creates a pulsating color overlay effect on a target canvas layer
 * or globally on the main canvas container. The color, pulse count, and duration
 * are configurable via the `config` property inherited from VisualEffect.
 * This effect works by dynamically adding and animating a DOM element overlay.
 *
 * @extends VisualEffect
 */
class ColorOverlayEffect extends VisualEffect {
  /**
   * Applies the color overlay effect by creating and animating a DOM element.
   *
   * @returns {import('../utils/VisualEffectsProcessor').EffectControlAPI} A control object including `effectId`, `layer`, and a `clear` method to stop and remove the effect.
   */
  apply() { // Removed _updateLayerConfig as it's unused in this specific effect
    const { layer } = this;
    /** @type {ColorOverlayConfig} */
    const effectSpecificConfig = this.config || {};

    const {
      color = "rgba(255, 0, 0, 0.3)",
      pulseCount = 3,
      duration = 3000,
      fadeOutDuration = duration * 0.4,
      easing = "cubic-bezier(0.4, 0, 0.2, 1)",
      mixBlendMode = "overlay",
    } = effectSpecificConfig;

    const logPrefix = `[ColorOverlayEffect ${this.effectId}]`;
    /** @type {HTMLElement | null} */
    let targetElement = null;
    let zIndexBase = 1;

    if (layer === 'global') {
        targetElement = document.querySelector('.canvas-container');
        if (targetElement) {
            zIndexBase = 10;
        } else if (import.meta.env.DEV) {
            console.error(`${logPrefix} Failed to find .canvas-container element for global overlay!`);
        }
    } else {
        const layerSelector = `.canvas.layer-${layer}`;
        targetElement = document.querySelector(layerSelector);
        if (targetElement) {
            const targetZIndex = parseInt(targetElement.style.zIndex || '', 10);
            zIndexBase = isNaN(targetZIndex) ? (parseInt(String(layer), 10) + 2) : targetZIndex;
        } else if (import.meta.env.DEV) {
             console.warn(`${logPrefix} Canvas element not found using selector: ${layerSelector}`);
        }
    }

    if (!targetElement) {
      if (import.meta.env.DEV) {
        console.error(`${logPrefix} No target element found to apply overlay.`);
      }
      return {
        effectId: this.effectId,
        layer: layer,
        type: this.type,
        config: this.config,
        clear: () => this.cleanup(),
      };
    }

    const existingOverlay = document.getElementById(`color-overlay-${this.effectId}`);
    if (existingOverlay) {
      existingOverlay.remove();
    }

    const overlayId = `color-overlay-${this.effectId}`;
    const overlay = document.createElement("div");
    overlay.id = overlayId;
    overlay.classList.add("color-overlay-effect");
    Object.assign(overlay.style, {
        position: "absolute",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        background: color,
        pointerEvents: "none",
        zIndex: (zIndexBase + 10).toString(),
        opacity: "0",
        transition: `opacity ${duration / (pulseCount * 2)}ms ${easing}`,
        mixBlendMode: mixBlendMode,
    });

    targetElement.appendChild(overlay);

    let currentPulse = 0;
    let isVisible = false;
    let isCleanedUp = false;

    const pulse = () => {
      if (isCleanedUp || !overlay || !overlay.isConnected) return;

      isVisible = !isVisible;
      overlay.style.opacity = isVisible ? "1" : "0";

      if (!isVisible) {
        currentPulse++;
      }

      if (currentPulse >= pulseCount) {
        this.addTimeout(
          "final_fade_out",
          () => {
            if (isCleanedUp || !overlay || !overlay.isConnected) return;
            overlay.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
            overlay.style.opacity = "0";
            this.addTimeout(
              "remove_element",
              () => {
                if (overlay?.parentNode) {
                   overlay.remove();
                }
              },
              fadeOutDuration + 100,
            );
          },
          duration / (pulseCount * 2),
        );
        return;
      }

      this.addTimeout(
        `pulse-${currentPulse}-${isVisible ? "on" : "off"}`,
        pulse,
        duration / (pulseCount * 2),
      );
    };

    this.addTimeout("start_pulse", pulse, 50);

    return {
      effectId: this.effectId,
      layer: layer,
      type: this.type,
      config: this.config,
      clear: () => {
        if (isCleanedUp) return;
        isCleanedUp = true;
        this.cleanup();
      },
    };
  }

  /**
   * Overrides the base cleanup method to specifically handle the removal
   * of the DOM element created by this effect.
   */
  cleanup() {
    super.cleanup();

    const overlayId = `color-overlay-${this.effectId}`;
    const overlayElement = document.getElementById(overlayId);

    if (overlayElement) {
      if (overlayElement.style.opacity !== "0") {
        overlayElement.style.transition = "opacity 150ms ease-out";
        overlayElement.style.opacity = "0";
        setTimeout(() => {
          if (overlayElement.parentNode) {
            overlayElement.remove();
          }
        }, 150);
      } else if (overlayElement.parentNode) {
        overlayElement.remove();
      }
    }
  }
}

export default ColorOverlayEffect;
```

---
### `src\effects\EffectFactory.js`
```js
// src/effects/EffectFactory.js
import ColorOverlayEffect from "./ColorOverlayEffect"; // Local effect class
// import ParticleBurstEffect from "./ParticleBurstEffect"; // Example for future expansion
// import VisualEffect from "./VisualEffect"; // Base class, for type hinting if needed

/**
 * @typedef {import('./VisualEffect').default} VisualEffect - Base class for all visual effects.
 * @typedef {import('../utils/VisualEffectsProcessor').EffectConfigInput} EffectConfigInput - Input config for effects.
 */

/**
 * EffectFactory: A factory class responsible for creating instances
 * of different visual effect classes based on a given type string.
 * This allows for easy extension with new effect types without modifying
 * the core effect processing logic.
 */
class EffectFactory {
  /**
   * Creates an instance of a specific VisualEffect subclass based on the `effectType`.
   * If the `effectType` is unknown or not explicitly handled, it falls back to
   * creating a `ColorOverlayEffect` as a default.
   *
   * @param {string} effectType - The type of effect to create (e.g., 'color_overlay').
   * @param {EffectConfigInput} options - Configuration options to pass to the effect constructor.
   *                                      These options typically include `layer`, `config`, `effectId`, etc.
   * @returns {VisualEffect} An instance of the requested (or fallback) effect class,
   *                         which should extend `VisualEffect`.
   */
  static createEffect(effectType, options) {
    switch (effectType) {
      case "color_overlay":
        return new ColorOverlayEffect(options);
      // Example for future expansion:
      // case "particle_burst":
      //   return new ParticleBurstEffect(options);
      default:
        if (import.meta.env.DEV) {
          // Keep warning for unknown types, as it indicates a potential configuration issue or missing effect class.
          console.warn(
            `[EffectFactory] Unknown effect type: '${effectType}'. Falling back to 'color_overlay'.`,
          );
        }
        // Fallback to a default effect (ColorOverlayEffect in this case)
        // Ensure the options passed are still compatible or handled gracefully by the fallback.
        return new ColorOverlayEffect({ ...options, type: 'color_overlay' });
    }
  }
}

export default EffectFactory;
```

---
### `src\effects\VisualEffect.js`
```js
// src/effects/VisualEffect.js

/**
 * @typedef {object} VisualEffectOptions
 * @property {string} [effectId] - Optional unique ID for the effect. If not provided, one will be generated.
 * @property {string|number} layer - The target layer ID for the effect (e.g., 'global', 1, 2, 3).
 * @property {object} [config={}] - Effect-specific configuration options. Structure depends on the concrete effect class.
 * @property {boolean} [preserveAnimation=false] - A hint indicating whether underlying canvas animations on the target layer should be preserved or potentially paused while this effect is active.
 * @property {string} [type] - The type identifier of the effect (e.g., 'color_overlay'). Often added by the factory or processor.
 */

/**
 * @typedef {object} EffectControlAPI
 * @property {string} effectId - The unique ID of this effect instance.
 * @property {string|number} layer - The target layer of this effect.
 * @property {() => void} clear - A function to manually stop and clean up this effect instance.
 * @property {string} [type] - The type of the effect.
 * @property {object} [config] - The configuration used for this effect instance.
 */

/**
 * VisualEffect: Base class for all visual effects within the application.
 * Provides common properties like ID, layer target, configuration, duration,
 * and methods for applying the effect, cleaning up resources (timeouts),
 * and common helper functions (like easing).
 *
 * Subclasses must implement the `apply` method.
 */
class VisualEffect {
  /** @type {string} Unique identifier for this effect instance. */
  effectId;
  /** @type {string|number} The layer this effect targets. */
  layer;
  /** @type {object} Effect-specific configuration. */
  config;
  /** @type {number} Default or configured duration of the effect in milliseconds. */
  duration;
  /** @type {boolean} Hint for animation preservation. */
  preserveAnimation;
  /** @type {string | undefined} The type identifier of the effect. */
  type;
  /** @type {Map<string, ReturnType<typeof setTimeout>>} Stores managed timeouts for automatic cleanup. Keyed by a unique ID. */
  timeouts = new Map();

  /**
   * Creates an instance of VisualEffect.
   * @param {VisualEffectOptions} options - Configuration options for the effect.
   */
  constructor(options) {
    this.effectId =
      options.effectId ||
      `effect_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`; // Increased randomness part
    this.layer = options.layer;
    this.config = options.config || {};
    this.duration = typeof this.config.duration === 'number' ? this.config.duration : 3000; // Default duration if not in config
    this.preserveAnimation = options.preserveAnimation || false;
    this.type = options.type; // Store the type if provided
    this.timeouts = new Map();
  }

  /**
   * Abstract method to apply the visual effect. Must be implemented by subclasses.
   * @param {(layerId: string | number, key: string, value: any) => void} [_updateLayerConfig] - Optional function to potentially update layer config (may not be used by all effects).
   * @returns {EffectControlAPI} A control object, typically including { effectId, layer, type, config, clear() }.
   * @throws {Error} If the method is not implemented by a subclass.
   */
  // eslint-disable-next-line no-unused-vars
  apply(_updateLayerConfig) {
    // This JSDoc comment is for the abstract method, ESLint will still warn if the param is unused in subclasses.
    // Subclasses should decide if they need to use it or can omit it from their signature if truly unused.
    throw new Error("Method 'apply' must be implemented by subclasses of VisualEffect.");
  }

  /**
   * Cleans up any resources used by the effect, primarily clearing all managed timeouts.
   * Subclasses can override this to add specific cleanup logic (e.g., removing DOM elements),
   * but they should call `super.cleanup()` to ensure timeouts are cleared.
   * @returns {void}
   */
  cleanup() {
    for (const timeoutId of this.timeouts.values()) {
      clearTimeout(timeoutId);
    }
    this.timeouts.clear();
    // if (import.meta.env.DEV) {
    //   console.log(`[VisualEffect ${this.effectId}] Cleaned up timeouts.`);
    // }
  }

  // --- Helper methods potentially useful for subclasses ---

  /**
   * Quadratic easing in/out function.
   * f(t) = t < 0.5 ? 2 * t^2 : 1 - (-2 * t + 2)^2 / 2
   * @param {number} t - Progress ratio (0 to 1).
   * @returns {number} Eased value.
   */
  easeInOutQuad(t) {
    // Ensure t is clamped between 0 and 1
    const clampedT = Math.max(0, Math.min(1, t));
    return clampedT < 0.5 ? 2 * clampedT * clampedT : 1 - Math.pow(-2 * clampedT + 2, 2) / 2;
  }

  /**
   * Elastic easing out function.
   * Provides a bouncy, elastic effect at the end of the animation.
   * @param {number} t - Progress ratio (0 to 1).
   * @returns {number} Eased value.
   */
  easeOutElastic(t) {
    // Ensure t is clamped between 0 and 1
    const clampedT = Math.max(0, Math.min(1, t));
    const c4 = (2 * Math.PI) / 3;

    if (clampedT === 0) return 0;
    if (clampedT === 1) return 1;

    return Math.pow(2, -10 * clampedT) * Math.sin((clampedT * 10 - 0.75) * c4) + 1;
  }

  /**
   * Adds a timeout to the internal map for automatic cleanup via `this.cleanup()`.
   * If a timeout with the same `id` already exists, it is cleared before setting the new one.
   * The timeout is removed from the map once its callback is executed.
   *
   * @param {string} id - A unique identifier for the timeout within this effect instance.
   * @param {() => void} callback - The function to execute after the delay.
   * @param {number} delay - The delay in milliseconds.
   * @returns {ReturnType<typeof setTimeout>} The timeout ID (NodeJS.Timeout or number).
   */
  addTimeout(id, callback, delay) {
    // Clear existing timeout with the same ID if present
    if (this.timeouts.has(id)) {
        const existingTimeoutId = this.timeouts.get(id);
        if (existingTimeoutId) clearTimeout(existingTimeoutId);
    }

    const timeoutId = setTimeout(() => {
        this.timeouts.delete(id); // Remove from map once executed or cleared
        try {
            callback();
        } catch (e) {
            if (import.meta.env.DEV) {
                console.error(`[VisualEffect ${this.effectId}] Error in timeout callback for ID '${id}':`, e);
            }
        }
    }, delay);

    this.timeouts.set(id, timeoutId);
    return timeoutId;
  }
}

export default VisualEffect;
```

---
### `src\hooks\configSelectors.js`
```js
import { useMemo } from 'react';

import { useConfig } from '../context/ConfigContext.jsx';
import { useUserSession } from '../context/UserSessionContext.jsx';
import { useVisualConfig } from '../context/VisualConfigContext.jsx';
import { usePresetManagement } from '../context/PresetManagementContext.jsx';
import { useUpProvider } from '../context/UpProvider.jsx';

/**
 * @typedef {object} VisualLayerState
 * @property {object} layerConfigs - Configuration for visual layers of the host profile. Sourced from `VisualConfigContext`.
 * @property {object} tokenAssignments - Mapping of layer IDs to token identifiers or image URLs for the host profile. Sourced from `VisualConfigContext`.
 * @property {(layerId: string | number, key: string, value: any) => void} updateLayerConfig - Updates a specific property of a layer's configuration for the host profile. From `VisualConfigContext`.
 * @property {(layerId: string | number, tokenId: string | object | null) => void} updateTokenAssignment - Updates the token assigned to a layer for the host profile. From `VisualConfigContext`.
 */

/**
 * Custom hook to provide a memoized subset of state from `VisualConfigContext`
 * related to visual layer configurations and token assignments for the host profile.
 * @returns {VisualLayerState} An object containing visual layer state and update functions.
 */
export const useVisualLayerState = () => {
  const visualCtx = useVisualConfig();
  return useMemo(() => ({
    layerConfigs: visualCtx.layerConfigs,
    tokenAssignments: visualCtx.tokenAssignments,
    updateLayerConfig: visualCtx.updateLayerConfig,
    updateTokenAssignment: visualCtx.updateTokenAssignment,
  }), [visualCtx.layerConfigs, visualCtx.tokenAssignments, visualCtx.updateLayerConfig, visualCtx.updateTokenAssignment]);
};

/**
 * @typedef {object} PresetManagementState
 * @property {string | null} currentConfigName - Name of the currently loaded visual preset for the host profile.
 * @property {Array<{name: string}>} savedConfigList - List of saved visual preset names for the host profile.
 * @property {boolean} isLoading - True when loading a preset or the list of presets for the host profile.
 * @property {Error | string | null} loadError - Error from the last preset load attempt for the host profile.
 * @property {boolean} isSaving - True when saving or deleting a preset for the host profile.
 * @property {Error | string | null} saveError - Error from the last preset save/delete attempt for the host profile.
 * @property {boolean} saveSuccess - True if the last save/delete operation for the host profile was successful.
 * @property {(nameToSave: string, setAsDefault: boolean, includeReactions: boolean, includeMidi: boolean, layerConfigsToSave: object, tokenAssignmentsToSave: object) => Promise<{success: boolean, error?: string}>} saveVisualPreset - Saves the current visual configuration as a preset to the host profile.
 * @property {(name: string) => Promise<{success: boolean, error?: string, config?: object | null}>} loadNamedConfig - Loads a specific named configuration from the host profile.
 * @property {() => Promise<{success: boolean, error?: string, config?: object | null}>} loadDefaultConfig - Loads the default configuration for the host profile.
 * @property {() => Promise<{success: boolean, list?: Array<{name: string}>, error?: string}>} loadSavedConfigList - Reloads the list of saved configurations from the host profile.
 * @property {(nameToDelete: string) => Promise<{success: boolean, error?: string}>} deleteNamedConfig - Deletes a named configuration from the host profile.
 * @property {object | null} loadedLayerConfigsFromPreset - The layer configurations loaded from the most recent preset for the host profile.
 * @property {object | null} loadedTokenAssignmentsFromPreset - The token assignments loaded from the most recent preset for the host profile.
 */

/**
 * Custom hook to provide a memoized subset of state from `PresetManagementContext`
 * related to managing visual presets for the host profile.
 * @returns {PresetManagementState} An object containing preset management state and functions.
 */
export const usePresetManagementState = () => {
  const presetCtx = usePresetManagement();
  return useMemo(() => ({
    currentConfigName: presetCtx.currentConfigName,
    savedConfigList: presetCtx.savedConfigList,
    isLoading: presetCtx.isLoading,
    loadError: presetCtx.loadError,
    isSaving: presetCtx.isSaving,
    saveError: presetCtx.saveError,
    saveSuccess: presetCtx.saveSuccess,
    saveVisualPreset: presetCtx.saveVisualPreset,
    loadNamedConfig: presetCtx.loadNamedConfig,
    loadDefaultConfig: presetCtx.loadDefaultConfig,
    loadSavedConfigList: presetCtx.loadSavedConfigList,
    deleteNamedConfig: presetCtx.deleteNamedConfig,
    loadedLayerConfigsFromPreset: presetCtx.loadedLayerConfigsFromPreset,
    loadedTokenAssignmentsFromPreset: presetCtx.loadedTokenAssignmentsFromPreset,
  }), [
    presetCtx.currentConfigName, presetCtx.savedConfigList, presetCtx.isLoading, presetCtx.loadError,
    presetCtx.isSaving, presetCtx.saveError, presetCtx.saveSuccess, presetCtx.saveVisualPreset,
    presetCtx.loadNamedConfig, presetCtx.loadDefaultConfig, presetCtx.loadSavedConfigList, presetCtx.deleteNamedConfig,
    presetCtx.loadedLayerConfigsFromPreset, presetCtx.loadedTokenAssignmentsFromPreset,
  ]);
};

/**
 * @typedef {object} InteractionSettingsState
 * @property {object} savedReactions - User-defined reactions to blockchain events for the host profile. Sourced from `ConfigContext`.
 * @property {object} midiMap - User's global MIDI controller mappings stored on the host profile. Sourced from `ConfigContext`.
 * @property {(eventType: string, reactionData: object) => void} updateSavedReaction - Adds or updates a specific event reaction configuration for the host profile. From `ConfigContext`.
 * @property {(eventType: string) => void} deleteSavedReaction - Removes an event reaction configuration for the host profile. From `ConfigContext`.
 * @property {(newMap: object) => void} updateMidiMap - Replaces the entire MIDI map configuration for the host profile. From `ConfigContext`.
 * @property {() => Promise<{success: boolean, error?: string}>} saveGlobalReactions - Saves only the global event reactions to the host profile. From `ConfigContext`.
 * @property {() => Promise<{success: boolean, error?: string}>} saveGlobalMidiMap - Saves only the global MIDI map to the host profile. From `ConfigContext`.
 */

/**
 * Custom hook to provide a memoized subset of state from `ConfigContext`
 * related to user-defined event reactions and MIDI mappings for the host profile.
 * @returns {InteractionSettingsState} An object containing interaction settings state and update functions.
 */
export const useInteractionSettingsState = () => {
  const ctx = useConfig();
  return useMemo(() => ({
    savedReactions: ctx.savedReactions,
    midiMap: ctx.midiMap,
    updateSavedReaction: ctx.updateSavedReaction,
    deleteSavedReaction: ctx.deleteSavedReaction,
    updateMidiMap: ctx.updateMidiMap,
    saveGlobalReactions: ctx.saveGlobalReactions,
    saveGlobalMidiMap: ctx.saveGlobalMidiMap,
  }), [
    ctx.savedReactions, ctx.midiMap, ctx.updateSavedReaction, ctx.deleteSavedReaction,
    ctx.updateMidiMap, ctx.saveGlobalReactions, ctx.saveGlobalMidiMap,
  ]);
};

/**
 * @typedef {object} ProfileSessionState
 * @property {string | null} currentProfileAddress - Address of the Universal Profile being viewed (host). Sourced from `UserSessionContext` (originally `hostProfileAddress`).
 * @property {string | null} visitorUPAddress - Address of the visitor's Universal Profile. Sourced from `UserSessionContext` (originally `visitorProfileAddress`).
 * @property {boolean} isProfileOwner - True if `visitorUPAddress` matches `currentProfileAddress` (i.e., visitor is owner of host profile). Sourced from `UserSessionContext` (originally `isHostProfileOwner`).
 * @property {boolean} isVisitor - True if visitor is not the owner of the host profile. Derived from `isProfileOwner`.
 * @property {boolean} canSave - True if the current user has permissions to save changes to the host profile. Sourced from `UserSessionContext` (originally `canSaveToHostProfile`).
 * @property {boolean} canInteract - True if the current user can interact with controls (not read-only due to preview or not being owner/admin). Derived.
 * @property {boolean} isPreviewMode - True if the app is in a special preview/demo mode. Sourced from `UserSessionContext`.
 * @property {() => void} togglePreviewMode - Toggles the preview mode. From `UserSessionContext`.
 * @property {boolean} isParentAdmin - True if the current visitor is the RADAR project admin. Sourced from `UserSessionContext` (originally `isRadarProjectAdmin`).
 */

/**
 * Custom hook to provide a memoized subset of state from `UserSessionContext`
 * related to the current profile, visitor, permissions, and application mode.
 * It renames some properties from the context for clarity or specific use in consuming components.
 * @returns {ProfileSessionState} An object containing profile and session state.
 */
export const useProfileSessionState = () => {
  const sessionCtx = useUserSession();
  if (import.meta.env.DEV) {
    // console.log("[useProfileSessionState] Consumed sessionCtx from useUserSession:", sessionCtx);
  }

  return useMemo(() => {
    const {
      hostProfileAddress,
      visitorProfileAddress,
      isHostProfileOwner,
      isRadarProjectAdmin,
      isPreviewMode,
      canSaveToHostProfile,
      togglePreviewMode,
    } = sessionCtx;

    if (import.meta.env.DEV) {
      // console.log("[useProfileSessionState useMemo] hostProfileAddress from sessionCtx:", hostProfileAddress);
    }

    // Allow interaction if a host profile is being viewed and not in preview mode.
    // Actual saving is gated by `canSaveToHostProfile`.
    const canInteract = !!hostProfileAddress && !isPreviewMode;
    
    const returnValue = {
      currentProfileAddress: hostProfileAddress, 
      visitorUPAddress: visitorProfileAddress,
      isProfileOwner: isHostProfileOwner,
      isVisitor: !isHostProfileOwner, // Derived: True if visitor is not the owner
      canSave: canSaveToHostProfile, 
      canInteract,
      isPreviewMode: isPreviewMode,
      togglePreviewMode: togglePreviewMode,
      isParentAdmin: isRadarProjectAdmin,
    };

    if (import.meta.env.DEV) {
      // console.log("[useProfileSessionState useMemo] Returning value:", returnValue);
    }
    return returnValue;
  }, [sessionCtx]);
};

/**
 * @typedef {object} PendingChangesState
 * @property {boolean} hasPendingChanges - True if local configuration of the host profile differs from its last saved state. Sourced from `ConfigContext`.
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setHasPendingChanges - Manually sets the pending changes flag. From `ConfigContext`.
 */

/**
 * Custom hook to provide a memoized subset of state from `ConfigContext`
 * related to pending unsaved changes for the host profile.
 * @returns {PendingChangesState} An object containing pending changes state.
 */
export const usePendingChangesState = () => {
  const ctx = useConfig();
  return useMemo(() => ({
    hasPendingChanges: ctx.hasPendingChanges,
    setHasPendingChanges: ctx.setHasPendingChanges,
  }), [ctx.hasPendingChanges, ctx.setHasPendingChanges]);
};

/**
 * @typedef {object} ConfigStatusState
 * @property {boolean} isLoading - True if a preset for the host profile is currently being loaded or list is being fetched. Sourced from `PresetManagementContext`.
 * @property {boolean} isInitiallyResolved - True once the very first attempt to load the host profile's preset (or fallback) is done. Sourced from `PresetManagementContext`.
 * @property {boolean} configServiceInstanceReady - True if ConfigurationService is instantiated and has its clients. Sourced from `ConfigContext`.
 * @property {number} configLoadNonce - Increments each time a new configuration preset for the host profile is successfully applied. Sourced from `PresetManagementContext`.
 * @property {React.RefObject<import('../services/ConfigurationService.js').default | null>} configServiceRef - Ref to the ConfigurationService instance. Sourced from `ConfigContext`.
 * @property {Error | string | null} loadError - Error from the last preset load attempt for the host profile. Sourced from `PresetManagementContext`.
 * @property {Error | null} upInitializationError - Error from UpProvider initialization. Sourced from `UpProvider`.
 * @property {Error | null} upFetchStateError - Error from UpProvider client fetching. Sourced from `UpProvider`.
 */

/**
 * Custom hook to aggregate and provide memoized status indicators related to
 * configuration loading, service readiness, and UPProvider state for the host profile.
 * @returns {ConfigStatusState} An object containing various configuration and provider status flags and errors.
 */
export const useConfigStatusState = () => {
  const configCtx = useConfig();
  const presetCtx = usePresetManagement();
  const upCtx = useUpProvider(); 

  const memoizedValue = useMemo(() => {
    const val = {
      isLoading: presetCtx.isLoading,
      isInitiallyResolved: presetCtx.isInitiallyResolved,
      configServiceInstanceReady: configCtx.configServiceInstanceReady,
      configLoadNonce: presetCtx.configLoadNonce,
      configServiceRef: configCtx.configServiceRef,
      loadError: presetCtx.loadError,
      upInitializationError: upCtx.initializationError, 
      upFetchStateError: upCtx.fetchStateError,       
    };
    return val;
  }, [
    presetCtx.isLoading, presetCtx.isInitiallyResolved, presetCtx.configLoadNonce, presetCtx.loadError,
    configCtx.configServiceInstanceReady, configCtx.configServiceRef,
    upCtx.initializationError, upCtx.fetchStateError, 
  ]);

  return memoizedValue;
};
```

---
### `src\hooks\useAnimationLifecycleManager.js`
```js
// src/hooks/useAnimationLifecycleManager.js
import { useEffect, useRef } from 'react';

import { globalAnimationFlags } from "../utils/globalAnimationFlags"; // Local utility

const ANIMATION_RESTART_DELAY = 16; // ms

/**
 * Manages the lifecycle of canvas animations based on component mount state,
 * visibility, UI interactions (panels, overlays), and explicit transition states.
 * It decides when to start or stop animations to optimize performance and ensure
 * visual correctness during UI changes or when the canvas is not visible.
 * Uses a small delay before restarting animations to allow UI to settle.
 *
 * This version uses an internal ref (`lastActionRef`) to track its last commanded
 * state (start/stop), making its decision to issue a new command more robust
 * independently of an external `isAnimating` prop that might not be perfectly in sync.
 *
 * @param {object} params - Parameters for the animation lifecycle manager.
 * @param {boolean} params.isMounted - Indicates if the component consuming this hook is fully mounted.
 * @param {string} params.renderState - The current rendering state of the visual component (e.g., "rendered", "loading").
 * @param {boolean} params.isContainerObservedVisible - Flag indicating if the main visual container is visible, typically determined by an IntersectionObserver.
 * @param {boolean} params.isBenignOverlayActive - Flag indicating if a non-blocking overlay (e.g., toasts, temporary messages) is currently active, which might warrant continued animation.
 * @param {string | null} params.animatingPanel - Identifier of any UI panel that is currently undergoing an open/close animation. (Logged for debugging; not directly used in the core animation start/stop decision logic of this hook version).
 * @param {boolean} params.isTransitioning - Flag indicating if a visual preset transition or an initial load animation sequence is active. Animations should generally run during transitions.
 * @param {() => void} params.restartCanvasAnimations - Callback function to be invoked when animations should (re)start.
 * @param {() => void} params.stopCanvasAnimations - Callback function to be invoked when animations should stop.
 * @returns {void} This hook does not return a value but manages side effects.
 */
export function useAnimationLifecycleManager({
  isMounted,
  renderState,
  isContainerObservedVisible,
  isBenignOverlayActive,
  animatingPanel, // Keep for logging, though not in core logic here
  isTransitioning,
  restartCanvasAnimations,
  stopCanvasAnimations,
}) {
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const animationStartTimerRef = useRef(null);
  /** @type {React.RefObject<'start' | 'stop' | null>} */
  const lastActionRef = useRef(null); // Tracks the last action taken by this hook

  useEffect(() => {
    const timestamp = performance.now();
    if (import.meta.env.DEV) {
        // Updated log to show last commanded action by this hook
        console.log(`[AnimLC ${timestamp.toFixed(0)}] EFFECT RUN. LastCmd: ${lastActionRef.current}, isTokenSelectorOpening: ${globalAnimationFlags.isTokenSelectorOpening}, IOVisible: ${isContainerObservedVisible}, BenignActive: ${isBenignOverlayActive}, AnimPanel: ${animatingPanel}, IsTransitioning: ${isTransitioning}, RenderState: ${renderState}`);
    }

    if (!isMounted || !restartCanvasAnimations || !stopCanvasAnimations) {
      if (import.meta.env.DEV) {
        console.log(`[AnimLC ${timestamp.toFixed(0)}] Aborting: Not mounted or animation functions missing.`);
      }
      return;
    }

    // Clear any pending restart timeout from a previous run of this effect
    if (animationStartTimerRef.current) {
      clearTimeout(animationStartTimerRef.current);
      animationStartTimerRef.current = null;
    }

    let shouldRunAnimations;
    // Determine if animations should be running based on current state
    if (globalAnimationFlags.isTokenSelectorOpening) {
      shouldRunAnimations = true;
      if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Condition Eval: RUN (GlobalFlag Override: isTokenSelectorOpening)`);
    } else if (isTransitioning) {
      shouldRunAnimations = true;
      if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Condition Eval: RUN (Preset Transition active)`);
    } else if (isBenignOverlayActive) {
      shouldRunAnimations = true;
      if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Condition Eval: RUN (Benign Overlay Active)`);
    } else {
      shouldRunAnimations = renderState === "rendered" && isContainerObservedVisible;
      if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Condition Eval: ${shouldRunAnimations ? "RUN" : "STOP"} (General: RenderState=${renderState}, IOVisible=${isContainerObservedVisible})`);
    }
    
    const isInFullscreen = !!document.fullscreenElement;
    // Logic to determine if animations should definitely stop:
    // They should stop if `shouldRunAnimations` is false AND we are not in fullscreen.
    const shouldStopLogic = !shouldRunAnimations && !isInFullscreen;

    if (shouldRunAnimations) {
      // If animations should run, but this hook's last command wasn't 'start'
      if (lastActionRef.current !== 'start') {
        if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Action: Scheduling RESTART (last cmd: ${lastActionRef.current})`);
        
        animationStartTimerRef.current = setTimeout(() => {
          // Re-check conditions inside timeout as state might have changed during the delay
          let currentShouldRunAgain;
          if (globalAnimationFlags.isTokenSelectorOpening) currentShouldRunAgain = true;
          else if (isTransitioning) currentShouldRunAgain = true;
          else if (isBenignOverlayActive) currentShouldRunAgain = true;
          else currentShouldRunAgain = renderState === "rendered" && isContainerObservedVisible;

          if (isMounted && currentShouldRunAgain) {
            if (import.meta.env.DEV) console.log(`[AnimLC ${performance.now().toFixed(0)}] setTimeout: EXECUTING RESTART (isMounted & currentShouldRunAgain).`);
            restartCanvasAnimations();
            lastActionRef.current = 'start'; // Update last action
          } else {
            if (import.meta.env.DEV) console.log(`[AnimLC ${performance.now().toFixed(0)}] setTimeout: Conditions changed, NOT RESTARTING (isMounted=${isMounted}, currentShouldRunAgain=${currentShouldRunAgain}). Last cmd remains: ${lastActionRef.current}`);
          }
          animationStartTimerRef.current = null; // Clear ref after execution or if not run
        }, ANIMATION_RESTART_DELAY);
      } else {
          // Animations should run and last command was 'start', so do nothing.
          if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] No Action: Conditions indicate RUN, and last command was 'start'.`);
      }
    } else if (shouldStopLogic) {
      // If animations should stop, but this hook's last command wasn't 'stop'
      if (lastActionRef.current !== 'stop') {
        if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] Action: EXECUTING STOP (last cmd: ${lastActionRef.current})`);
        stopCanvasAnimations();
        lastActionRef.current = 'stop'; // Update last action
      } else {
        // Animations should stop and last command was 'stop', so do nothing.
        if (import.meta.env.DEV) console.log(`[AnimLC ${timestamp.toFixed(0)}] No Action: Conditions indicate STOP, and last command was 'stop'.`);
      }
    } else {
        // This block covers cases where:
        // 1. `shouldRunAnimations` is false, BUT `isInFullscreen` is true (so `shouldStopLogic` is false).
        //    In this case, we don't stop animations. `lastActionRef` remains what it was.
        //    If `lastActionRef` was 'start', animations continue (correct for fullscreen).
        //    If `lastActionRef` was 'stop' (e.g. from a previous non-fullscreen stop), and now it's fullscreen but conditions like IOVisible are false,
        //    it won't try to restart them here, which seems correct. The expectation is usually that fullscreen implies visible content.
        if (import.meta.env.DEV) {
            if (!shouldRunAnimations && isInFullscreen) {
                 console.log(`[AnimLC ${timestamp.toFixed(0)}] No Action: Conditions suggest STOP, but fullscreen is active. Last cmd: ${lastActionRef.current}. Animation continues if it was 'start'.`);
            } else {
                 // This case should ideally not be hit if logic is exhaustive.
                 // It might mean `shouldRunAnimations` is true, but `lastActionRef.current` was already 'start'. (Covered by specific log above)
                 // Or `shouldRunAnimations` is false, `isInFullscreen` is false (so `shouldStopLogic` is true), but `lastActionRef.current` was already 'stop'. (Covered by specific log above)
                 console.log(`[AnimLC ${timestamp.toFixed(0)}] No Action: Uncategorized state or conditions met current command. shouldRunAnimations: ${shouldRunAnimations}, shouldStopLogic: ${shouldStopLogic}, last cmd: ${lastActionRef.current}.`);
            }
        }
    }

    // Cleanup function for the useEffect
    return () => {
      if (animationStartTimerRef.current) {
        clearTimeout(animationStartTimerRef.current);
        animationStartTimerRef.current = null;
      }
    };
  }, [
    isMounted, renderState, isContainerObservedVisible, isBenignOverlayActive,
    animatingPanel, // Kept for logging consistency, even if not in core decision logic
    isTransitioning,
    restartCanvasAnimations, stopCanvasAnimations,
    // lastActionRef is a ref, its changes don't re-trigger useEffect.
    // globalAnimationFlags is external, its changes don't re-trigger useEffect.
  ]);
}
```

---
### `src\hooks\useAppInteractions.js`
```js
// src/hooks/useAppInteractions.js
import { useCallback, useEffect, useMemo } from 'react'; // Added useMemo
import { useUIState } from './useUIState';
import { useNotifications } from './useNotifications';
import { useVisualEffects } from './useVisualEffects';
import { useLsp1Events } from './useLsp1Events';

// Config & Assets
import { IPFS_GATEWAY } from "../config/global-config";
import { demoAssetMap } from '../assets/DemoLayers/initLayers';
import { sliderParams } from '../components/Panels/EnhancedControlPanel'; // Assuming this path is correct relative to this hook's usage
import { INTERPOLATED_MIDI_PARAMS } from '../config/midiConstants';

// Utils
import { scaleNormalizedValue } from "../utils/helpers";
import { resolveLsp4Metadata } from '../utils/erc725.js';
import { isAddress } from 'viem';

/**
 * @typedef {import('../services/ConfigService').default} ConfigService
 * @typedef {import('../utils/CanvasManager').default} CanvasManager // Corrected path
 * @typedef {import('./useUIState').UIState} UIStateHook // Assuming UIState is the return type of useUIState
 * @typedef {import('./useNotifications').NotificationsAPI} NotificationHook // Assuming NotificationsAPI is the return type
 * @typedef {import('./useVisualEffects').VisualEffectsAPI} VisualEffectsHook // Assuming VisualEffectsAPI is the return type
 * @typedef {import('../context/VisualConfigContext').AllLayerConfigs} LayerConfigsType // Placeholder
 * @typedef {import('../context/VisualConfigContext').TokenAssignments} TokenAssignmentsType // Placeholder
 * @typedef {import('../context/MIDIContext').MIDIContextValue['pendingParamUpdate']} PendingParamUpdate // More specific type
 * @typedef {import('../context/MIDIContext').MIDIContextValue['pendingLayerSelect']} PendingLayerSelect // More specific type
 * @typedef {import('../services/LSP1EventService').ProcessedLsp1Event} LSP1UniversalReceiverEvent // Assuming ProcessedLsp1Event from LSP1EventService
 * @typedef {import('../context/ConfigContext').ConfigContextValue['savedReactions'][string]} ReactionConfig // Type for a single reaction config
 */

/**
 * @typedef {object} UseAppInteractionsProps
 * @property {(layerId: string, key: string, value: any) => void} updateLayerConfig - Function to update a layer's visual configuration.
 * @property {string | null} currentProfileAddress - The address of the currently viewed Universal Profile.
 * @property {{ [key: string]: ReactionConfig }} savedReactions - The map of saved event reactions for the current profile.
 * @property {React.RefObject<{[key: string]: CanvasManager}>} managerInstancesRef - Ref to the canvas manager instances.
 * @property {(layerId: string, src: string) => Promise<void>} setCanvasLayerImage - Function to set an image on a specific canvas layer.
 * @property {(layerId: string, tokenId: string | object | null) => void} updateTokenAssignment - Function to update the token assignment for a layer.
 * @property {React.RefObject<ConfigService | null>} configServiceRef - Ref to the ConfigurationService instance.
 * @property {PendingParamUpdate | null} pendingParamUpdate - Pending MIDI parameter update data.
 * @property {PendingLayerSelect | null} pendingLayerSelect - Pending MIDI layer selection data.
 * @property {() => void} clearPendingActions - Function to clear pending MIDI actions.
 * @property {React.RefObject<boolean>} isMountedRef - Ref indicating if the consuming component is mounted.
 */

/**
 * @typedef {object} AppInteractionsHook
 * @property {UIStateHook} uiStateHook - The state and functions returned by `useUIState`.
 * @property {NotificationHook} notificationData - The state and functions returned by `useNotifications`.
 * @property {(data: any, layerId: string) => Promise<void>} handleTokenApplied - Callback to handle applying a token/asset to a layer.
 * @property {VisualEffectsHook['processEffect']} processEffect - Function to process and apply a visual effect.
 * @property {VisualEffectsHook['createDefaultEffect']} createDefaultEffect - Function to create and apply a default visual effect for an event.
 * @property {(layerId: string, key: string, value: any) => void} handleLayerPropChange - Callback to handle changes to a layer's properties.
 */

/**
 * `useAppInteractions` is a custom React hook that centralizes the management of various
 * application-level user interactions, UI state, notifications, and event handling logic.
 * It aims to decouple these concerns from the main application view (`MainView.jsx`),
 * making `MainView` more focused on layout and orchestration.
 *
 * **Core Responsibilities:**
 * 1.  **UI State Management:** Initializes and exposes `useUIState` for managing panel visibility, active tabs, and overlays.
 * 2.  **Notifications:** Initializes and exposes `useNotifications` for adding and managing toast-like notifications.
 * 3.  **Visual Effects:** Initializes `useVisualEffects` to provide functions for triggering visual effects in response to events or actions.
 * 4.  **LSP1 Event Handling:**
 *     - Initializes `useLsp1Events` to listen for on-chain events related to the current Universal Profile.
 *     - Contains the `handleEventReceived` callback, which processes incoming LSP1 events, adds notifications, and triggers appropriate visual effects based on `savedReactions` or default behaviors.
 * 5.  **MIDI Action Processing:**
 *     - Includes a `useEffect` hook to process pending MIDI actions (`pendingParamUpdate`, `pendingLayerSelect`) received from `MIDIContext`.
 *     - Translates MIDI inputs into application actions like changing layer parameters (via `handleLayerPropChange`) or switching active layer tabs (via `uiStateHook.setActiveLayerTab`).
 * 6.  **Token Application Logic:**
 *     - Contains the `handleTokenApplied` callback, which manages the logic for resolving token metadata (including IPFS URIs) and instructing the `useCanvasOrchestrator` (via `setCanvasLayerImage` prop) to load the image onto the specified canvas layer. It also updates the global token assignment state (via `updateTokenAssignment` prop).
 * 7.  **Layer Property Changes:** Provides `handleLayerPropChange` as a stable callback for UI components to update layer configurations.
 *
 * **Props (`UseAppInteractionsProps`):**
 * This hook requires several functions and state values from parent contexts or other hooks to perform its duties:
 * - Functions to update global state (`updateLayerConfig`, `updateTokenAssignment`).
 * - Current application state (`currentProfileAddress`, `savedReactions`, `pendingParamUpdate`, etc.).
 * - Refs to services or instances needed for operations (`managerInstancesRef`, `configServiceRef`, `isMountedRef`).
 * - Functions to interact with other systems (`setCanvasLayerImage`, `clearPendingActions`).
 *
 * **Returns (`AppInteractionsHook`):**
 * It returns a memoized object containing:
 * - `uiStateHook`: The complete API from `useUIState`.
 * - `notificationData`: The complete API from `useNotifications`.
 * - `handleTokenApplied`: The callback for token application.
 * - `processEffect`, `createDefaultEffect`: Functions from `useVisualEffects`.
 * - `handleLayerPropChange`: The callback for layer property updates.
 *
 * By encapsulating these interaction patterns, `useAppInteractions` helps to simplify `MainView.jsx` and makes the overall application logic more modular and testable.
 *
 * @param {UseAppInteractionsProps} props - The properties required by the hook.
 * @returns {AppInteractionsHook} A memoized object containing UI state, notification handlers, and interaction callbacks.
 */
export const useAppInteractions = (props) => {
  const {
    updateLayerConfig,
    currentProfileAddress,
    savedReactions,
    managerInstancesRef,
    setCanvasLayerImage,
    updateTokenAssignment,
    configServiceRef,
    pendingParamUpdate,
    pendingLayerSelect,
    clearPendingActions,
    isMountedRef,
  } = props;

  const uiStateHook = useUIState('tab1'); // Initialize useUIState
  const notificationData = useNotifications(); // Initialize useNotifications
  const { addNotification } = notificationData;
  const { processEffect, createDefaultEffect } = useVisualEffects(updateLayerConfig); // Initialize useVisualEffects

  const handleLayerPropChange = useCallback((layerId, key, value) => {
    if (typeof updateLayerConfig === 'function') {
      updateLayerConfig(String(layerId), key, value);
    }
  }, [updateLayerConfig]); // updateLayerConfig should be stable

  const handleEventReceived = useCallback((event) => {
    if (!isMountedRef.current || !event?.typeId) {
      if (import.meta.env.DEV && event) console.warn(`[AppInteractions handleEventReceived] Event missing typeId or component not mounted. Event type: ${event.type}`);
      return;
    }
    if (typeof addNotification === 'function') addNotification(event);

    const reactionsMap = savedReactions || {};
    const typeIdToMatch = event.typeId.toLowerCase();

    if (import.meta.env.DEV) {
      const timestamp = performance.now().toFixed(0);
      console.log(`%c[AppInteractions Event ${timestamp}] TypeID: ${typeIdToMatch} (Type: ${event.type})`, 'color: lime; font-weight: bold;');
    }

    const matchingReactions = Object.values(reactionsMap).filter(
      r => r?.event?.toLowerCase() === typeIdToMatch
    );

    if (import.meta.env.DEV && matchingReactions.length > 0) {
      console.log(`%c[AppInteractions Event ${performance.now().toFixed(0)}] Found ${matchingReactions.length} matching reaction(s) for ${typeIdToMatch}`, 'color: lightgreen;');
    } else if (import.meta.env.DEV && matchingReactions.length === 0) {
      console.log(`%c[AppInteractions Event ${performance.now().toFixed(0)}] No matching reactions found for ${typeIdToMatch}. Available reaction event keys: ${Object.values(reactionsMap).map(r => r?.event).join(', ')}`, 'color: orange;');
    }

    if (matchingReactions.length > 0) {
      matchingReactions.forEach(reactionConfig => {
        if (typeof processEffect === 'function') {
          processEffect({ ...reactionConfig, originEvent: event })
            .catch(e => { if (import.meta.env.DEV) console.error("[AppInteractions] Error processing configured reaction:", e); });
        }
      });
    } else if (typeof createDefaultEffect === 'function') {
      if (import.meta.env.DEV) console.log(`%c[AppInteractions Event ${performance.now().toFixed(0)}] No specific reaction, creating default for type: ${event.type}`, 'color: skyblue;');
      createDefaultEffect(event.type)
        .catch(e => { if (import.meta.env.DEV) console.error("[AppInteractions] Error creating default effect:", e); });
    }
  }, [isMountedRef, addNotification, savedReactions, processEffect, createDefaultEffect]);

  useLsp1Events(currentProfileAddress, handleEventReceived); // Initialize useLsp1Events

  useEffect(() => {
    let processed = false;
    if (pendingParamUpdate && managerInstancesRef.current) {
      const { layer, param, value: normalizedMidiValue } = pendingParamUpdate;
      const manager = managerInstancesRef.current[String(layer)];
      if (manager) {
        const sliderConfig = sliderParams.find(p => p.prop === param);
        if (sliderConfig) {
          const scaledValue = scaleNormalizedValue(normalizedMidiValue, sliderConfig.min, sliderConfig.max);
          if (INTERPOLATED_MIDI_PARAMS.includes(param) && typeof manager.setTargetValue === 'function') {
            manager.setTargetValue(param, scaledValue);
          }
          handleLayerPropChange(String(layer), param, scaledValue);
          processed = true;
        }
      }
    }
    if (pendingLayerSelect) {
      const { layer } = pendingLayerSelect;
      const layerToTabMap = { 1: 'tab3', 2: 'tab2', 3: 'tab1' }; // Maps layer ID to tab ID
      const targetTab = layerToTabMap[layer];
      if (targetTab && typeof uiStateHook.setActiveLayerTab === 'function') {
        uiStateHook.setActiveLayerTab(targetTab);
        processed = true;
      }
    }
    if (processed && typeof clearPendingActions === 'function') {
      clearPendingActions();
    }
  }, [pendingParamUpdate, pendingLayerSelect, handleLayerPropChange, uiStateHook.setActiveLayerTab, clearPendingActions, managerInstancesRef]);

  const handleTokenApplied = useCallback(async (data, layerId) => {
    if (!isMountedRef.current || typeof setCanvasLayerImage !== 'function' || !configServiceRef.current) {
        if(import.meta.env.DEV) console.warn("[AppInteractions handleTokenApplied] Pre-condition fail or not mounted", {isMounted: isMountedRef.current, setCanvasLayerImageExists: !!setCanvasLayerImage, configServiceRefCurrentExists: !!configServiceRef.current});
        return;
    }

    let idToSaveInConfig = null;
    let srcToLoadInCanvas = null;

    if (data?.type === 'owned' && data.address && isAddress(data.address)) {
      idToSaveInConfig = data.address;
      const metadata = await resolveLsp4Metadata(configServiceRef.current, data.address);
      if (metadata?.LSP4Metadata) {
        const meta = metadata.LSP4Metadata;
        const url = meta.assets?.[0]?.url || meta.icon?.[0]?.url || meta.images?.[0]?.[0]?.url || null;
        if (url && typeof url === 'string') {
          const trimmedUrl = url.trim();
          if (trimmedUrl.startsWith('ipfs://')) srcToLoadInCanvas = `${IPFS_GATEWAY}${trimmedUrl.slice(7)}`;
          else if (trimmedUrl.startsWith('http') || trimmedUrl.startsWith('data:')) srcToLoadInCanvas = trimmedUrl;
        }
      }
      if (!srcToLoadInCanvas && data.iconUrl) srcToLoadInCanvas = data.iconUrl;
    } else if (typeof data === 'string') {
      if (Object.prototype.hasOwnProperty.call(demoAssetMap, data)) {
        idToSaveInConfig = data;
        srcToLoadInCanvas = demoAssetMap[data];
      } else if (Object.values(demoAssetMap).includes(data)) {
        const demoKey = Object.keys(demoAssetMap).find(key => demoAssetMap[key] === data);
        idToSaveInConfig = demoKey || data;
        srcToLoadInCanvas = data;
      } else if (data.startsWith('http') || data.startsWith('data:')) {
        idToSaveInConfig = data.startsWith('data:') ? data.substring(0, 50) + '...' : data;
        srcToLoadInCanvas = data;
      } else {
        idToSaveInConfig = data;
        srcToLoadInCanvas = data;
        if (import.meta.env.DEV) console.warn(`[AppInteractions handleTokenApplied] Unknown string token data: ${data}. Attempting to load as URL.`);
      }
    }

    if (srcToLoadInCanvas) {
      await setCanvasLayerImage(String(layerId), srcToLoadInCanvas)
        .catch(e => { if (import.meta.env.DEV) console.error(`[AppInteractions handleTokenApplied L${layerId}] setCanvasLayerImage failed for ${String(srcToLoadInCanvas).substring(0,60)}...:`, e); });
    } else if (import.meta.env.DEV) {
        console.warn(`[AppInteractions handleTokenApplied L${layerId}] No valid image source found to apply for token data:`, data);
    }

    if (typeof updateTokenAssignment === 'function' && idToSaveInConfig !== null) {
      updateTokenAssignment(String(layerId), idToSaveInConfig);
    }
  }, [isMountedRef, setCanvasLayerImage, updateTokenAssignment, configServiceRef]); // Dependencies

  // --- APPLIED FIX: Memoize the return object ---
  return useMemo(() => ({
    uiStateHook,          // Object from useUIState, should be memoized by useUIState
    notificationData,     // Object from useNotifications, should be memoized by useNotifications
    handleTokenApplied,   // useCallback
    processEffect,        // From useVisualEffects, should be stable
    createDefaultEffect,  // From useVisualEffects, should be stable
    handleLayerPropChange,// useCallback
  }), [
    uiStateHook, notificationData, handleTokenApplied,
    processEffect, createDefaultEffect, handleLayerPropChange
  ]);
  // --- END APPLIED FIX ---
};
```

---
### `src\hooks\useAudioVisualizer.js`
```js
// src/hooks/useAudioVisualizer.js
import { useState, useCallback, useRef, useEffect, useMemo } from 'react';

import throttle from 'lodash-es/throttle';

const UI_UPDATE_THROTTLE_MS = 100; // Update UI max 10 times per second (100ms)

/**
 * @typedef {object} AudioVisualizerSettings
 * @property {number} bassIntensity - Intensity multiplier for the bass frequency band.
 * @property {number} midIntensity - Intensity multiplier for the mid frequency band.
 * @property {number} trebleIntensity - Intensity multiplier for the treble frequency band.
 * @property {number} smoothingFactor - Smoothing factor for audio data changes.
 */

/**
 * @typedef {object} AudioFrequencyBands
 * @property {number} bass - Bass frequency level.
 * @property {number} mid - Mid frequency level.
 * @property {number} treble - Treble frequency level.
 */

/**
 * @typedef {object} RawAudioAnalyzerData
 * @property {number} level - Overall audio level.
 * @property {AudioFrequencyBands} frequencyBands - Audio levels for different frequency bands.
 */

/**
 * @typedef {object} AudioVisualizerAPI
 * @property {boolean} isAudioActive - Whether audio processing is currently active.
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setIsAudioActive - Function to set the audio active state.
 * @property {AudioVisualizerSettings} audioSettings - Current settings for audio processing.
 * @property {React.Dispatch<React.SetStateAction<AudioVisualizerSettings>>} setAudioSettings - Function to update audio settings.
 * @property {RawAudioAnalyzerData} analyzerData - Processed and throttled audio analysis data for UI consumption.
 * @property {(data: RawAudioAnalyzerData) => void} handleAudioDataUpdate - Callback to feed new raw audio data into the visualizer.
 */

// Helper to compare frequency band objects shallowly
const areFrequencyBandsEqual = (bandsA, bandsB) => {
  if (!bandsA || !bandsB) return bandsA === bandsB;
  return bandsA.bass === bandsB.bass && bandsA.mid === bandsB.mid && bandsA.treble === bandsB.treble;
};

/**
 * Custom hook to manage audio visualization state, including activity status,
 * settings, and processed analyzer data. It throttles UI updates for performance.
 *
 * @returns {AudioVisualizerAPI} An object containing audio visualizer state and control functions.
 */
export function useAudioVisualizer() {
  const [isAudioActive, setIsAudioActive] = useState(false);
  const [audioSettings, setAudioSettings] = useState({
    bassIntensity: 1.0,
    midIntensity: 1.0,
    trebleIntensity: 1.0,
    smoothingFactor: 0.6,
  });

  // Internal state that is updated by the throttled function
  /** @type {[RawAudioAnalyzerData, React.Dispatch<React.SetStateAction<RawAudioAnalyzerData>>]} */
  const [internalAnalyzerData, setInternalAnalyzerData] = useState({
    level: 0,
    frequencyBands: { bass: 0, mid: 0, treble: 0 },
  });

  // Memoized version of analyzerData to be passed as props.
  // This ensures the object reference only changes if the actual values change.
  const uiPropAnalyzerData = useMemo(() => ({
    level: internalAnalyzerData.level,
    frequencyBands: { // Always create a new object for frequencyBands for immutability
      bass: internalAnalyzerData.frequencyBands.bass,
      mid: internalAnalyzerData.frequencyBands.mid,
      treble: internalAnalyzerData.frequencyBands.treble,
    }
  }), [
    internalAnalyzerData.level,
    internalAnalyzerData.frequencyBands.bass, // Depend on individual primitive values
    internalAnalyzerData.frequencyBands.mid,
    internalAnalyzerData.frequencyBands.treble
  ]);

  /** @type {React.RefObject<RawAudioAnalyzerData>} */
  const latestRawDataRef = useRef({
    level: 0,
    frequencyBands: { bass: 0, mid: 0, treble: 0 },
  });

  // Throttled function to update the internal state
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const throttledUpdateInternalState = useCallback(
    throttle(() => {
      // Read the latest data from the ref when the throttled function executes
      const newDataFromRef = latestRawDataRef.current;
      setInternalAnalyzerData(prevData => {
        // Only update if the values have actually changed
        if (prevData.level !== newDataFromRef.level || !areFrequencyBandsEqual(prevData.frequencyBands, newDataFromRef.frequencyBands)) {
          return newDataFromRef; // Return new data, causing a state change
        }
        return prevData; // Return old data, preventing unnecessary state change & re-render
      });
    }, UI_UPDATE_THROTTLE_MS, { leading: true, trailing: true }),
    [] // setInternalAnalyzerData is stable from useState, latestRawDataRef is a ref
  );

  /**
   * Handles incoming raw audio data, stores it in a ref, and triggers a throttled state update.
   * @param {RawAudioAnalyzerData} data - The latest raw audio data.
   */
  const handleAudioDataUpdate = useCallback((data) => {
    // Always update the ref with the absolute latest raw data
    latestRawDataRef.current = {
      level: data.level ?? 0,
      frequencyBands: data.frequencyBands ?? { bass: 0, mid: 0, treble: 0 },
    };
    // Call the throttled function, which will then decide whether to update state
    throttledUpdateInternalState();
  }, [throttledUpdateInternalState]);

  useEffect(() => {
    // Cleanup the throttle function on unmount
    return () => {
      throttledUpdateInternalState.cancel();
    };
  }, [throttledUpdateInternalState]);

  return useMemo(() => ({
    isAudioActive,
    setIsAudioActive,
    audioSettings,
    setAudioSettings,
    analyzerData: uiPropAnalyzerData, // Expose the memoized, more stable data for UI
    handleAudioDataUpdate,
  }), [
    isAudioActive,
    audioSettings,
    uiPropAnalyzerData,
    handleAudioDataUpdate,
    // setIsAudioActive and setAudioSettings are stable
  ]);
}
```

---
### `src\hooks\useCanvasContainer.js`
```js
// src/hooks/useCanvasContainer.js
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';

/**
 * @typedef {object} CanvasContainerOptions Options for the useCanvasContainer hook.
 * @property {() => void} [onResize] - Optional: Callback function triggered on valid resize events (debounced for zero dimensions). Also triggered on significant visual viewport scale changes.
 * @property {(isVisible: boolean) => void} [onVisibilityChange] - Optional: Callback function triggered when the container's viewport visibility changes based on IntersectionObserver.
 * @property {() => void} [onZeroDimensions] - Optional: Callback function triggered when container dimensions become zero after being valid, following a debounce check.
 */

/**
 * @typedef {object} CanvasContainerHookReturn The state and actions provided by the useCanvasContainer hook.
 * @property {React.RefObject<HTMLDivElement>} containerRef - Ref to be attached to the container element that this hook will observe. Its `.current` property will be `HTMLDivElement | null`.
 * @property {boolean} hasValidDimensions - Indicates if the container currently has valid (non-zero) width and height based on ResizeObserver.
 * @property {boolean} isContainerObservedVisible - Indicates if the container is currently considered visible within the viewport by the IntersectionObserver.
 * @property {boolean} isFullscreenActive - Indicates if the browser is currently in fullscreen mode, typically initiated via this hook.
 * @property {() => void} enterFullscreen - Function to attempt to toggle fullscreen mode. It targets an element with ID 'fullscreen-root' first, falling back to the `containerRef` element.
 */

/**
 * Custom hook to manage observation of a container element for resize, viewport visibility,
 * and fullscreen state. It provides callbacks for these events and stateful flags.
 *
 * @param {CanvasContainerOptions} [options={}] - Configuration options for the hook.
 * @returns {CanvasContainerHookReturn} An object containing the container ref, state flags, and control functions.
 */
export function useCanvasContainer(options = {}) {
  const { onResize, onVisibilityChange, onZeroDimensions } = options;

  /** @type {React.RefObject<HTMLDivElement | null>} */
  const containerRef = useRef(null);
  /** @type {React.RefObject<boolean>} */
  const isMountedRef = useRef(false);
  /** @type {React.RefObject<IntersectionObserver | null>} */
  const intersectionObserverRef = useRef(null);
  /** @type {React.RefObject<ResizeObserver | null>} */
  const resizeObserverRef = useRef(null);
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const zeroDimCheckTimeoutRef = useRef(null);
  /** @type {React.RefObject<{width: number, height: number}>} */
  const lastValidDimensionsRef = useRef({ width: 0, height: 0 });
  /** @type {React.RefObject<number>} */
  const lastVisualViewportScaleRef = useRef(
    typeof window !== 'undefined' && window.visualViewport ? window.visualViewport.scale : 1
  );

  const [hasValidDimensions, setHasValidDimensions] = useState(false);
  const [isContainerObservedVisible, setIsContainerObservedVisible] = useState(true);
  const [isFullscreenActive, setIsFullscreenActive] = useState(false);

  const stableOnResize = useCallback(() => {
    if (onResize) {
      onResize();
    }
  }, [onResize]);

  const handleFullscreenError = useCallback((err) => {
      if (import.meta.env.DEV) {
        console.error(`[useCanvasContainer] Error with fullscreen operation: ${err.message} (${err.name})`);
      }
      // Update fullscreen state based on the actual document state after an error.
      setIsFullscreenActive(!!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement));
  }, [setIsFullscreenActive]); // setIsFullscreenActive is stable

  const enterFullscreen = useCallback(() => {
    const elem = document.getElementById('fullscreen-root') || containerRef.current;
    if (!elem) {
      if (import.meta.env.DEV) {
        console.warn("[useCanvasContainer] Fullscreen target element not found for enterFullscreen.");
      }
      return;
    }

    const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

    if (!isInFullscreen) {
      const requestPromise = elem.requestFullscreen?.() || elem.webkitRequestFullscreen?.() || elem.mozRequestFullScreen?.() || elem.msRequestFullscreen?.();
      if (requestPromise && typeof requestPromise.catch === 'function') {
        requestPromise.catch(handleFullscreenError);
      } else if (!requestPromise) {
        if (import.meta.env.DEV) {
          console.warn("[useCanvasContainer] Fullscreen request API not supported or call failed synchronously.");
        }
        handleFullscreenError(new Error("Fullscreen request failed or not supported."));
      }
    } else {
      const exitPromise = document.exitFullscreen?.() || document.webkitExitFullscreen?.() || document.mozCancelFullScreen?.() || document.msExitFullscreen?.();
      if (exitPromise && typeof exitPromise.catch === 'function') {
        exitPromise.catch(handleFullscreenError);
      } else if (!exitPromise) {
        if (import.meta.env.DEV) {
          console.warn("[useCanvasContainer] Fullscreen exit API not supported or call failed synchronously.");
        }
        handleFullscreenError(new Error("Fullscreen exit failed or not supported."));
      }
    }
  }, [containerRef, handleFullscreenError]);

  useEffect(() => {
    isMountedRef.current = true;
    const containerElement = containerRef.current;

    if (!containerElement) {
      return;
    }

    const intersectionCallback = (entries) => {
      if (!isMountedRef.current) return;
      entries.forEach((entry) => {
        const currentlyVisible = entry.isIntersecting;
        setIsContainerObservedVisible(prevVisible => {
            if (prevVisible !== currentlyVisible) {
                if (onVisibilityChange) { onVisibilityChange(currentlyVisible); }
                return currentlyVisible;
            }
            return prevVisible;
        });
      });
    };
    intersectionObserverRef.current = new IntersectionObserver(intersectionCallback, {
      root: null, rootMargin: "0px", threshold: 0.01,
    });
    intersectionObserverRef.current.observe(containerElement);

    const resizeCallback = (entries) => {
        if (!isMountedRef.current) return;
        const entry = entries[0]; if (!entry) return;
        const { width, height } = entry.contentRect;
        const currentWidth = Math.floor(width);
        const currentHeight = Math.floor(height);

        if (zeroDimCheckTimeoutRef.current) {
            clearTimeout(zeroDimCheckTimeoutRef.current);
            zeroDimCheckTimeoutRef.current = null;
        }

        if (currentWidth > 0 && currentHeight > 0) {
            if (!hasValidDimensions) {
                setHasValidDimensions(true);
            }
            lastValidDimensionsRef.current = { width: currentWidth, height: currentHeight };
            stableOnResize();
        } else {
            if (hasValidDimensions) {
                setHasValidDimensions(false);
                zeroDimCheckTimeoutRef.current = setTimeout(() => {
                    if (!isMountedRef.current) return;
                    const checkElement = containerRef.current;
                    const checkWidth = checkElement ? checkElement.clientWidth : 0;
                    const checkHeight = checkElement ? checkElement.clientHeight : 0;
                    if (checkWidth <= 0 || checkHeight <= 0) {
                        if (onZeroDimensions) { onZeroDimensions(); }
                    } else {
                        setHasValidDimensions(true);
                        lastValidDimensionsRef.current = { width: checkWidth, height: checkHeight };
                        stableOnResize();
                    }
                    zeroDimCheckTimeoutRef.current = null;
                }, 500);
            }
        }
    };
    resizeObserverRef.current = new ResizeObserver(resizeCallback);
    resizeObserverRef.current.observe(containerElement);

    let vv = null;
    const handleVisualViewportResize = () => {
        if (!isMountedRef.current || !vv) return;
        const currentScale = vv.scale;
        if (Math.abs(currentScale - lastVisualViewportScaleRef.current) > 0.01) {
            lastVisualViewportScaleRef.current = currentScale;
            stableOnResize();
        }
    };

    if (typeof window !== 'undefined' && window.visualViewport) {
        vv = window.visualViewport;
        lastVisualViewportScaleRef.current = vv.scale;
        vv.addEventListener('resize', handleVisualViewportResize);
        vv.addEventListener('scroll', handleVisualViewportResize);
    }

    const initialWidth = containerElement.clientWidth;
    const initialHeight = containerElement.clientHeight;
    if (initialWidth > 0 && initialHeight > 0) {
        if (!hasValidDimensions) setHasValidDimensions(true);
        lastValidDimensionsRef.current = { width: initialWidth, height: initialHeight };
    } else {
        if (hasValidDimensions) setHasValidDimensions(false);
        lastValidDimensionsRef.current = { width: 0, height: 0 };
    }

    return () => {
      isMountedRef.current = false;
      if (intersectionObserverRef.current) { intersectionObserverRef.current.disconnect(); }
      if (resizeObserverRef.current) { resizeObserverRef.current.disconnect(); }
      if (zeroDimCheckTimeoutRef.current) { clearTimeout(zeroDimCheckTimeoutRef.current); }
      if (vv) {
        vv.removeEventListener('resize', handleVisualViewportResize);
        vv.removeEventListener('scroll', handleVisualViewportResize);
      }
    };
  }, [stableOnResize, onVisibilityChange, onZeroDimensions, hasValidDimensions]);

  useEffect(() => {
    const handleFullscreenChange = () => {
        const isCurrentlyFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        setIsFullscreenActive(isCurrentlyFullscreen);
    };
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
    handleFullscreenChange(); // Initial check
    return () => {
        document.removeEventListener('fullscreenchange', handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
    };
  }, [setIsFullscreenActive]); // setIsFullscreenActive is stable

  return useMemo(() => ({
    containerRef,
    hasValidDimensions,
    isContainerObservedVisible,
    isFullscreenActive,
    enterFullscreen,
  }), [containerRef, hasValidDimensions, isContainerObservedVisible, isFullscreenActive, enterFullscreen]);
}
```

---
### `src\hooks\useCanvasManagers.js`
```js
// src/hooks/useCanvasManagers.js
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import CanvasManager from '../utils/CanvasManager'; // Assuming CanvasManager adheres to similar principles or is out of scope

/**
 * @typedef {object} CanvasManagersAPI
 * @property {Object.<string, CanvasManager>} managers - State holding manager instances (might be slightly delayed vs ref).
 * @property {React.RefObject<Object.<string, CanvasManager>>} managerInstancesRef - Ref for immediate access to managers.
 * @property {boolean} isInitialized - True once all managers are attempted to be created.
 * @property {(layerId: string, src: string) => Promise<void>} setLayerImage - Sets the image for a specific layer.
 * @property {(layerId: string, config: object) => void} applyLayerConfig - Applies a full configuration object to a single specified CanvasManager instance.
 * @property {(configs: Object.<string, object>) => void} applyConfigurations - Applies a full configuration object to each corresponding CanvasManager instance, typically used for preset loads.
 * @property {(layerId: string, key: string, value: any) => void} updateLayerProperty - Directly updates a single non-interpolated configuration property on a specific CanvasManager. Intended for use by an orchestrator for properties not driven by interpolation.
 * @property {() => void} stopAllAnimations - Stops animations for all managed canvases.
 * @property {() => void} restartAllAnimations - Restarts animations for all managed canvases (if their config has `enabled: true`).
 * @property {(configs?: Object.<string, object> | null) => Promise<boolean>} forceRedrawAll - Forces a redraw on all managed canvases, optionally applying new configurations before redrawing. Returns true if all redraws succeeded.
 * @property {() => Object.<string, object | null>} getCurrentConfigs - Retrieves the current configuration data from all managed CanvasManager instances.
 * @property {() => Promise<void>} handleResize - Programmatically triggers the resize logic (or setupCanvas fallback) for all managers.
 */

/**
 * Manages the lifecycle and interaction logic for multiple CanvasManager instances,
 * one for each visual layer. It handles their creation, initialization,
 * and cleanup. It provides centralized functions to control all managed canvases
 * (e.g., applying full configurations, setting images, animation control).
 *
 * The `updateLayerProperty` function is kept for potential direct, non-reactive updates
 * to non-interpolated properties if needed by orchestrator logic. However, primary layer
 * parameter updates are expected to be reactive, driven by `VisualConfigContext` changes
 * handled in `useCanvasOrchestrator`.
 *
 * @param {Object.<string, React.RefObject<HTMLCanvasElement>>} canvasRefs - An object where keys are layer IDs ('1', '2', '3') and values are React refs to the corresponding canvas elements.
 * @param {Object.<string, string>} defaultAssets - An object mapping layer IDs to their default image source URLs.
 * @returns {CanvasManagersAPI} An object containing the manager instances, initialization status, and control functions.
 */
export function useCanvasManagers(canvasRefs, defaultAssets) {
    const [isInitialized, setIsInitialized] = useState(false);
    // 'managers' state might be useful if components need to react to the set of managers changing,
    // but managerInstancesRef is generally used for direct interaction.
    const [managers, setManagers] = useState({});
    /** @type {React.RefObject<Object.<string, CanvasManager>>} */
    const managerInstancesRef = useRef({});
    /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
    const resizeTimeoutRef = useRef(null);
    /** @type {React.RefObject<boolean>} */
    const initRunRef = useRef(false); // To prevent re-running initialization effect unnecessarily

    useEffect(() => {
        if (initRunRef.current) return; // Only run initialization once per canvasRefs/defaultAssets change
        initRunRef.current = true;

        const newManagers = {};
        const createdManagerInstancesList = []; // To keep track for cleanup
        let managersCreatedCount = 0;
        const totalLayersExpected = Object.keys(canvasRefs).length;

        if (totalLayersExpected === 0) {
            if (import.meta.env.DEV) {
                console.warn("[useCanvasManagers] No canvas refs provided during initialization.");
            }
            setIsInitialized(true); // Considered initialized if no canvases are expected
            initRunRef.current = false; // Allow re-init if refs change later
            return;
        }

        Object.keys(canvasRefs).forEach(layerId => {
            const canvasElement = canvasRefs[layerId]?.current;
            if (canvasElement) {
                try {
                    const manager = new CanvasManager(canvasElement, layerId);
                    newManagers[layerId] = manager;
                    createdManagerInstancesList.push(manager);
                    managersCreatedCount++;
                } catch (error) {
                    if (import.meta.env.DEV) {
                        console.error(`[useCanvasManagers] Failed to create CanvasManager for layer ${layerId}:`, error);
                    }
                }
            } else {
                if (import.meta.env.DEV) {
                    console.warn(`[useCanvasManagers] Canvas ref not available for layer ${layerId} during initialization attempt.`);
                }
            }
        });

        managerInstancesRef.current = newManagers;
        setManagers(newManagers); // Update state

        if (managersCreatedCount !== totalLayersExpected) {
             if (import.meta.env.DEV) {
                 console.warn(`[useCanvasManagers] Manager creation mismatch. Expected: ${totalLayersExpected}, Created: ${managersCreatedCount}. isInitialized may be false or reflect partial setup.`);
             }
        }
        setIsInitialized(managersCreatedCount > 0 || totalLayersExpected === 0); // Initialized if any manager created or none expected

        initRunRef.current = false; // Reset for potential future re-initializations if deps change

        // Resize handler
        const handleResizeCallback = () => {
            if (resizeTimeoutRef.current) cancelAnimationFrame(resizeTimeoutRef.current);
            resizeTimeoutRef.current = requestAnimationFrame(() => {
                Object.values(managerInstancesRef.current).forEach(manager => {
                    if (manager && typeof manager.resize === 'function') {
                         manager.resize().catch(err => {
                             if(import.meta.env.DEV) console.error(`Error during resize for layer ${manager.layerId}:`, err)
                         });
                    } else if (manager && typeof manager.setupCanvas === 'function') { // Fallback if resize isn't available
                         manager.setupCanvas().catch(err => {
                             if(import.meta.env.DEV) console.error(`Error during setupCanvas fallback for layer ${manager.layerId} on resize:`, err)
                         });
                    }
                });
            });
        };
        window.addEventListener('resize', handleResizeCallback, { passive: true });

        // Cleanup function
        return () => {
            window.removeEventListener('resize', handleResizeCallback);
            if (resizeTimeoutRef.current) cancelAnimationFrame(resizeTimeoutRef.current);
            // Use the list of instances created during *this specific effect run* for cleanup
            createdManagerInstancesList.forEach(manager => {
                 if (manager && typeof manager.destroy === 'function') {
                     manager.destroy();
                 }
            });
            initRunRef.current = false; // Ensure reset on unmount too
        };
    }, [canvasRefs, defaultAssets]); // Re-run if canvasRefs or defaultAssets change

    const setLayerImage = useCallback(async (layerId, src) => {
        const manager = managerInstancesRef.current?.[String(layerId)];
        if (!manager) {
            if (import.meta.env.DEV) console.warn(`[useCanvasManagers setLayerImage] No manager for layer ${layerId}`);
            return Promise.reject(new Error(`No manager for layer ${layerId}`));
        }
        if (typeof manager.setImage !== 'function') {
            if (import.meta.env.DEV) console.warn(`[useCanvasManagers setLayerImage] Manager for layer ${layerId} has no setImage method.`);
            return Promise.reject(new Error(`Manager for layer ${layerId} has no setImage method.`));
        }
        return manager.setImage(src);
    }, []); // managerInstancesRef is stable

    // loadTokenImage seems to have been removed from CanvasManager, if it was specific to TokenService, this can be removed.
    // If it's a general image loading with metadata, its implementation in CanvasManager would be needed.
    // For now, assuming it's not part of CanvasManager's direct API.

    /** Applies a full configuration object to a single specified CanvasManager instance. */
    const applyLayerConfig = useCallback((layerId, config) => {
        const manager = managerInstancesRef.current?.[String(layerId)];
        if (manager && typeof manager.applyFullConfig === 'function') {
            manager.applyFullConfig(config);
        } else {
            if (import.meta.env.DEV) {
                console.warn(`[useCanvasManagers applyLayerConfig] Cannot apply full config: Manager or method missing for layer ${layerId}`);
            }
        }
    }, []);

    /**
     * Applies a full configuration object to each corresponding CanvasManager instance.
     * This is typically used when a new preset is loaded.
     */
    const applyConfigurations = useCallback((configs) => {
        if (!configs || typeof configs !== 'object') {
            if (import.meta.env.DEV) {
                console.warn("[useCanvasManagers applyConfigurations] Invalid or no configs object provided.");
            }
            return;
        }
        const currentManagers = managerInstancesRef.current || {};
        Object.entries(configs).forEach(([layerId, config]) => {
            const manager = currentManagers[String(layerId)];
            if (manager && typeof manager.applyFullConfig === 'function') {
                manager.applyFullConfig(config);
            } else {
                 if (import.meta.env.DEV) {
                    // console.warn(`[useCanvasManagers applyConfigurations] No manager or applyFullConfig for layer ${layerId} when applying new configs.`);
                 }
            }
        });
        // Ensure layers not in the incoming config are handled (e.g., set to a default enabled state)
        Object.entries(currentManagers).forEach(([layerId, manager]) => {
            if (!configs[String(layerId)] && manager && typeof manager.applyFullConfig === 'function') {
                const currentManagerConfig = manager.getConfigData?.() || {};
                // Apply existing config but ensure 'enabled' is true, or apply a default enabled config
                manager.applyFullConfig({ ...(manager.getDefaultConfig?.() || {}), ...currentManagerConfig, enabled: true });
            }
        });
    }, []);

    /**
     * Directly updates a single non-interpolated configuration property on a specific CanvasManager.
     * This is intended for use by `useCanvasOrchestrator` if it needs to make direct updates
     * for properties not driven by interpolation (e.g., 'speed', 'opacity', 'blendMode').
     */
    const updateLayerProperty = useCallback((layerId, key, value) => {
        const manager = managerInstancesRef.current?.[String(layerId)];
        if (!manager) {
            if (import.meta.env.DEV) {
                console.warn(`[useCanvasManagers updateLayerProperty] Manager missing for layer ${layerId}`);
            }
            return;
        }
        if (typeof manager.updateConfigProperty === 'function') {
            manager.updateConfigProperty(key, value);
        } else {
            if (import.meta.env.DEV) {
                console.error(`[useCanvasManagers updateLayerProperty] No updateConfigProperty method on manager for layer ${layerId}.`);
            }
        }
    }, []); // managerInstancesRef is stable

    const stopAllAnimations = useCallback(() => {
        Object.values(managerInstancesRef.current || {}).forEach(manager => {
            if (manager && typeof manager.stopAnimationLoop === 'function') manager.stopAnimationLoop();
        });
    }, []);

    const restartAllAnimations = useCallback(() => {
        Object.values(managerInstancesRef.current || {}).forEach(manager => {
            const config = manager?.getConfigData?.();
            if (manager && typeof manager.startAnimationLoop === 'function' && config?.enabled) {
                manager.startAnimationLoop();
            }
        });
    }, []);

    const forceRedrawAll = useCallback(async (configs = null) => {
        const results = [];
        const currentManagers = managerInstancesRef.current || {};
        for (const layerId in currentManagers) {
            const manager = currentManagers[layerId];
            if (manager) {
                try {
                    const configForLayer = configs ? configs[layerId] : null;
                    if (typeof manager.forceRedraw === 'function') {
                        const result = await manager.forceRedraw(configForLayer);
                        results.push(result);
                    } else {
                        if (import.meta.env.DEV) console.warn(`[useCanvasManagers forceRedrawAll] forceRedraw missing on manager L${layerId}`);
                        results.push(false);
                    }
                } catch (e) {
                    if (import.meta.env.DEV) console.error(`[useCanvasManagers forceRedrawAll] Error redrawing layer ${layerId}:`, e);
                    results.push(false);
                }
            }
        }
        return results.every(Boolean);
    }, []);

    const handleResize = useCallback(async () => {
        const currentManagers = managerInstancesRef.current || {};
        for (const layerId in currentManagers) {
            const manager = currentManagers[layerId];
            if (manager?.resize) {
                try { await manager.resize(); }
                catch (error) { if(import.meta.env.DEV) console.error(`[useCanvasManagers handleResize] Error resizing layer ${layerId}:`, error); }
            } else if (manager?.setupCanvas) { // Fallback if resize isn't available
                 try { await manager.setupCanvas(); }
                 catch (error) { if(import.meta.env.DEV) console.error(`[useCanvasManagers handleResize] Error setting up canvas for layer ${layerId} during resize:`, error); }
            }
        }
    }, []);

    const getCurrentConfigs = useCallback(() => {
        const configs = {};
        const currentManagers = managerInstancesRef.current || {};
        Object.entries(currentManagers).forEach(([layerId, manager]) => {
            configs[layerId] = manager?.getConfigData?.() ?? null;
        });
        return configs;
    }, []);

    return useMemo(() => ({
        managers, // The state variable (might have a slight delay from ref)
        managerInstancesRef, // Ref for immediate access
        isInitialized,
        setLayerImage,
        applyLayerConfig,
        applyConfigurations,
        updateLayerProperty,
        stopAllAnimations,
        restartAllAnimations,
        forceRedrawAll,
        getCurrentConfigs,
        handleResize
    }), [
        managers, isInitialized,
        setLayerImage, applyLayerConfig, applyConfigurations, updateLayerProperty,
        stopAllAnimations, restartAllAnimations, forceRedrawAll, getCurrentConfigs, handleResize
    ]);
}
```

---
### `src\hooks\useCanvasOrchestrator.js`
```js
// src/hooks/useCanvasOrchestrator.js
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';

import { useVisualConfig } from '../context/VisualConfigContext';
import { useCanvasManagers } from './useCanvasManagers'; // Local hook

import debounce from '../utils/debounce'; // Local utility
import { resolveLsp4Metadata } from '../utils/erc725.js'; // Local utility
import { demoAssetMap } from '../assets/DemoLayers/initLayers'; // Local assets
import { IPFS_GATEWAY } from '../config/global-config'; // Local config
import { INTERPOLATED_MIDI_PARAMS } from '../config/midiConstants'; // Local config

import { isAddress } from 'viem'; // Third-party library
import CanvasManager from '../utils/CanvasManager'; // For instanceof check

const RESIZE_DEBOUNCE_DELAY = 250; // Milliseconds for debouncing resize events

// --- MODIFIED: Align defaultAssets with fallback-config.js using DEMO_LAYER_4 ---
// This object defines the default images to be loaded for each canvas layer
// if no other specific image or token is assigned.
const defaultAssets = {
    1: demoAssetMap.DEMO_LAYER_4 || '', // Use DEMO_LAYER_4 as per fallback-config
    2: demoAssetMap.DEMO_LAYER_4 || '', // Use DEMO_LAYER_4
    3: demoAssetMap.DEMO_LAYER_4 || '', // Use DEMO_LAYER_4
};
// --- END MODIFICATION ---

/**
 * @typedef {object} CanvasOrchestratorAPI
 * @property {boolean} managersReady - True if all expected CanvasManager instances are initialized and ready.
 * @property {boolean} defaultImagesLoaded - True if the initial default images for all layers have been successfully loaded.
 * @property {React.RefObject<Object.<string, import('../utils/CanvasManager').default>>} managerInstancesRef - Direct ref to the CanvasManager instances, as managed by `useCanvasManagers`.
 * @property {(configs: Object.<string, object>) => void} applyConfigurationsToManagers - Applies full layer configurations to all canvas managers. Updates internal tracking for reactive effects. This is typically used for applying a loaded preset.
 * @property {(assignments: Object.<string, string | object | null>) => Promise<void>} applyTokenAssignmentsToManagers - Resolves and applies token/image assignments to canvas layers based on various input types (demo keys, owned asset objects, LSP4 addresses, direct URLs).
 * @property {() => void} stopCanvasAnimations - Stops animations on all managed canvases.
 * @property {() => void} restartCanvasAnimations - Restarts animations on all managed canvases if they are ready and configured to be enabled.
 * @property {(configs?: Object.<string, object> | null) => Promise<boolean>} redrawAllCanvases - Forces a redraw on all canvases, optionally applying new configurations before redrawing. Returns true if all redraws succeeded.
 * @property {() => void} handleCanvasResize - Debounced handler to trigger resize logic on all canvases.
 * @property {(layerId: string, src: string) => Promise<void>} setCanvasLayerImage - Sets an image for a specific canvas layer directly.
 */

/**
 * Orchestrates multiple CanvasManager instances, handling their initialization,
 * configuration application (from presets or context changes), image assignments,
 * and lifecycle events like animations and resizing. It acts as a bridge between
 * global configuration state (`VisualConfigContext`, `configLoadNonce`) and the
 * individual `CanvasManager` instances.
 *
 * @param {object} params - Parameters for the orchestrator.
 * @param {React.RefObject<import('../services/ConfigurationService').default | null>} params.configServiceRef - Ref to the ConfigurationService, used for resolving LSP4 metadata.
 * @param {Object.<string, React.RefObject<HTMLCanvasElement>>} params.canvasRefs - Refs to the canvas elements for each layer.
 * @param {number} params.configLoadNonce - A nonce that changes when a new global configuration (preset) is loaded, used to coordinate updates.
 * @returns {CanvasOrchestratorAPI} An API object for interacting with the orchestrated canvas managers.
 */
export function useCanvasOrchestrator({ configServiceRef, canvasRefs, configLoadNonce }) {
    /** @type {React.RefObject<boolean>} */
    const isMountedRef = useRef(false);
    const [managersReady, setManagersReady] = useState(false);
    const [defaultImagesLoaded, setDefaultImagesLoaded] = useState(false);
    /** @type {React.RefObject<number>} */
    const lastProcessedNonceByOrchestratorRef = useRef(0);
    /** @type {React.RefObject<Object.<string, object> | null>} */
    const prevLayerConfigsRef = useRef(null);

    const {
        managerInstancesRef,
        isInitialized: managersInitialized,
        setLayerImage: setLayerImageInternal,
        applyConfigurations: applyConfigsToManagersInternal,
        stopAllAnimations: stopAllAnimationsInternal,
        restartAllAnimations: restartAllAnimationsInternal,
        forceRedrawAll: forceRedrawAllInternal,
        handleResize: handleResizeInternal,
    } = useCanvasManagers(canvasRefs, defaultAssets);

    /** @type {React.RefObject<() => Promise<void>>} */
    const rawHandleResize = useRef(handleResizeInternal);
    const debouncedResizeHandler = useMemo(
        () => debounce(() => { if (rawHandleResize.current) rawHandleResize.current(); }, RESIZE_DEBOUNCE_DELAY),
        [] // Debounce function should be stable
    );

    useEffect(() => {
        isMountedRef.current = true;
        return () => { isMountedRef.current = false; };
    }, []);

    useEffect(() => {
        rawHandleResize.current = handleResizeInternal;
    }, [handleResizeInternal]);

    // Effect to determine if all CanvasManager instances are ready
    useEffect(() => {
        if (managersInitialized && isMountedRef.current) {
            const allManagersExist = Object.keys(canvasRefs).every(
                (id) => managerInstancesRef.current?.[id] instanceof CanvasManager
            );
            if (managersReady !== allManagersExist) {
                setManagersReady(allManagersExist);
            }
        } else if (managersReady) { // If not initialized or not mounted, but was previously ready
            setManagersReady(false);
        }
    }, [managersInitialized, canvasRefs, managersReady, managerInstancesRef]); // managerInstancesRef ADDED HERE

    // Effect to load default images once managers are ready
    useEffect(() => {
        if (!managersReady || !isMountedRef.current || defaultImagesLoaded) return;

        const currentManagers = managerInstancesRef.current;
        const loadImages = async () => {
            const promises = Object.keys(currentManagers).map(layerId => {
                const manager = currentManagers[layerId];
                const src = defaultAssets[layerId]; // This will now use DEMO_LAYER_4
                if (manager && src && typeof manager.setImage === "function") {
                    return manager.setImage(src).catch((e) => {
                        if (import.meta.env.DEV) {
                            console.error(`[CanvasOrchestrator] Default Image Load FAILED L${layerId} (src: ${src}):`, e);
                        }
                        // Propagate error to be caught by Promise.allSettled
                        return Promise.reject(e);
                    });
                }
                return Promise.resolve(); // Resolve if no manager, src, or setImage
            });

            try {
                const results = await Promise.allSettled(promises);
                if (isMountedRef.current) {
                    const allSucceeded = results.every(r => r.status === 'fulfilled');
                    setDefaultImagesLoaded(allSucceeded);
                    if (!allSucceeded && import.meta.env.DEV) {
                        console.warn("[CanvasOrchestrator] Not all default images loaded successfully. Results:", results);
                    }
                }
            } catch (e) { // Should not be reached if using Promise.allSettled correctly
                if (import.meta.env.DEV) {
                    console.error("[CanvasOrchestrator] Unexpected error in Promise.allSettled for default images:", e);
                }
                if (isMountedRef.current) setDefaultImagesLoaded(false);
            }
        };
        loadImages();
    }, [managersReady, defaultImagesLoaded, managerInstancesRef]);

    const { layerConfigs: currentContextLayerConfigs } = useVisualConfig();

    // Effect to react to changes in layer configurations from VisualConfigContext or configLoadNonce
    useEffect(() => {
        if (!managersReady || !currentContextLayerConfigs || !isMountedRef.current) {
            return;
        }

        if (configLoadNonce > lastProcessedNonceByOrchestratorRef.current) {
            if (import.meta.env.DEV) {
                console.log(`[CanvasOrchestrator] Reactive Effect: New configLoadNonce (${configLoadNonce}) detected. Orchestrator nonce was (${lastProcessedNonceByOrchestratorRef.current}). Deferring to RenderLifecycle/applyConfigurationsToManagers. Updating orchestrator nonce.`);
            }
            lastProcessedNonceByOrchestratorRef.current = configLoadNonce;
            return;
        }

        if (lastProcessedNonceByOrchestratorRef.current !== configLoadNonce && import.meta.env.DEV) {
            console.warn(`[CanvasOrchestrator] Reactive Effect: Nonce mismatch after initial check. Orchestrator: ${lastProcessedNonceByOrchestratorRef.current}, Global: ${configLoadNonce}. Syncing orchestrator nonce.`);
            lastProcessedNonceByOrchestratorRef.current = configLoadNonce;
        }

        const managers = managerInstancesRef.current;
        if (!managers) return;

        const prevConfigs = prevLayerConfigsRef.current;
        let changedOverall = false;

        for (const layerIdStr of ['1', '2', '3']) { // Assuming fixed layer IDs
            const newConfigForLayer = currentContextLayerConfigs[layerIdStr];
            const oldConfigForLayer = prevConfigs ? prevConfigs[layerIdStr] : null;
            const manager = managers[layerIdStr];

            if (!manager || !newConfigForLayer) continue;

            Object.keys(newConfigForLayer).forEach(key => {
                const newValue = newConfigForLayer[key];
                const oldValue = oldConfigForLayer ? oldConfigForLayer[key] : undefined;

                let propertyChanged = oldValue !== newValue;
                if (key === 'driftState') {
                    propertyChanged = JSON.stringify(oldValue) !== JSON.stringify(newValue);
                }

                if (propertyChanged) {
                    changedOverall = true;
                    if (import.meta.env.DEV) {
                        const actionType = INTERPOLATED_MIDI_PARAMS.includes(key) ? "SNAP_VISUAL_PROPERTY" : "UPDATE_CONFIG_PROPERTY";
                        const formattedNewValue = typeof newValue === 'object' ? JSON.stringify(newValue) : newValue;
                        const formattedOldValue = typeof oldValue === 'object' ? JSON.stringify(oldValue) : oldValue;
                        console.log(
                            `%c[ORCHESTRATOR_APPLY L${layerIdStr} - ${key}] Action: ${actionType}, NewValue: ${formattedNewValue}`,
                            'color: darkorange; font-weight: bold;',
                            `(Details: Old from prevLayerConfigsRef: ${formattedOldValue}, NewValFromVisualConfigContext: ${formattedNewValue})`
                        );
                    }

                    if (INTERPOLATED_MIDI_PARAMS.includes(key)) {
                        if (typeof manager.snapVisualProperty === 'function') {
                            manager.snapVisualProperty(key, newValue);
                        } else if (import.meta.env.DEV) {
                            console.warn(`[CanvasOrchestrator] Manager for layer ${layerIdStr} missing snapVisualProperty for ${key}`);
                        }
                    } else {
                        if (typeof manager.updateConfigProperty === 'function') {
                            manager.updateConfigProperty(key, newValue);
                        } else if (import.meta.env.DEV) {
                            console.warn(`[CanvasOrchestrator] Manager for layer ${layerIdStr} missing updateConfigProperty for ${key}`);
                        }
                    }
                }
            });
        }
        if (changedOverall || !prevConfigs) {
            if (import.meta.env.DEV && changedOverall) {
                 console.log(`[CanvasOrchestrator Reactive Effect] Overall changes detected. Updating prevLayerConfigsRef to reflect currentContextLayerConfigs.`);
            }
            prevLayerConfigsRef.current = JSON.parse(JSON.stringify(currentContextLayerConfigs));
        }
    }, [currentContextLayerConfigs, managersReady, managerInstancesRef, configLoadNonce]);


    const setCanvasLayerImage = useCallback((layerId, src) => {
        if (!managersReady) {
            if (import.meta.env.DEV) {
                console.warn("[CanvasOrchestrator setCanvasLayerImage] Attempted to set image, but managers are not ready.");
            }
            return Promise.reject(new Error("Managers not ready"));
        }
        return setLayerImageInternal(layerId, src);
    }, [managersReady, setLayerImageInternal]);

    const applyTokenAssignmentsToManagers = useCallback(async (assignments) => {
        if (!isMountedRef.current || !managersReady || !managerInstancesRef.current || !assignments || !configServiceRef?.current) {
            if (import.meta.env.DEV) {
                console.warn("[CanvasOrchestrator applyTokenAssignmentsToManagers] Aborted due to unmet conditions:", {
                    isMounted: isMountedRef.current, managersReady, hasManagerInstances: !!managerInstancesRef.current, hasAssignments: !!assignments, hasConfigService: !!configServiceRef?.current
                });
            }
            return Promise.resolve();
        }
        const currentManagers = managerInstancesRef.current;
        const imageLoadPromises = [];

        for (const layerId of ['1', '2', '3']) { // Assuming fixed layer IDs
            const manager = currentManagers[layerId];
            if (!manager) continue;

            const assignmentValue = assignments[layerId];
            const defaultAssetSrcForThisLayer = defaultAssets[layerId];
            let imageSourceToApply = defaultAssetSrcForThisLayer;

            try {
                if (typeof assignmentValue === 'string' && assignmentValue.startsWith("DEMO_LAYER_")) {
                    const demoAssetSource = demoAssetMap[assignmentValue];
                    if (demoAssetSource) {
                        imageSourceToApply = demoAssetSource;
                    } else if (import.meta.env.DEV) {
                        console.warn(`[CanvasOrchestrator] Demo key '${assignmentValue}' not found for L${layerId}. Using default: ${defaultAssetSrcForThisLayer}`);
                    }
                } else if (typeof assignmentValue === 'object' && assignmentValue?.type === 'owned' && assignmentValue.iconUrl) {
                    imageSourceToApply = assignmentValue.iconUrl;
                } else if (typeof assignmentValue === 'string' && isAddress(assignmentValue)) {
                    const metadata = await resolveLsp4Metadata(configServiceRef.current, assignmentValue);
                    let resolvedImageUrl = null;
                    if (metadata?.LSP4Metadata) {
                        const meta = metadata.LSP4Metadata;
                        const url = meta.assets?.[0]?.url || meta.icon?.[0]?.url || meta.images?.[0]?.[0]?.url || null;
                        if (url && typeof url === 'string') {
                            const trimmedUrl = url.trim();
                            if (trimmedUrl.startsWith('ipfs://')) resolvedImageUrl = `${IPFS_GATEWAY}${trimmedUrl.slice(7)}`;
                            else if (trimmedUrl.startsWith('http') || trimmedUrl.startsWith('data:')) resolvedImageUrl = trimmedUrl;
                        }
                    }
                    if (resolvedImageUrl) {
                        imageSourceToApply = resolvedImageUrl;
                    } else if (import.meta.env.DEV) {
                        console.warn(`[CanvasOrchestrator] Could not resolve image URL from LSP4 for ${assignmentValue} on L${layerId}. Using default: ${defaultAssetSrcForThisLayer}`);
                    }
                } else if (typeof assignmentValue === 'string' && (assignmentValue.includes('/') || assignmentValue.startsWith('data:'))) {
                     imageSourceToApply = assignmentValue;
                } else if (assignmentValue === null || assignmentValue === undefined) {
                    imageSourceToApply = defaultAssetSrcForThisLayer;
                } else if (assignmentValue && import.meta.env.DEV) {
                    console.warn(`[CanvasOrchestrator] Unhandled assignment type or value for L${layerId}:`, assignmentValue, `. Using default: ${defaultAssetSrcForThisLayer}`);
                }

                if (manager.setImage && imageSourceToApply) {
                    imageLoadPromises.push(
                        setLayerImageInternal(layerId, imageSourceToApply).catch(err => {
                            if (import.meta.env.DEV) {
                                console.error(`[CanvasOrchestrator] L${layerId}: Error setting image '${String(imageSourceToApply).substring(0,60)}...':`, err);
                            }
                            if (defaultAssetSrcForThisLayer && manager.setImage && imageSourceToApply !== defaultAssetSrcForThisLayer) {
                                if (import.meta.env.DEV) {
                                    console.log(`[CanvasOrchestrator] L${layerId}: Falling back to default asset '${defaultAssetSrcForThisLayer}' after error.`);
                                }
                                return setLayerImageInternal(layerId, defaultAssetSrcForThisLayer);
                            }
                            return Promise.reject(err);
                        })
                    );
                } else if (!manager.setImage && import.meta.env.DEV) {
                    console.warn(`[CanvasOrchestrator] L${layerId}: manager.setImage is not available.`);
                }
            } catch (errorAssignmentProcessing) {
                if (import.meta.env.DEV) {
                    console.error(`[CanvasOrchestrator] L${layerId}: Outer error processing assignment '${JSON.stringify(assignmentValue)}': `, errorAssignmentProcessing);
                }
                if (defaultAssetSrcForThisLayer && manager?.setImage) {
                    imageLoadPromises.push(setLayerImageInternal(layerId, defaultAssetSrcForThisLayer));
                }
            }
        }
        if (imageLoadPromises.length > 0) {
            await Promise.allSettled(imageLoadPromises);
        }
    }, [managersReady, configServiceRef, managerInstancesRef, setLayerImageInternal]);

    const applyConfigurationsToManagers = useCallback((configs) => {
        if (!managersReady) {
            if (import.meta.env.DEV) {
                console.warn("[CanvasOrchestrator applyConfigurationsToManagers] Attempted to apply configs, but managers are not ready.");
            }
            return;
        }
        if (import.meta.env.DEV) {
            console.log("[CanvasOrchestrator] applyConfigurationsToManagers CALLED with:", configs ? JSON.parse(JSON.stringify(configs)) : null);
        }
        applyConfigsToManagersInternal(configs);
        prevLayerConfigsRef.current = configs ? JSON.parse(JSON.stringify(configs)) : null;
        lastProcessedNonceByOrchestratorRef.current = configLoadNonce;

    }, [managersReady, applyConfigsToManagersInternal, configLoadNonce]);

    const stopCanvasAnimations = useCallback(() => {
        stopAllAnimationsInternal();
    }, [stopAllAnimationsInternal]);

    const restartCanvasAnimations = useCallback(() => {
        if (managersReady) {
            restartAllAnimationsInternal();
        } else if (import.meta.env.DEV) {
            console.warn("[CanvasOrchestrator restartCanvasAnimations] Attempted to restart animations, but managers are not ready.");
        }
    }, [managersReady, restartAllAnimationsInternal]);

    const redrawAllCanvases = useCallback(async (configs = null) => {
        if (!managersReady) {
            if (import.meta.env.DEV) {
                console.warn("[CanvasOrchestrator redrawAllCanvases] Attempted to redraw, but managers are not ready.");
            }
            return false;
        }
        return forceRedrawAllInternal(configs);
    }, [managersReady, forceRedrawAllInternal]);

    const handleCanvasResize = useCallback(() => {
        debouncedResizeHandler();
    }, [debouncedResizeHandler]);


    return useMemo(() => ({
        managersReady,
        defaultImagesLoaded,
        managerInstancesRef,
        applyConfigurationsToManagers,
        applyTokenAssignmentsToManagers,
        stopCanvasAnimations,
        restartCanvasAnimations,
        redrawAllCanvases,
        handleCanvasResize,
        setCanvasLayerImage,
    }), [
        managersReady, defaultImagesLoaded, managerInstancesRef,
        applyConfigurationsToManagers, applyTokenAssignmentsToManagers,
        stopCanvasAnimations, restartCanvasAnimations, redrawAllCanvases,
        handleCanvasResize, setCanvasLayerImage
    ]);
}
```

---
### `src\hooks\useConfigState.js`
```js
// src/hooks/useConfigState.js
import { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { useUpProvider } from "../context/UpProvider";
import ConfigurationService from "../services/ConfigurationService";
import { useToast } from "../context/ToastContext";
import {
  RADAR_EVENT_REACTIONS_KEY,
  RADAR_MIDI_MAP_KEY,
} from "../config/global-config";
import { stringToHex, hexToString } from "viem";

/**
 * @typedef {object} ConfigStateAPI
 * @property {boolean} configServiceInstanceReady - Indicates if the ConfigurationService is ready for reads and writes based on provider/client stability.
 * @property {React.RefObject<ConfigurationService | null>} configServiceRef - Ref holding the initialized ConfigurationService instance.
 * @property {object} savedReactions - Configuration object for global event reactions stored on the host profile. Keyed by event type.
 * @property {object} midiMap - Configuration object for global MIDI mappings stored on the host profile.
 * @property {boolean} isSavingGlobal - True if global settings (reactions or MIDI map) are currently being saved to the host profile.
 * @property {Error | string | null} globalSaveError - Contains the error message if the last global settings save attempt failed.
 * @property {boolean} globalSaveSuccess - True if the last global settings save operation completed successfully.
 * @property {boolean} hasPendingChanges - True if any configuration (visual, preset, reactions, MIDI) has unsaved modifications. This flag is typically set by other contexts or components interacting with the configuration.
 * @property {React.Dispatch<React.SetStateAction<boolean>>} setHasPendingChanges - Function to manually set the `hasPendingChanges` flag. Intended for consumption by other contexts/components that modify configuration state managed elsewhere but need to signal pending changes globally.
 * @property {() => Promise<{success: boolean, error?: string}>} saveGlobalReactions - Saves the current `savedReactions` state to the host profile using the ConfigurationService. Returns a promise indicating success or failure.
 * @property {() => Promise<{success: boolean, error?: string}>} saveGlobalMidiMap - Saves the current `midiMap` state to the host profile using the ConfigurationService. Returns a promise indicating success or failure.
 * @property {(eventType: string, reactionData: object) => void} updateSavedReaction - Adds or updates a specific event reaction configuration in the local `savedReactions` state and sets `hasPendingChanges` to true.
 * @property {(eventType: string) => void} deleteSavedReaction - Removes an event reaction configuration from the local `savedReactions` state by its event type and sets `hasPendingChanges` to true if a change occurred.
 * @property {(newMap: object) => void} updateMidiMap - Replaces the entire `midiMap` configuration in the local state and sets `hasPendingChanges` to true.
 * @property {boolean} isLoadingGlobals - True if global settings (reactions, MIDI map) are currently being loaded from the host profile.
 * @property {Error | string | null} globalLoadError - Contains the error message(s) if the last attempt to load global settings failed.
 */

/**
 * Custom hook to manage global application settings (Reactions, MIDI map for the host profile),
 * the `ConfigurationService` instance, and the `hasPendingChanges` status.
 * It no longer handles preset management or live visual configurations, which have been
 * delegated to `PresetManagementContext` and `VisualConfigContext` respectively.
 * It loads global settings (reactions, MIDI map) when the profile address or service readiness changes.
 *
 * @param {string|null} currentProfileAddress The address of the host profile to manage settings for. If null, global settings are reset.
 * @returns {ConfigStateAPI} An object containing global configuration state and management functions.
 */
const useConfigState = (currentProfileAddress) => {
  const {
      provider, walletClient, publicClient,
      isConnecting: upIsConnecting,
      hasCriticalError: upHasCriticalError
  } = useUpProvider();

  const { addToast } = useToast();
  /** @type {React.RefObject<ConfigurationService | null>} */
  const configServiceRef = useRef(null);
  /** @type {React.RefObject<string | null>} */
  const prevProfileAddressForGlobalsRef = useRef(null);

  // State managed by this hook
  const [savedReactions, setSavedReactions] = useState({});
  const [midiMap, setMidiMap] = useState({}); // Host profile's stored MIDI map
  const [isSavingGlobal, setIsSavingGlobal] = useState(false);
  const [globalSaveError, setGlobalSaveError] = useState(null);
  const [globalSaveSuccess, setGlobalSaveSuccess] = useState(false);
  const [hasPendingChanges, setHasPendingChanges] = useState(false);
  const [isLoadingGlobals, setIsLoadingGlobals] = useState(false);
  const [globalLoadError, setGlobalLoadError] = useState(null);


  const isUpProviderStableForRead = useMemo(() => {
      // Service is stable for reading if we have a public client and the provider isn't connecting or in an error state.
      return !!publicClient && !upIsConnecting && !upHasCriticalError;
  }, [publicClient, upIsConnecting, upHasCriticalError]);

  // Effect to initialize and update ConfigurationService instance
  useEffect(() => {
    if (provider && !configServiceRef.current) {
        // Initialize service only if provider exists and service isn't already initialized
        configServiceRef.current = new ConfigurationService(provider, walletClient, publicClient);
    }
    if (configServiceRef.current) {
        // Update clients if they change (e.g., wallet connection, chain change)
        if (configServiceRef.current.publicClient !== publicClient) {
            configServiceRef.current.publicClient = publicClient;
        }
        if (configServiceRef.current.walletClient !== walletClient) {
            configServiceRef.current.walletClient = walletClient;
        }
        // Re-check readiness flags whenever clients change
        configServiceRef.current.checkReadyForRead();
        configServiceRef.current.checkReadyForWrite();
    }
  }, [provider, publicClient, walletClient]);

  /**
   * Memoized boolean indicating if the ConfigurationService instance exists and is ready for read operations.
   * @type {boolean}
   */
  const configServiceInstanceReady = useMemo(() => {
      return !!configServiceRef.current && isUpProviderStableForRead;
  }, [isUpProviderStableForRead]);

  // Effect to load global reactions and MIDI map when profile or service readiness changes
  useEffect(() => {
    const loadGlobalSettings = async () => {
        if (currentProfileAddress && configServiceInstanceReady && configServiceRef.current) {
            const service = configServiceRef.current;
            setIsLoadingGlobals(true);
            setGlobalLoadError(null);
            let currentLoadErrors = [];

            try {
                const reactionsHex = await service.loadDataFromKey(currentProfileAddress, RADAR_EVENT_REACTIONS_KEY);
                if (reactionsHex && reactionsHex !== '0x') {
                    setSavedReactions(JSON.parse(hexToString(reactionsHex)));
                } else {
                    setSavedReactions({}); // Reset if no data or '0x'
                }
            } catch (e) {
                if (import.meta.env.DEV) {
                    console.error("Error loading global reactions:", e);
                }
                currentLoadErrors.push(`Reactions: ${e.message}`);
                setSavedReactions({}); // Reset on error
            }

            try {
                const midiHex = await service.loadDataFromKey(currentProfileAddress, RADAR_MIDI_MAP_KEY);
                if (midiHex && midiHex !== '0x') {
                    setMidiMap(JSON.parse(hexToString(midiHex)));
                } else {
                    setMidiMap({}); // Reset if no data or '0x'
                }
            } catch (e) {
                if (import.meta.env.DEV) {
                    console.error("Error loading global MIDI map:", e);
                }
                currentLoadErrors.push(`MIDI: ${e.message}`);
                setMidiMap({}); // Reset on error
            }

            if (currentLoadErrors.length > 0) {
                setGlobalLoadError(currentLoadErrors.join('; '));
            }

            setIsLoadingGlobals(false);
        } else {
            // Reset state if no address or service not ready
            setSavedReactions({});
            setMidiMap({});
            setIsLoadingGlobals(false); // Ensure loading is false if conditions aren't met
            setGlobalLoadError(null);
        }
    };

    // Determine if a load should be triggered
    const shouldLoad = currentProfileAddress && configServiceInstanceReady && !isLoadingGlobals;
    const addressChanged = currentProfileAddress !== prevProfileAddressForGlobalsRef.current;

    if (addressChanged || (shouldLoad && prevProfileAddressForGlobalsRef.current !== currentProfileAddress)) {
        prevProfileAddressForGlobalsRef.current = currentProfileAddress;
        loadGlobalSettings();
    } else if (!currentProfileAddress && prevProfileAddressForGlobalsRef.current !== null) { // Handle address becoming null
        prevProfileAddressForGlobalsRef.current = null;
        setSavedReactions({});
        setMidiMap({});
        setIsLoadingGlobals(false);
        setGlobalLoadError(null);
    }

  // Only re-run load when address or service readiness fundamentally changes, or loading finishes.
  // Avoid re-fetching constantly on transient errors by not including globalLoadError here.
  }, [currentProfileAddress, configServiceInstanceReady, isLoadingGlobals]);


  /**
   * Saves the current global event reactions state to the host profile via ConfigurationService.
   * @async
   * @returns {Promise<{success: boolean, error?: string}>} A promise resolving with the save operation result.
   */
  const saveGlobalReactions = useCallback(async () => {
     const service = configServiceRef.current;
     const addressToSave = currentProfileAddress;
     // Check service readiness for writing
     const isReady = !!service && configServiceInstanceReady && service.checkReadyForWrite();
     if (!isReady || !addressToSave) {
         const errorMsg = !isReady ? "Configuration service not ready for writing." : "No host profile address provided.";
         addToast(errorMsg, "error"); return { success: false, error: errorMsg };
     }
     setIsSavingGlobal(true); setGlobalSaveError(null); setGlobalSaveSuccess(false);
     try {
         const dataKey = RADAR_EVENT_REACTIONS_KEY; const dataToSave = savedReactions || {};
         const jsonString = JSON.stringify(dataToSave); const hexValue = stringToHex(jsonString);
         const result = await service.saveDataToKey(addressToSave, dataKey, hexValue);
         if (result.success) {
            addToast(`Global reactions saved successfully!`, 'success');
            setGlobalSaveSuccess(true);
            // Assuming successful save clears pending changes related to reactions
            // Note: This might need adjustment if other pending changes exist.
            setHasPendingChanges(false);
         } else { throw new Error(result.error || "Save reactions operation failed."); }
         return result;
     } catch (error) {
        const errorMsg = error.message || `An unknown error occurred while saving reactions.`; setGlobalSaveError(errorMsg);
        addToast(`Error saving reactions: ${errorMsg}`, 'error');
        setGlobalSaveSuccess(false); return { success: false, error: errorMsg };
     } finally {
        setIsSavingGlobal(false);
     }
  }, [currentProfileAddress, savedReactions, addToast, configServiceInstanceReady, setHasPendingChanges]);

  /**
   * Saves the current global MIDI map state (for the host profile) to the host profile via ConfigurationService.
   * @async
   * @returns {Promise<{success: boolean, error?: string}>} A promise resolving with the save operation result.
   */
  const saveGlobalMidiMap = useCallback(async () => {
     const service = configServiceRef.current;
     const addressToSave = currentProfileAddress;
     // Check service readiness for writing
     const isReady = !!service && configServiceInstanceReady && service.checkReadyForWrite();
     if (!isReady || !addressToSave) {
         const errorMsg = !isReady ? "Configuration service not ready for writing." : "No host profile address provided.";
         addToast(errorMsg, "error"); return { success: false, error: errorMsg };
     }
    setIsSavingGlobal(true); setGlobalSaveError(null); setGlobalSaveSuccess(false);
     try {
        const dataKey = RADAR_MIDI_MAP_KEY; const dataToSave = midiMap || {}; // Use midiMap from this hook's state
        const jsonString = JSON.stringify(dataToSave); const hexValue = stringToHex(jsonString);
        const result = await service.saveDataToKey(addressToSave, dataKey, hexValue);
        if (result.success) {
            addToast(`Global MIDI map saved successfully!`, 'success');
            setGlobalSaveSuccess(true);
            // Assuming successful save clears pending changes related to the MIDI map
            // Note: This might need adjustment if other pending changes exist.
            setHasPendingChanges(false);
         } else { throw new Error(result.error || "Save MIDI map operation failed."); }
         return result;
     } catch (error) {
        const errorMsg = error.message || `An unknown error occurred while saving the MIDI map.`; setGlobalSaveError(errorMsg);
        addToast(`Error saving MIDI map: ${errorMsg}`, 'error');
        setGlobalSaveSuccess(false); return { success: false, error: errorMsg };
     } finally {
        setIsSavingGlobal(false);
     }
  }, [currentProfileAddress, midiMap, addToast, configServiceInstanceReady, setHasPendingChanges]);

  /**
   * Updates or adds a specific event reaction configuration in the local state. Sets `hasPendingChanges` to true.
   * @param {string} eventType - The identifier for the event type (e.g., 'up:reaction:received').
   * @param {object} reactionData - The configuration data for this reaction.
   * @returns {void}
   */
  const updateSavedReaction = useCallback((eventType, reactionData) => {
      if (!eventType || !reactionData) return;
      setSavedReactions((prev) => ({ ...prev, [eventType]: reactionData }));
      setHasPendingChanges(true);
  }, [setHasPendingChanges]);

  /**
   * Removes an event reaction configuration from the local state by its event type. Sets `hasPendingChanges` to true if a deletion occurred.
   * @param {string} eventType - The identifier for the event type to remove.
   * @returns {void}
   */
  const deleteSavedReaction = useCallback((eventType) => {
    if (!eventType) return;
    setSavedReactions((prev) => {
      const newState = { ...prev };
      if (newState[eventType]) {
        delete newState[eventType];
        setHasPendingChanges(true); // Mark changes as pending only if deletion happened
        return newState;
      }
      return prev; // Return previous state if key didn't exist
    });
  }, [setHasPendingChanges]);

  /**
   * Replaces the entire MIDI map configuration in the local state (for the host profile). Sets `hasPendingChanges` to true.
   * @param {object} newMap - The new MIDI map object.
   * @returns {void}
   */
  const updateMidiMap = useCallback((newMap) => {
    setMidiMap(newMap || {}); // Ensure it's an object, default to empty if null/undefined
    setHasPendingChanges(true);
  }, [setHasPendingChanges]);

  // Memoize the final context state provided by this hook
  const contextState = useMemo(() => ({
      configServiceInstanceReady,
      configServiceRef,
      savedReactions,
      midiMap,
      isSavingGlobal,
      globalSaveError,
      globalSaveSuccess,
      hasPendingChanges,
      setHasPendingChanges,
      saveGlobalReactions,
      saveGlobalMidiMap,
      updateSavedReaction,
      deleteSavedReaction,
      updateMidiMap,
      isLoadingGlobals,
      globalLoadError,
  }), [
      configServiceInstanceReady, configServiceRef,
      savedReactions, midiMap, isSavingGlobal, globalSaveError, globalSaveSuccess,
      hasPendingChanges, setHasPendingChanges, saveGlobalReactions, saveGlobalMidiMap,
      updateSavedReaction, deleteSavedReaction, updateMidiMap,
      isLoadingGlobals, globalLoadError
  ]);

  return contextState;
};

export default useConfigState;
```

---
### `src\hooks\useCoreApplicationStateAndLifecycle.js`
```js
// src/hooks/useCoreApplicationStateAndLifecycle.js
import { useRef, useEffect, useCallback, useMemo } from "react";
import { useCanvasOrchestrator } from "./useCanvasOrchestrator";
import { useRenderLifecycle } from './useRenderLifecycle';
import { useCanvasContainer } from './useCanvasContainer';
import { useAudioVisualizer } from './useAudioVisualizer';
import { useAnimationLifecycleManager } from './useAnimationLifecycleManager';

/**
 * @typedef {import('../services/ConfigService').default} ConfigService
 * @typedef {import('../utils/CanvasManager').default} CanvasManager // Corrected path if CanvasManager is in utils
 * @typedef {import('./useAudioVisualizer').AudioVisualizerAPI} AudioVisualizerState // Assuming useAudioVisualizer returns an object matching this type
 * @typedef {import('../context/VisualConfigContext').AllLayerConfigs} LayerConfigsType // Placeholder, assuming defined in VisualConfigContext or a types file
 * @typedef {import('../context/VisualConfigContext').TokenAssignments} TokenAssignmentsType // Placeholder, assuming defined or imported
 */

/**
 * @typedef {object} UseCoreApplicationStateAndLifecycleProps
 * @property {{ "1": React.RefObject<HTMLCanvasElement>, "2": React.RefObject<HTMLCanvasElement>, "3": React.RefObject<HTMLCanvasElement> }} canvasRefs - Refs to the HTML canvas elements for each layer.
 * @property {React.RefObject<ConfigService | null>} configServiceRef - Ref to the ConfigurationService instance.
 * @property {number} configLoadNonce - A nonce that changes when a new global configuration (preset) is loaded.
 * @property {LayerConfigsType} currentActiveLayerConfigs - The currently active layer configurations from `VisualConfigContext`.
 * @property {TokenAssignmentsType} currentActiveTokenAssignments - The currently active token assignments from `VisualConfigContext`.
 * @property {LayerConfigsType | null} loadedLayerConfigsFromPreset - Layer configurations loaded from the most recent preset (via `PresetManagementContext`).
 * @property {TokenAssignmentsType | null} loadedTokenAssignmentsFromPreset - Token assignments loaded from the most recent preset (via `PresetManagementContext`).
 * @property {Error | string | null} loadError - Error object or message from preset loading.
 * @property {Error | null} upInitializationError - Error from `UpProvider` initialization.
 * @property {Error | null} upFetchStateError - Error from `UpProvider` client fetching.
 * @property {boolean} isConfigLoading - Indicates if a configuration preset is currently being loaded.
 * @property {boolean} isInitiallyResolved - Indicates if the initial configuration (preset or fallback) has been resolved.
 * @property {string | null} currentConfigName - The name of the currently loaded configuration preset.
 * @property {string | null} currentProfileAddress - The address of the current Universal Profile being viewed.
 * @property {boolean} isBenignOverlayActive - Flag indicating if a non-blocking overlay (e.g., toasts) is active.
 * @property {string | null} animatingPanel - Identifier of any UI panel currently undergoing an open/close animation.
 * @property {boolean} animationLockForTokenOverlay - Flag to temporarily lock animation state changes during token overlay transitions.
 */

/**
 * @typedef {object} CoreApplicationStateAndLifecycle
 * @property {React.RefObject<HTMLDivElement>} containerRef - Ref to the main canvas container element.
 * @property {React.RefObject<{[key: string]: CanvasManager}>} managerInstancesRef - Ref to the initialized CanvasManager instances.
 * @property {AudioVisualizerState} audioState - State and functions related to audio visualization, from `useAudioVisualizer`.
 * @property {string} renderState - The current state of the rendering lifecycle (e.g., 'initializing', 'rendered', 'error').
 * @property {string} loadingStatusMessage - A message indicating the current loading or status.
 * @property {boolean} isStatusFadingOut - True if the status message display is currently fading out.
 * @property {boolean} showStatusDisplay - True if the loading/status display should be visible.
 * @property {boolean} showRetryButton - True if a retry button should be shown (typically in a recoverable error state).
 * @property {boolean} isTransitioning - True if a preset transition (fade-out/fade-in) is currently active.
 * @property {Set<string> | null} outgoingLayerIdsOnTransitionStart - A set of layer IDs that were active when a transition started.
 * @property {boolean} makeIncomingCanvasVisible - A flag to signal when incoming canvases (for a new preset) should become visible.
 * @property {boolean} isAnimating - True if canvas animations are considered to be (or should be) running.
 * @property {() => void} handleManualRetry - Function to attempt a manual retry from an error state.
 * @property {() => void} resetLifecycle - Function to reset the entire render lifecycle to its initial state.
 * @property {boolean} managersReady - True if all expected CanvasManager instances are initialized and ready.
 * @property {boolean} defaultImagesLoaded - True if the initial default images for all layers have been successfully loaded.
 * @property {() => void} stopCanvasAnimations - Function to stop animations on all managed canvases.
 * @property {() => void} restartCanvasAnimations - Function to restart animations on all managed canvases.
 * @property {(configs: LayerConfigsType) => void} applyConfigurationsToManagers - Applies full layer configurations to all canvas managers. (Note: `useCanvasOrchestrator`'s version might be async if it involves image loading based on config, but the one passed to `useRenderLifecycle` is often synchronous for config application itself).
 * @property {(assignments: TokenAssignmentsType) => Promise<void>} applyTokenAssignmentsToManagers - Resolves and applies token/image assignments to canvas layers.
 * @property {(configs?: LayerConfigsType | null) => Promise<boolean>} redrawAllCanvases - Forces a redraw on all canvases, optionally applying new configurations.
 * @property {(layerId: string, src: string) => Promise<void>} setCanvasLayerImage - Sets an image for a specific canvas layer directly.
 * @property {boolean} hasValidDimensions - Indicates if the canvas container currently has valid (non-zero) width and height.
 * @property {boolean} isContainerObservedVisible - Indicates if the container is currently considered visible within the viewport.
 * @property {boolean} isFullscreenActive - Indicates if the browser is currently in fullscreen mode.
 * @property {() => void} enterFullscreen - Function to attempt to toggle fullscreen mode.
 * @property {React.RefObject<boolean>} isMountedRef - Ref indicating if the component consuming this hook (or this hook itself) is mounted.
 */

/**
 * `useCoreApplicationStateAndLifecycle` is a custom React hook designed to consolidate and manage
 * the primary operational state and lifecycle logic for the RADAR application's core visual and interactive elements.
 * It achieves this by internally initializing and orchestrating several other specialized hooks:
 *
 * - `useCanvasOrchestrator`: Manages the creation, image loading, and configuration application for individual canvas layers.
 * - `useAudioVisualizer`: Handles audio input, analysis, and provides data for audio-reactive visuals.
 * - `useCanvasContainer`: Observes the main canvas container for resize events, viewport visibility, and manages fullscreen state.
 * - `useRenderLifecycle`: Implements a state machine to control the overall rendering process, including initial loading, preset transitions, and error states.
 * - `useAnimationLifecycleManager`: Decides when canvas animations should start or stop based on various application states (visibility, UI interactions, transitions).
 *
 * This hook acts as a central hub, taking numerous pieces of application-wide state (like current configurations,
 * preset loading status, and UI interaction flags) as input props. It then wires these inputs and the outputs of
 * its internal hooks together to create a cohesive operational flow.
 *
 * **Key Responsibilities:**
 * 1.  **Initialization:** Sets up the core visual and audio processing systems.
 * 2.  **State Aggregation:** Collects and exposes essential state variables (e.g., `renderState`, `isAnimating`, `managersReady`) required by the main application view (`MainView.jsx`) for rendering its UI and orchestrating high-level behaviors.
 * 3.  **Lifecycle Management:**
 *     - Manages an `isMountedRef` to track component mount status, crucial for preventing state updates on unmounted components within async operations or timeouts.
 *     - Exposes a `resetLifecycle` function (from `useRenderLifecycle`) to allow the application to revert to an initial state, for instance, upon profile changes or critical errors.
 *     - Integrates `useAnimationLifecycleManager` to intelligently pause or resume canvas animations, optimizing performance and visual correctness.
 * 4.  **Callback Provision:** Defines and provides stable callbacks (e.g., for handling zero-dimension errors from `useCanvasContainer`) to its internal hooks.
 * 5.  **Memoization:** The entire object returned by this hook is memoized using `React.useMemo`. This is critical for performance, ensuring that consuming components (like `MainView.jsx`) only re-render when the actual data or function references they depend on have changed, rather than on every render of this hook.
 *
 * **Props (`UseCoreApplicationStateAndLifecycleProps`):**
 * This hook accepts a comprehensive set of props that represent the current global state of the application, including:
 * - Canvas element references (`canvasRefs`).
 * - Configuration service reference (`configServiceRef`).
 * - State related to preset loading and current configurations (`configLoadNonce`, `currentActiveLayerConfigs`, etc.).
 * - Error states from various parts of the application (`loadError`, `upInitializationError`).
 * - Flags indicating UI states that might affect animations (`isBenignOverlayActive`, `animatingPanel`).
 *
 * **Returns (`CoreApplicationStateAndLifecycle`):**
 * It returns a single, memoized object containing:
 * - Refs to important elements (`containerRef`, `managerInstancesRef`, `isMountedRef`).
 * - Aggregated state from its internal hooks (e.g., `audioState`, `renderState`, `isAnimating`).
 * - Key functions for controlling the application's core lifecycle and visuals (e.g., `handleManualRetry`, `resetLifecycle`, `stopCanvasAnimations`, `applyConfigurationsToManagers`, `enterFullscreen`).
 *
 * By centralizing this complex orchestration, `useCoreApplicationStateAndLifecycle` simplifies the `MainView` component, making it more focused on rendering and delegating complex state interactions.
 *
 * @param {UseCoreApplicationStateAndLifecycleProps} props - The properties required to initialize and manage the core application state and lifecycle.
 * @returns {CoreApplicationStateAndLifecycle} A memoized object containing the consolidated state and control functions.
 */
export const useCoreApplicationStateAndLifecycle = (props) => {
  const {
    canvasRefs,
    configServiceRef,
    configLoadNonce,
    currentActiveLayerConfigs,
    currentActiveTokenAssignments,
    loadedLayerConfigsFromPreset,
    loadedTokenAssignmentsFromPreset,
    loadError,
    upInitializationError,
    upFetchStateError,
    isConfigLoading,
    isInitiallyResolved,
    currentConfigName,
    currentProfileAddress,
    isBenignOverlayActive,
    animatingPanel,
    animationLockForTokenOverlay,
  } = props;

  const isMountedRef = useRef(false);
  const internalResetLifecycleRef = useRef(null);

  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const {
    managersReady, defaultImagesLoaded, managerInstancesRef,
    applyConfigurationsToManagers, applyTokenAssignmentsToManagers,
    stopCanvasAnimations, restartCanvasAnimations,
    redrawAllCanvases, handleCanvasResize, setCanvasLayerImage,
  } = useCanvasOrchestrator({ configServiceRef, canvasRefs, configLoadNonce });

  const audioState = useAudioVisualizer();

  const handleZeroDimensionsOrchestrator = useCallback(() => {
    if (isMountedRef.current && internalResetLifecycleRef.current && typeof internalResetLifecycleRef.current === 'function') {
      if (import.meta.env.DEV) console.log("[CoreAppLifecycle] Zero dimensions detected, triggering lifecycle reset.");
      internalResetLifecycleRef.current();
    }
  }, []); // isMountedRef and internalResetLifecycleRef are stable refs

  const onResizeCanvasContainer = useCallback(() => {
    if (isMountedRef.current && typeof handleCanvasResize === 'function') {
      handleCanvasResize();
    }
  }, [handleCanvasResize]); // handleCanvasResize from useCanvasOrchestrator should be stable

  const { containerRef, hasValidDimensions, isContainerObservedVisible, isFullscreenActive, enterFullscreen } = useCanvasContainer({
    onResize: onResizeCanvasContainer,
    onZeroDimensions: handleZeroDimensionsOrchestrator,
  });

  const renderLifecycleData = useRenderLifecycle({
    managersReady, defaultImagesLoaded, isInitiallyResolved, hasValidDimensions,
    isContainerObservedVisible, configLoadNonce, currentConfigName, currentProfileAddress,
    layerConfigs: currentActiveLayerConfigs,
    tokenAssignments: currentActiveTokenAssignments,
    targetLayerConfigsForPreset: loadedLayerConfigsFromPreset,
    targetTokenAssignmentsForPreset: loadedTokenAssignmentsFromPreset,
    loadError, upInitializationError, upFetchStateError,
    stopAllAnimations: stopCanvasAnimations,
    applyConfigurationsToManagers: applyConfigurationsToManagers,
    applyTokenAssignments: applyTokenAssignmentsToManagers,
    redrawAllCanvases: redrawAllCanvases,
    restartCanvasAnimations: restartCanvasAnimations,
    isLoading: isConfigLoading,
    managerInstancesRef,
  });
  const {
    renderState, loadingStatusMessage, isStatusFadingOut, showStatusDisplay,
    showRetryButton, isTransitioning,
    outgoingLayerIdsOnTransitionStart,
    makeIncomingCanvasVisible,
    isAnimating, handleManualRetry, resetLifecycle
  } = renderLifecycleData;

  useEffect(() => {
    internalResetLifecycleRef.current = resetLifecycle;
  }, [resetLifecycle]); // resetLifecycle from useRenderLifecycle should be stable

  useAnimationLifecycleManager({
    isMounted: isMountedRef.current,
    renderState,
    isContainerObservedVisible,
    isBenignOverlayActive,
    animatingPanel,
    isAnimating,
    isTransitioning,
    restartCanvasAnimations,
    stopCanvasAnimations,
    animationLockForTokenOverlay,
  });

  return useMemo(() => ({
    containerRef,
    managerInstancesRef,
    audioState,
    renderState,
    loadingStatusMessage,
    isStatusFadingOut,
    showStatusDisplay,
    showRetryButton,
    isTransitioning,
    outgoingLayerIdsOnTransitionStart,
    makeIncomingCanvasVisible,
    isAnimating,
    handleManualRetry,
    resetLifecycle,
    managersReady,
    defaultImagesLoaded,
    stopCanvasAnimations,
    restartCanvasAnimations,
    applyConfigurationsToManagers,
    applyTokenAssignmentsToManagers,
    redrawAllCanvases,
    setCanvasLayerImage,
    hasValidDimensions,
    isContainerObservedVisible,
    isFullscreenActive,
    enterFullscreen,
    isMountedRef,
  }), [
    containerRef, managerInstancesRef, audioState, renderState, loadingStatusMessage,
    isStatusFadingOut, showStatusDisplay, showRetryButton, isTransitioning,
    outgoingLayerIdsOnTransitionStart, makeIncomingCanvasVisible, isAnimating,
    handleManualRetry, resetLifecycle, managersReady, defaultImagesLoaded,
    stopCanvasAnimations, restartCanvasAnimations, applyConfigurationsToManagers,
    applyTokenAssignmentsToManagers, redrawAllCanvases, setCanvasLayerImage,
    hasValidDimensions, isContainerObservedVisible, isFullscreenActive, enterFullscreen,
    isMountedRef
  ]);
};
```

---
### `src\hooks\useLsp1Events.js`
```js
// src/hooks/useLsp1Events.js
import { useEffect, useRef } from 'react';

import LSP1EventService from '../services/LSP1EventService'; // Local service

import { isAddress } from 'viem'; // Third-party library

/**
 * @typedef {object} Lsp1Event - Represents an event received from the LSP1EventService.
 * Structure depends on the specific event type.
 */

/**
 * Manages the lifecycle of an LSP1EventService instance, automatically
 * initializing, connecting, and cleaning up based on the provided profileAddress.
 * It subscribes to events from the service using the provided `onEventReceived`
 * callback, ensuring the callback reference is kept up-to-date without causing
 * unnecessary effect re-runs.
 *
 * @param {string | null} profileAddress - The address of the Universal Profile to listen to. The service will connect/disconnect as this address changes or becomes null/invalid.
 * @param {(event: Lsp1Event) => void} onEventReceived - Callback function executed when a new LSP1 event is received from the service.
 * @returns {void} This hook does not return a value but manages side effects.
 */
export function useLsp1Events(profileAddress, onEventReceived) {
  /** @type {React.RefObject<LSP1EventService | null>} */
  const eventServiceRef = useRef(null);
  /** @type {React.RefObject<() => void>} */
  const unsubscribeRef = useRef(() => {});
  /** @type {React.RefObject<(event: Lsp1Event) => void>} */
  const onEventReceivedRef = useRef(onEventReceived);

  // Keep the callback ref updated to avoid adding it to the main effect's dependencies
  useEffect(() => {
    onEventReceivedRef.current = onEventReceived;
  }, [onEventReceived]);

  // Effect to manage the service lifecycle based on profileAddress
  useEffect(() => {
    /** @type {boolean} - Tracks if the component is still mounted to prevent state updates on unmounted components. */
    let isMounted = true;

    const initializeAndListen = async (address) => {
      // Cleanup existing service before creating a new one
      if (eventServiceRef.current) {
        if (typeof unsubscribeRef.current === 'function') unsubscribeRef.current();
        eventServiceRef.current.cleanupListeners();
        eventServiceRef.current = null;
        unsubscribeRef.current = () => {};
      }

      const service = new LSP1EventService();
      eventServiceRef.current = service; // Store the instance immediately

      try {
        await service.initialize();
        if (!isMounted) {
          // Clean up the newly created service if unmounted during init
          service.cleanupListeners();
          eventServiceRef.current = null;
          return;
        }

        const success = await service.setupEventListeners(address);
        if (success && isMounted) {
          // Subscribe using the ref to the latest callback
          unsubscribeRef.current = service.onEvent((event) => {
            if (onEventReceivedRef.current) {
              onEventReceivedRef.current(event);
            }
          });
        } else if (!success && isMounted) {
          if (import.meta.env.DEV) {
            console.warn(`[useLsp1Events] Failed to set up listeners for ${address}.`);
          }
          service.cleanupListeners();
          eventServiceRef.current = null;
        } else if (!isMounted) {
           // Clean up if unmounted during listener setup
           service.cleanupListeners();
           eventServiceRef.current = null;
        }
      } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`[useLsp1Events] Error initializing/setting up service for ${address}:`, error);
        }
        if (eventServiceRef.current) { // Check ref before cleanup
            eventServiceRef.current.cleanupListeners();
            eventServiceRef.current = null;
        }
        unsubscribeRef.current = () => {};
      }
    };

    const cleanupService = () => {
      if (typeof unsubscribeRef.current === 'function') {
        unsubscribeRef.current();
        unsubscribeRef.current = () => {};
      }
      if (eventServiceRef.current) {
        eventServiceRef.current.cleanupListeners();
        eventServiceRef.current = null;
      }
    };

    if (profileAddress && isAddress(profileAddress)) {
      initializeAndListen(profileAddress);
    } else {
      cleanupService();
    }

    // Cleanup function for when the hook unmounts or profileAddress changes
    return () => {
      isMounted = false;
      cleanupService();
    };
  }, [profileAddress]); // Only re-run when the profileAddress changes
}
```

---
### `src\hooks\useNotifications.js`
```js
// src/hooks/useNotifications.js
import { useState, useCallback, useMemo, useEffect } from "react";

const LOCAL_STORAGE_KEY = "axyz_app_notifications";

/**
 * @typedef {object} NotificationItem
 * @property {string|number} id - Unique identifier for the notification.
 * @property {number} timestamp - Timestamp of when the notification was created or received.
 * @property {boolean} read - Whether the notification has been marked as read.
 * @property {string} [messageFromInput] - Optional: A pre-formatted message if provided directly to addNotification.
 * @property {string} type - Event type (e.g., 'follower_gained', 'lyx_received'). From LSP1EventService.
 * @property {string} [typeId] - The on-chain typeId of the event. From LSP1EventService.
 * @property {string} [sender] - Sender address. From LSP1EventService.
 * @property {string} [value] - Event value. From LSP1EventService.
 * @property {string} [data] - Raw receivedData. From LSP1EventService.
 * @property {object} [decodedPayload] - Decoded payload, e.g., followerAddress. From LSP1EventService.
 * @property {string} [link] - Optional: A URL link associated with the notification (if provided to addNotification).
 */

/**
 * @typedef {object} NotificationInput
 * @property {string} [message] - Optional: A pre-formatted message. If not provided, NotificationItem will generate one.
 * @property {string} type - REQUIRED: Event type from LSP1EventService or a custom type.
 * @property {string} [typeId] - Optional: The on-chain typeId.
 * @property {string} [sender] - Optional: Sender address.
 * @property {string} [value] - Optional: Event value.
 * @property {string} [data] - Optional: Raw receivedData.
 * @property {object} [decodedPayload] - Optional: Decoded payload.
 * @property {string} [link] - Optional: A URL link.
 * @property {string|number} [id] - Optional: Predefined ID.
 * @property {number} [timestamp] - Optional: Predefined timestamp.
 * @property {boolean} [read] - Optional: Initial read status.
 */

/**
 * @typedef {object} NotificationsAPI
 * @property {Array<NotificationItem>} notifications - The current array of notification objects.
 * @property {(notificationInput: NotificationInput) => void} addNotification - Adds a new notification to the list.
 * @property {(id: string|number) => void} markAsRead - Marks a specific notification as read by its ID.
 * @property {() => void} markAllAsRead - Marks all current notifications as read.
 * @property {(id: string|number) => void} removeNotification - Removes a specific notification from the list by its ID.
 * @property {() => void} clearAll - Removes all notifications from the list.
 * @property {number} unreadCount - The count of unread notifications.
 */

/**
 * Manages a list of notifications, providing functions to add, remove,
 * mark as read, and clear notifications. It persists the notification state
 * to localStorage to maintain notifications across sessions. It also calculates
 * and provides the count of unread notifications.
 *
 * @param {Array<NotificationItem>} [initialNotifications=[]] - An optional initial array of notification objects. Primarily used if localStorage is empty or fails.
 * @returns {NotificationsAPI} An object containing the current notifications array, functions to manage them, and the unread count.
 */
export function useNotifications(initialNotifications = []) {
  const [notifications, setNotifications] = useState(() => {
    try {
      const storedNotifications = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (storedNotifications) {
        const parsed = JSON.parse(storedNotifications);
        if (Array.isArray(parsed)) {
          return parsed;
        }
      }
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(
          "[useNotifications] Error loading notifications from localStorage:",
          error,
        );
      }
    }
    return Array.isArray(initialNotifications) ? initialNotifications : [];
  });

  // Effect to save notifications to localStorage whenever they change
  useEffect(() => {
    try {
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(notifications));
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(
          "[useNotifications] Error saving notifications to localStorage:",
          error,
        );
      }
    }
  }, [notifications]);

  /**
   * Adds a new notification to the list, ensuring a unique ID and timestamp.
   * @param {NotificationInput} notificationInput - The notification object to add.
   */
  const addNotification = useCallback((notificationInput) => {
    // The `notificationInput` object is the `eventObj` from LSP1EventService
    // or a custom object if addNotification is called from elsewhere.
    const formattedNotification = {
      // Fields directly from LSP1EventService's eventObj or from custom input
      id: notificationInput.id || `notification_${Date.now()}_${Math.random().toString(16).slice(2)}`,
      timestamp: notificationInput.timestamp || Date.now(),
      read: notificationInput.read || false,
      type: notificationInput.type, // This is the human-readable eventTypeName
      typeId: notificationInput.typeId, // The on-chain typeId
      sender: notificationInput.sender, // The determined sender/initiator
      value: notificationInput.value,   // The event value
      data: notificationInput.data,     // The raw receivedData
      decodedPayload: notificationInput.decodedPayload, // Contains followerAddress etc.
      
      // Optional fields that might be passed if addNotification is called with a custom object
      messageFromInput: notificationInput.message, // If a pre-formatted message is passed
      link: notificationInput.link,
    };
    setNotifications((prev) => [formattedNotification, ...prev]); // Prepend
  }, []);

  /**
   * Marks a specific notification as read by its ID.
   * @param {string|number} id - The ID of the notification to mark as read.
   */
  const markAsRead = useCallback((id) => {
    setNotifications((prev) =>
      prev.map((notif) => (notif.id === id ? { ...notif, read: true } : notif)),
    );
  }, []);

  /** Marks all current notifications as read. */
  const markAllAsRead = useCallback(() => {
    setNotifications((prev) => prev.map((notif) => ({ ...notif, read: true })));
  }, []);

  /**
   * Removes a specific notification from the list by its ID.
   * @param {string|number} id - The ID of the notification to remove.
   */
  const removeNotification = useCallback((id) => {
    setNotifications((prev) => prev.filter((notif) => notif.id !== id));
  }, []);

  /** Removes all notifications from the list. */
  const clearAll = useCallback(() => {
    setNotifications([]);
  }, []);

  /** Memoized count of unread notifications. */
  const unreadCount = useMemo(
    () => notifications.filter((n) => !n.read).length,
    [notifications],
  );

  return useMemo(() => ({
    notifications,
    addNotification,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
    unreadCount,
  }), [
    notifications,
    addNotification,
    markAsRead,
    markAllAsRead,
    removeNotification,
    clearAll,
    unreadCount,
  ]);
}
```

---
### `src\hooks\usePanelManager.js`
```js
// src/hooks/usePanelManager.js
import { useState, useCallback, useRef, useEffect, useMemo } from 'react';

const OPEN_ANIMATION_DURATION = 500; 
const CLOSE_ANIMATION_DELAY = 500;   // MODIFIED: Match CSS animation duration (0.5s)

/**
 * @typedef {object} PanelManagerState
 * @property {string | null} activePanel - The identifier of the currently active panel.
 * @property {string | null} animatingPanel - The panel identifier that is currently undergoing an open/close animation (e.g., the panel name when opening, or "closing" when closing).
 * @property {(panelName: string) => void} openPanel - Function to open a specific panel.
 * @property {() => void} closePanel - Function to close the currently active panel.
 * @property {(panelName: string) => void} togglePanel - Function to toggle a panel's state (open if closed, close if open).
 */

/**
 * Manages the state for UI panels, including which panel is currently active
 * and handling the state for opening/closing animations (`animatingPanel`).
 * It uses timeouts to coordinate the animation state with the actual panel visibility.
 * Includes logging to trace panel state changes, especially when closing.
 *
 * @param {string | null} [initialPanel=null] - The panel identifier (string) to be initially active, or null for none.
 * @returns {PanelManagerState} An object containing panel state and control functions.
 */
export function usePanelManager(initialPanel = null) {
  const [activePanel, setActivePanelInternal] = useState(initialPanel);
  const [animatingPanel, setAnimatingPanel] = useState(null);

  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const openTimeoutRef = useRef(null);
  /** @type {React.RefObject<ReturnType<typeof setTimeout> | null>} */
  const closeTimeoutRef = useRef(null);

  const setActivePanel = useCallback((newPanelValue) => {
      const previousActivePanel = activePanel; 
      if (newPanelValue === null && previousActivePanel !== null) {
          if (import.meta.env.DEV) {
            // console.warn(`[usePanelManager] ---> Setting activePanel to NULL! (Previous: '${previousActivePanel}')`); // Kept for debugging if needed
          }
      }
      setActivePanelInternal(newPanelValue);
  }, [activePanel]); 

  useEffect(() => {
    return () => {
      if (openTimeoutRef.current) {
        clearTimeout(openTimeoutRef.current);
      }
      if (closeTimeoutRef.current) {
        clearTimeout(closeTimeoutRef.current);
      }
    };
  }, []);

  const openPanel = useCallback((panelName) => {
    if (closeTimeoutRef.current) {
      clearTimeout(closeTimeoutRef.current);
      closeTimeoutRef.current = null;
    }
    if (openTimeoutRef.current) {
        clearTimeout(openTimeoutRef.current);
        openTimeoutRef.current = null;
    }

    setAnimatingPanel(panelName); 
    setActivePanel(panelName); 

    openTimeoutRef.current = setTimeout(() => {
      setAnimatingPanel(null); 
      openTimeoutRef.current = null;
    }, OPEN_ANIMATION_DURATION);
  }, [setActivePanel]);

  const closePanel = useCallback(() => {
    if (openTimeoutRef.current) {
      clearTimeout(openTimeoutRef.current);
      openTimeoutRef.current = null;
    }
    if (closeTimeoutRef.current) {
        clearTimeout(closeTimeoutRef.current); 
        closeTimeoutRef.current = null;
    }

    setAnimatingPanel("closing"); 

    closeTimeoutRef.current = setTimeout(() => {
      setActivePanel(null); 
      setAnimatingPanel(null); 
      closeTimeoutRef.current = null;
    }, CLOSE_ANIMATION_DELAY);
  }, [setActivePanel]);

  const togglePanel = useCallback((panelName) => {
    if (activePanel === panelName) {
      closePanel();
    } else {
      openPanel(panelName);
    }
  }, [activePanel, openPanel, closePanel]);

  return useMemo(() => ({
    activePanel,
    animatingPanel,
    openPanel,
    closePanel,
    togglePanel,
  }), [activePanel, animatingPanel, openPanel, closePanel, togglePanel]);
}
```

---
### `src\hooks\usePanelState.js`
```js
// src/hooks/usePanelState.js
import { useState, useCallback, useEffect, useMemo } from "react";

/**
 * @typedef {object} PanelState
 * @property {string | null} activePanel - The identifier of the currently active panel (e.g., 'controls', 'notifications', 'tokens'), or null if no panel is active.
 * @property {boolean} tokenSelectorOpen - True if the token selector overlay should be open. This is typically true when `activePanel` is 'tokens'.
 * @property {string} activeLayerTab - The identifier of the currently active layer tab (e.g., 'tab1', 'tab2', 'tab3').
 * @property {React.Dispatch<React.SetStateAction<string>>} setActiveLayerTab - Function to set the active layer tab.
 * @property {(panelName: string | null) => void} togglePanel - Function to toggle a panel's visibility (opens if closed, closes if open). Pass `null` to close the current panel.
 * @property {(panelName: string) => void} openPanel - Function to open a specific panel.
 * @property {() => void} closePanel - Function to close any currently active panel.
 * @property {(panelName: string) => boolean} isPanelActive - Function to check if a specific panel is currently active.
 * @property {() => number} getActiveLayerId - Function to get the numerical layer ID corresponding to the `activeLayerTab`.
 * @property {Object.<string, number>} tabToLayer - A mapping from tab identifiers (e.g., 'tab1') to their corresponding numerical layer IDs (e.g., 1).
 */

/**
 * Manages the state related to UI panels and layer tabs. It tracks which
 * panel (if any) is currently active, whether the dedicated token selector
 * overlay should be open (specifically when the 'tokens' panel is active),
 * and which layer tab (e.g., for layer controls) is currently selected.
 * Provides functions to toggle/open/close panels and check panel status.
 *
 * @param {string|null} [initialPanel=null] - The identifier of the panel to be initially active.
 * @param {string} [initialLayerTab='tab1'] - The identifier of the initially active layer tab.
 * @returns {PanelState} An object containing the panel and tab state, along with functions to manage them.
 */
export function usePanelState(initialPanel = null, initialLayerTab = 'tab1') {
  const [activePanel, setActivePanel] = useState(initialPanel);
  const [tokenSelectorOpen, setTokenSelectorOpen] = useState(initialPanel === "tokens");
  const [activeLayerTab, setActiveLayerTab] = useState(initialLayerTab);

  // Effect to automatically manage the tokenSelectorOpen state based on activePanel
  useEffect(() => {
    setTokenSelectorOpen(activePanel === "tokens");
  }, [activePanel]);

  /**
   * Toggles a panel's visibility: opens if closed, closes if open.
   * @param {string | null} panelName - The name of the panel to toggle, or `null` to close the current panel.
   */
  const togglePanel = useCallback(
    (panelName) => {
      // Ensure 'null' string is treated as actual null for closing
      const cleanPanelName = panelName === "null" ? null : panelName;
      setActivePanel((current) => (current === cleanPanelName ? null : cleanPanelName));
    },
    [], // setActivePanel is stable
  );

  /**
   * Opens a specific panel by its identifier.
   * @param {string} panelName - The name of the panel to open.
   */
  const openPanel = useCallback((panelName) => {
    setActivePanel(panelName);
  }, []); // setActivePanel is stable

  /** Closes any currently active panel. */
  const closePanel = useCallback(() => {
    setActivePanel(null);
  }, []); // setActivePanel is stable

  /**
   * Checks if a specific panel is currently the active one.
   * @param {string} panelName - The name of the panel to check.
   * @returns {boolean} True if the panel is active, false otherwise.
   */
  const isPanelActive = useCallback(
    (panelName) => {
      return activePanel === panelName;
    },
    [activePanel],
  );

  /**
   * Memoized mapping from tab identifiers to layer IDs.
   * This ensures the object reference is stable across renders.
   * @type {Object.<string, number>}
   */
  const tabToLayer = useMemo(() => ({
    tab1: 1,
    tab2: 2,
    tab3: 3,
  }), []); // Empty dependency array means it's created once and memoized

  /**
   * Gets the numerical layer ID corresponding to the currently active tab.
   * @returns {number} The layer ID (e.g., 1, 2, or 3). Defaults to 1 if the tab is not found.
   */
  const getActiveLayerId = useCallback(() => {
    return tabToLayer[activeLayerTab] || 1; // Default to layer 1 if tab mapping is missing
  }, [activeLayerTab, tabToLayer]);

  return useMemo(() => ({
    activePanel,
    tokenSelectorOpen,
    activeLayerTab,
    setActiveLayerTab, // Direct state setter
    togglePanel,
    openPanel,
    closePanel,
    isPanelActive,
    getActiveLayerId,
    tabToLayer,
  }), [
    activePanel,
    tokenSelectorOpen,
    activeLayerTab,
    setActiveLayerTab,
    togglePanel,
    openPanel,
    closePanel,
    isPanelActive,
    getActiveLayerId,
    tabToLayer,
  ]);
}
```

---
### `src\hooks\useProfileCache.js`
```js
// src/hooks/useProfileCache.js
import { useState, useCallback, useMemo } from "react";

import { ERC725 } from "@erc725/erc725.js";
import lsp3ProfileSchema from "@erc725/erc725.js/schemas/LSP3ProfileMetadata.json";

import { isAddress } from "viem";

// Configuration
const RPC_URL = import.meta.env.VITE_LUKSO_MAINNET_RPC_URL || "https://rpc.mainnet.lukso.network";
const IPFS_GATEWAY = import.meta.env.VITE_IPFS_GATEWAY || "https://api.universalprofile.cloud/ipfs/";

// In-memory Cache (shared across hook instances within the session)
/** @type {Object.<string, {data: ProfileData, error: boolean, timestamp: number}>} */
const profileCacheStore = {};
const CACHE_DURATION_MS = 5 * 60 * 1000; // 5 minutes

// Debounce mechanism to prevent fetch storms
/** @type {Map<string, ReturnType<typeof setTimeout>>} */
const fetchDebounceMap = new Map();
const DEBOUNCE_DELAY_MS = 300;

/**
 * @typedef {object} ProfileData The structure of cached or fetched profile data.
 * @property {string} name - The profile name (or a fallback like 'UP (0x...)', or an error indicator like 'Error (0x...)').
 * @property {string | null} profileImage - The resolved URL for the profile image, or null.
 * @property {string | null} backgroundImage - The resolved URL for the background image, or null.
 */

/**
 * @typedef {object} ProfileCacheResult The return value of the useProfileCache hook.
 * @property {(address: string | null) => Promise<ProfileData | null>} getProfileData - Asynchronously fetches profile data for a given address. It utilizes an in-memory cache with expiration and debounces requests for the same address. Returns `null` if the address is invalid or if an error occurs during the initial setup of the fetch. On successful fetch or cache hit, it returns a `ProfileData` object. If an error occurred during fetching or processing, the `name` property of `ProfileData` will indicate an error state (e.g., "Error (0x...)").
 * @property {(address: string | null) => ProfileData | null} getCachedProfile - Synchronously retrieves profile data from the cache if it's valid and not expired. Returns `null` if the address is invalid, or if the data is not in the cache, is expired, or represents a cached error state (use `getProfileData` to re-fetch errors).
 * @property {string | null} isLoadingAddress - The address currently being fetched by this specific hook instance, or `null` if no fetch is in progress for this instance.
 */

/**
 * Provides functions to fetch and cache LSP3 Profile data (name, images) for Lukso Universal Profiles.
 * It uses an in-memory cache with expiration and debounces requests for the same address
 * made in quick succession. It leverages erc725.js for efficient data fetching and decoding.
 *
 * @returns {ProfileCacheResult} An object containing functions to get profile data and the loading status.
 */
export function useProfileCache() {
  // State to track loading status for THIS hook instance
  const [isLoadingAddress, setIsLoadingAddress] = useState(null);

  /**
   * Fetches LSP3 Profile data for an address, checking cache first and debouncing requests.
   * Returns cached data immediately if valid. Otherwise, initiates a debounced fetch.
   * Handles VerifiableURI decoding and IPFS resolution via erc725.js.
   *
   * @param {string | null} address The Universal Profile address to fetch data for.
   * @returns {Promise<ProfileData | null>} A promise resolving to the profile data or null/error object.
   */
  const getProfileData = useCallback(
    async (address) => {
      if (!address || typeof address !== "string" || !isAddress(address)) {
        if (import.meta.env.DEV) {
            console.warn(`[ProfileCache] Invalid address provided to getProfileData: ${address}`);
        }
        return null;
      }
      const lowerAddress = address.toLowerCase();

      const now = Date.now();
      const cachedEntry = profileCacheStore[lowerAddress];

      // Return valid, non-error cache entry immediately
      if (cachedEntry && !cachedEntry.error && now - cachedEntry.timestamp < CACHE_DURATION_MS) {
        return cachedEntry.data;
      }
      // Return cached error state immediately (allows UI to show error without re-fetching immediately)
      if (cachedEntry?.error) {
        // If error is stale, allow re-fetch by not returning here, otherwise return cached error.
        if (now - cachedEntry.timestamp < CACHE_DURATION_MS) {
            return cachedEntry.data;
        }
      }

      // Debounce logic
      if (fetchDebounceMap.has(lowerAddress)) {
        // If a fetch is already debounced for this address, return current cache or loading state
        return cachedEntry?.data || { name: "Loading...", profileImage: null, backgroundImage: null };
      }
      const timerId = setTimeout(() => { fetchDebounceMap.delete(lowerAddress); }, DEBOUNCE_DELAY_MS);
      fetchDebounceMap.set(lowerAddress, timerId);

      setIsLoadingAddress(lowerAddress);

      try {
        const erc725Instance = new ERC725(lsp3ProfileSchema, lowerAddress, RPC_URL, { ipfsGateway: IPFS_GATEWAY });
        const fetchedData = await erc725Instance.fetchData("LSP3Profile");

        if (fetchedData?.value?.LSP3Profile) {
          const profile = fetchedData.value.LSP3Profile;
          const defaultName = `UP (${lowerAddress.slice(0, 6)}...)`;
          const name = profile.name?.trim() ? profile.name.trim() : defaultName;

          const getImageUrl = (images) => {
            if (!Array.isArray(images) || images.length === 0) return null;
            const url = images[0]?.url; // Assuming the first image is the primary one
            if (!url || typeof url !== "string") return null;

            if (url.startsWith("ipfs://")) {
              const hash = url.slice(7);
              const gateway = IPFS_GATEWAY.endsWith("/") ? IPFS_GATEWAY : IPFS_GATEWAY + "/";
              return `${gateway}${hash}`;
            }
            if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith("data:")) return url;

            if (import.meta.env.DEV) {
                console.warn(`[ProfileCache] Unknown image URL format for address ${lowerAddress}: ${url}`);
            }
            return null;
          };

          const profileImageUrl = getImageUrl(profile.profileImage);
          const backgroundImageUrl = getImageUrl(profile.backgroundImage);

          const profileResult = { name, profileImage: profileImageUrl, backgroundImage: backgroundImageUrl };

          profileCacheStore[lowerAddress] = { data: profileResult, error: false, timestamp: Date.now() };
          return profileResult;

        } else {
          if (import.meta.env.DEV) {
            console.warn(`[ProfileCache] LSP3Profile data key found but content invalid or missing for ${lowerAddress}. Fetched data:`, fetchedData);
          }
          // This case indicates that the LSP3Profile key might exist but doesn't contain the expected structure.
          throw new Error("LSP3Profile data key found but content invalid or missing.");
        }
      } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`[ProfileCache] Error fetching or processing profile data for ${lowerAddress}:`, error);
        }
        const errorResult = { name: `Error (${lowerAddress.slice(0, 6)})`, profileImage: null, backgroundImage: null };
        profileCacheStore[lowerAddress] = { data: errorResult, error: true, timestamp: Date.now() };
        return errorResult;
      } finally {
        const currentTimerId = fetchDebounceMap.get(lowerAddress);
        if (currentTimerId === timerId) { // Ensure we only clear the timer we set
            clearTimeout(timerId);
            fetchDebounceMap.delete(lowerAddress);
        }
        // Clear loading state *only if* this instance was the one loading THIS address
        // and the address hasn't changed in the meantime by another call.
        if (isLoadingAddress === lowerAddress) {
             setIsLoadingAddress(null);
        }
      }
    },
    [isLoadingAddress], // isLoadingAddress is specific to this hook instance
  );

  /**
   * Synchronously retrieves profile data from the cache if available, valid, and not an error state.
   * Does NOT trigger a network fetch.
   * @param {string | null} address The Universal Profile address to check in the cache.
   * @returns {ProfileData | null} The cached profile data object, or null if not found/expired/invalid/error.
   */
  const getCachedProfile = useCallback((address) => {
    if (!address || typeof address !== "string" || !isAddress(address)) return null;
    const lowerAddress = address.toLowerCase();
    const cachedEntry = profileCacheStore[lowerAddress];

    // Only return if cached, not an error, and not expired
    if (cachedEntry && !cachedEntry.error && Date.now() - cachedEntry.timestamp < CACHE_DURATION_MS) {
      return cachedEntry.data;
    }
    return null;
  }, []);

  return useMemo(() => ({
    getProfileData,
    getCachedProfile,
    isLoadingAddress
  }), [getProfileData, getCachedProfile, isLoadingAddress]);
}
```

---
### `src\hooks\useRenderLifecycle.js`
```js
// src/hooks/useRenderLifecycle.js
import { useState, useEffect, useCallback, useRef, useMemo } from 'react';

import fallbackConfig from '../config/fallback-config.js'; // Local config

const CANVAS_FADE_DURATION = 250; // User's desired duration for preset fade
const LOADING_FADE_DURATION = 400; // Duration for the loading status message to fade out
const FORCE_REPAINT_DELAY = 50; // Small delay before redrawing to allow DOM updates
const ANIMATION_CONTINUE_DURING_TRANSITION = true;
const CONNECTING_MESSAGE = "Connecting";
const LOADING_CONFIG_MESSAGE = "Loading Configuration";
const APPLYING_CONFIG_MESSAGE = "Applying Configuration";
const TRANSITION_MESSAGE = "Transitioning"; // Ensure this is the message used

/**
 * @typedef {object} RenderLifecycleOptions
 * @property {boolean} managersReady - Indicates if canvas managers are initialized.
 * @property {boolean} defaultImagesLoaded - Indicates if default images for canvases have loaded.
 * @property {boolean} isInitiallyResolved - Indicates if the initial configuration (preset or fallback) has been resolved.
 * @property {boolean} hasValidDimensions - Indicates if the canvas container has valid dimensions.
 * @property {boolean} isContainerObservedVisible - Indicates if the canvas container is visible in the viewport.
 * @property {number} configLoadNonce - A nonce that changes when a new configuration preset is loaded.
 * @property {string|null} [currentConfigName] - The name of the currently loaded configuration preset.
 * @property {string|null} currentProfileAddress - The address of the current Universal Profile being viewed.
 * @property {object} [layerConfigs] - The current layer configurations active in the `VisualConfigContext`.
 * @property {object|null} targetLayerConfigsForPreset - The layer configurations to be applied from a newly loaded preset.
 * @property {object|null} targetTokenAssignmentsForPreset - The token assignments to be applied from a newly loaded preset.
 * @property {Error|string|null} loadError - Error object or message from preset loading.
 * @property {Error|null} upInitializationError - Error from `UpProvider` initialization.
 * @property {Error|null} upFetchStateError - Error from `UpProvider` client fetching.
 * @property {() => void} stopAllAnimations - Function to stop all canvas animations.
 * @property {(configs: object) => void} applyConfigurationsToManagers - Function to apply full configurations to canvas managers.
 * @property {(assignments: object) => Promise<void>} applyTokenAssignments - Function to apply token assignments to canvas managers.
 * @property {(configs?: object|null) => Promise<boolean>} redrawAllCanvases - Function to force redraw all canvases.
 * @property {() => void} restartCanvasAnimations - Function to restart all canvas animations.
 * @property {React.RefObject<Object.<string, import('../utils/CanvasManager').default>>} managerInstancesRef - Ref to the canvas manager instances.
 * @property {boolean} [isLoading] - Optional: Explicit loading state, typically from preset management. Defaults to true if undefined.
 */

/**
 * @typedef {'initializing' | 'waiting_layout' | 'initializing_managers' | 'loading_defaults' | 'resolving_initial_config' | 'fading_out' | 'applying_config' | 'rendered' | 'error'} RenderStateValue - Possible states of the render lifecycle.
 */

/**
 * @typedef {object} RenderLifecycleAPI
 * @property {RenderStateValue} renderState - The current state of the rendering lifecycle.
 * @property {string} loadingStatusMessage - A message indicating the current loading or status.
 * @property {boolean} isStatusFadingOut - True if the status message display is currently fading out.
 * @property {boolean} showStatusDisplay - True if the loading/status display should be visible.
 * @property {boolean} showRetryButton - True if a retry button should be shown (typically in a recoverable error state).
 * @property {boolean} isTransitioning - True if a preset transition (fade-out/fade-in) is currently active.
 * @property {Set<string>} outgoingLayerIdsOnTransitionStart - A set of layer IDs that were active when a transition started, used to manage their fade-out.
 * @property {boolean} makeIncomingCanvasVisible - A flag to signal when incoming canvases (for a new preset) should become visible after a transition.
 * @property {boolean} isAnimating - True if canvas animations are considered to be (or should be) running.
 * @property {() => void} handleManualRetry - Function to attempt a manual retry from an error state.
 * @property {() => void} resetLifecycle - Function to reset the entire render lifecycle to its initial state.
 */
export function useRenderLifecycle(options) {
  const {
    managersReady, defaultImagesLoaded, isInitiallyResolved, hasValidDimensions,
    isContainerObservedVisible, configLoadNonce, currentProfileAddress,
    layerConfigs,
    targetLayerConfigsForPreset,
    targetTokenAssignmentsForPreset,
    loadError, upInitializationError, upFetchStateError,
    stopAllAnimations, applyConfigurationsToManagers,
    applyTokenAssignments,
    redrawAllCanvases,
    restartCanvasAnimations,
    managerInstancesRef,
  } = options;

  const currentIsLoading = options.isLoading === undefined ? true : options.isLoading;

  const [renderState, setRenderStateInternal] = useState('initializing');
  const [loadingStatusMessage, setLoadingStatusMessageState] = useState(CONNECTING_MESSAGE);
  const [isStatusFadingOut, setIsStatusFadingOut] = useState(false);
  const [isTransitioningInternal, setIsTransitioningInternal] = useState(false);
  const [makeIncomingCanvasVisible, setMakeIncomingCanvasVisible] = useState(false);

  const isMountedRef = useRef(false);
  const lastAppliedNonceRef = useRef(0);
  const statusDisplayFadeTimeoutRef = useRef(null);
  const transitionEndTimeoutRef = useRef(null);
  const fadeOutCompletionTimeoutRef = useRef(null);
  const repaintDelayTimeoutRef = useRef(null);
  const applyConfigPromiseRef = useRef(null);
  const animationStateRef = useRef('stopped');
  const outgoingLayerIdsOnTransitionStartRef = useRef(new Set());
  const prevAddressRef = useRef(currentProfileAddress);


  const logAction = useCallback((actionName, details = '') => {
    if (import.meta.env.DEV) {
      console.log(`%c[RenderLifecycle] Action: ${actionName}`, 'color: purple;', details);
    }
  }, []);

  const logStateChange = useCallback((newState, reason) => {
    setRenderStateInternal(prevState => {
      if (prevState !== newState) {
        if (import.meta.env.DEV) {
          console.log(`%c[RenderLifecycle] State CHANGE: ${prevState} -> ${newState} (Reason: ${reason})`, 'color: blue; font-weight: bold;');
        }
        return newState;
      }
      return prevState;
    });
  }, []);

  useEffect(() => {
    isMountedRef.current = true;
    logAction("Component Mounted");
    return () => {
      logAction("Component Unmounting - Cleaning up ALL timers");
      isMountedRef.current = false;
      if (statusDisplayFadeTimeoutRef.current) clearTimeout(statusDisplayFadeTimeoutRef.current);
      if (transitionEndTimeoutRef.current) clearTimeout(transitionEndTimeoutRef.current);
      if (fadeOutCompletionTimeoutRef.current) clearTimeout(fadeOutCompletionTimeoutRef.current);
      if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current);
      applyConfigPromiseRef.current = null;
    };
  }, [logAction]);

  const setLoadingStatusMessage = useCallback((message, forceNoFade = false) => {
    if (isMountedRef.current) {
      setLoadingStatusMessageState(prev => {
          if (prev !== message || forceNoFade) { 
              logAction("Set Status Message", `${message}${forceNoFade ? ' (forced, no fade reset)' : ''}`);
              if (message !== "Render complete" || forceNoFade) {
                setIsStatusFadingOut(false);
                if (statusDisplayFadeTimeoutRef.current) {
                    clearTimeout(statusDisplayFadeTimeoutRef.current);
                    statusDisplayFadeTimeoutRef.current = null;
                }
              }
              return message;
          }
          return prev;
      });
    }
  }, [logAction]); 

  const resetLifecycle = useCallback(() => {
      if (!isMountedRef.current) return;
      logAction(`!!! Resetting Lifecycle Triggered !!!`);
      animationStateRef.current = 'pending_stop';
      logStateChange("initializing", "External Reset");
      setLoadingStatusMessage(CONNECTING_MESSAGE, true); 
      lastAppliedNonceRef.current = 0;
      setIsTransitioningInternal(false);
      setMakeIncomingCanvasVisible(false);
      outgoingLayerIdsOnTransitionStartRef.current.clear();
      applyConfigPromiseRef.current = null;
      setTimeout(() => {
        if (isMountedRef.current && animationStateRef.current === 'pending_stop') {
          logAction(`Executing delayed animation stop after reset`);
          if (stopAllAnimations) stopAllAnimations();
          animationStateRef.current = 'stopped';
        }
      }, CANVAS_FADE_DURATION);
      if (statusDisplayFadeTimeoutRef.current) clearTimeout(statusDisplayFadeTimeoutRef.current);
      if (transitionEndTimeoutRef.current) clearTimeout(transitionEndTimeoutRef.current);
      if (fadeOutCompletionTimeoutRef.current) clearTimeout(fadeOutCompletionTimeoutRef.current);
      if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current);
  }, [stopAllAnimations, setLoadingStatusMessage, logAction, logStateChange]);

  const handleManualRetry = useCallback(() => {
    if (!isMountedRef.current || renderState !== 'error') return;
    logAction(`Manual Retry Triggered.`);
    if (hasValidDimensions) {
      logAction(`Manual Retry: Dimensions valid -> 'applying_config'.`);
      setLoadingStatusMessage(LOADING_CONFIG_MESSAGE, true); 
      logStateChange('applying_config', 'Manual Retry (Valid Dim)');
    } else {
      logAction(`Manual Retry: No valid dimensions. -> 'waiting_layout'`);
      setLoadingStatusMessage("⚠ Still waiting for layout.", true); 
      logStateChange('waiting_layout', 'Manual Retry (No Valid Dim)');
    }
  }, [renderState, hasValidDimensions, setLoadingStatusMessage, logAction, logStateChange]);

  useEffect(() => {
    const criticalError = upInitializationError || upFetchStateError || (loadError && !isInitiallyResolved);
    if (criticalError && renderState !== 'error') {
      const errorSource = upInitializationError ? 'UP Init Error' : upFetchStateError ? 'UP Fetch Error' : 'Initial Load Error';
      const errorMessage = (criticalError)?.message || "Unknown critical error.";
      setLoadingStatusMessage(`⚠ Critical Error: ${errorMessage}`, true); 
      logStateChange('error', `${errorSource}: ${errorMessage}`);
      animationStateRef.current = 'stopped';
      if (stopAllAnimations) stopAllAnimations();
      setIsTransitioningInternal(false);
      setMakeIncomingCanvasVisible(false);
    }
  }, [upInitializationError, upFetchStateError, loadError, isInitiallyResolved, renderState, setLoadingStatusMessage, logStateChange, stopAllAnimations]);

  useEffect(() => {
    if (isMountedRef.current && isInitiallyResolved) {
      const previousAddress = prevAddressRef.current;
      if (previousAddress !== currentProfileAddress) {
         if ( (previousAddress && !currentProfileAddress) || (previousAddress && currentProfileAddress && previousAddress !== currentProfileAddress) ) {
              logAction(`Profile address changed from ${previousAddress||'null'} to ${currentProfileAddress||'null'}. Resetting lifecycle.`);
              resetLifecycle();
         }
         prevAddressRef.current = currentProfileAddress;
      }
    } else if (prevAddressRef.current !== currentProfileAddress) {
         prevAddressRef.current = currentProfileAddress;
     }
  }, [currentProfileAddress, isInitiallyResolved, resetLifecycle, logAction]);

  // Main state machine logic
  useEffect(() => {
    const currentState = renderState;
    if (currentState === 'error' || currentState === 'fading_out' || currentState === 'applying_config') {
        return;
    }

    const hasNewConfigToApply = configLoadNonce > lastAppliedNonceRef.current;

    if (!hasValidDimensions) {
        if (currentState !== 'waiting_layout') {
            setLoadingStatusMessage("Waiting for layout...", true);
            logStateChange('waiting_layout', 'No Layout');
        }
    } else if (!managersReady) {
        if (currentState !== 'initializing_managers') {
            setLoadingStatusMessage("Initializing managers...", true);
            logStateChange('initializing_managers', 'Layout OK -> Init Mgrs');
        }
    } else if (!defaultImagesLoaded) {
        if (currentState !== 'loading_defaults') {
            setLoadingStatusMessage("Loading defaults...", true);
            logStateChange('loading_defaults', 'Mgrs OK -> Load Defaults');
        }
    } else if (!isInitiallyResolved) {
        if (currentState !== 'resolving_initial_config') {
            setLoadingStatusMessage(currentIsLoading ? LOADING_CONFIG_MESSAGE : CONNECTING_MESSAGE, true);
            logStateChange('resolving_initial_config', `Defaults OK -> Resolve Initial (isLoading: ${currentIsLoading})`);
        }
    } else {
        if (hasNewConfigToApply) {
            if (currentState === 'rendered' || currentState === 'applying_config' || currentState === 'fading_out') {
                logAction(`New config nonce ${configLoadNonce} detected. Current state: ${currentState}. Starting transition.`);
                
                setLoadingStatusMessage(TRANSITION_MESSAGE, true); 

                setIsTransitioningInternal(true);
                setMakeIncomingCanvasVisible(false);
                outgoingLayerIdsOnTransitionStartRef.current = new Set(Object.keys(layerConfigs || {}));

                if (ANIMATION_CONTINUE_DURING_TRANSITION && animationStateRef.current === 'running') {
                    animationStateRef.current = 'running_during_transition';
                } else if (!ANIMATION_CONTINUE_DURING_TRANSITION && animationStateRef.current === 'running') {
                    if (stopAllAnimations) stopAllAnimations();
                    animationStateRef.current = 'stopped_for_transition';
                }
                logStateChange('fading_out', 'New Config Detected (from rendered/applying)');
            } else {
                logAction(`New config nonce ${configLoadNonce} detected during ${currentState}. Moving to applying_config directly.`);
                setLoadingStatusMessage(APPLYING_CONFIG_MESSAGE, true);
                logStateChange('applying_config', `${currentState} -> Apply New/Fallback (Direct)`);
            }
        } else if (currentState !== 'rendered') {
            logAction(`All prerequisites met, no new config. Current state ${currentState}. Moving to rendered.`);
            logStateChange('rendered', `${currentState} -> Rendered (Initial Fallback/Default Applied)`);
        }
    }
  }, [
      renderState, managersReady, defaultImagesLoaded, isInitiallyResolved, hasValidDimensions,
      configLoadNonce, currentIsLoading, layerConfigs, 
      setLoadingStatusMessage, logStateChange, logAction, stopAllAnimations
    ]);

  // Effect for 'fading_out' state
  useEffect(() => {
      if (renderState !== 'fading_out') {
        if (fadeOutCompletionTimeoutRef.current) clearTimeout(fadeOutCompletionTimeoutRef.current);
        return;
      }
      logAction(`FADING_OUT: Outgoing canvases should be visually fading out (CSS opacity 0 over ${CANVAS_FADE_DURATION}ms). Message: ${loadingStatusMessage}`);
      if (loadingStatusMessage !== TRANSITION_MESSAGE) {
          setLoadingStatusMessage(TRANSITION_MESSAGE, true); 
      }
      if (fadeOutCompletionTimeoutRef.current) clearTimeout(fadeOutCompletionTimeoutRef.current);

      fadeOutCompletionTimeoutRef.current = setTimeout(() => {
        if (isMountedRef.current && renderState === 'fading_out') {
          logAction(`FADING_OUT: Visual fade-out duration (${CANVAS_FADE_DURATION}ms) complete. -> APPLYING_CONFIG.`);
          if (!ANIMATION_CONTINUE_DURING_TRANSITION) {
            if (animationStateRef.current !== 'stopped') {
                if (stopAllAnimations) stopAllAnimations();
                animationStateRef.current = 'stopped';
            }
          } else {
            if (animationStateRef.current === 'stopped_for_transition' || animationStateRef.current === 'running') {
                animationStateRef.current = 'running_during_transition';
            }
          }
          setLoadingStatusMessage(APPLYING_CONFIG_MESSAGE, true); 
          logStateChange('applying_config', 'Fade Out Complete');
        }
      }, CANVAS_FADE_DURATION);
      return () => { if (fadeOutCompletionTimeoutRef.current) clearTimeout(fadeOutCompletionTimeoutRef.current); };
  }, [renderState, stopAllAnimations, logAction, logStateChange, setLoadingStatusMessage, loadingStatusMessage]);

  // Effect for 'applying_config' state
  useEffect(() => {
    if (renderState !== 'applying_config') {
      if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current);
      applyConfigPromiseRef.current = null;
      return;
    }
    if (applyConfigPromiseRef.current) {
      logAction(`APPLYING_CONFIG: Application process already in progress for nonce ${configLoadNonce}. Skipping.`);
      return;
    }

    logAction(`APPLYING_CONFIG: Starting configuration application process for nonce ${configLoadNonce}.`);
    if (loadingStatusMessage !== APPLYING_CONFIG_MESSAGE) {
        setLoadingStatusMessage(APPLYING_CONFIG_MESSAGE, true); 
    }

    const configsToApply = targetLayerConfigsForPreset || fallbackConfig.layers;
    const tokensToApply = targetTokenAssignmentsForPreset || fallbackConfig.tokenAssignments;
    const nonceForThisCycle = configLoadNonce;

    const applyAndDrawLogic = async () => {
        if (!isMountedRef.current || renderState !== 'applying_config') {
            logAction(`APPLYING_CONFIG: Aborted applyAndDrawLogic (unmounted or state changed).`);
            applyConfigPromiseRef.current = null; return;
        }
        let configApplySuccess = true, tokenApplySuccess = true, redrawSuccess = false;
        try {
            logAction(`APPLYING_CONFIG: Applying visual configs for nonce ${nonceForThisCycle}.`);
            if (applyConfigurationsToManagers) applyConfigurationsToManagers(configsToApply);

            logAction(`APPLYING_CONFIG: Applying token assignments for nonce ${nonceForThisCycle}.`);
            if (applyTokenAssignments) await applyTokenAssignments(tokensToApply);

            await new Promise(resolve => {
                if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current);
                repaintDelayTimeoutRef.current = setTimeout(resolve, FORCE_REPAINT_DELAY);
            });
            if (!isMountedRef.current || renderState !== 'applying_config') {
                logAction(`APPLYING_CONFIG: Aborted after repaint delay (unmounted or state changed).`);
                applyConfigPromiseRef.current = null; return;
            }
            repaintDelayTimeoutRef.current = null;

            logAction(`APPLYING_CONFIG: Redrawing all canvases with new config for nonce ${nonceForThisCycle}.`);
            if (redrawAllCanvases) redrawSuccess = await redrawAllCanvases(configsToApply);
            else redrawSuccess = true;

            if (!redrawSuccess) throw new Error("Redraw after config/token application failed.");

        } catch (error) {
            logAction(`APPLYING_CONFIG: Error during apply/redraw: ${error.message}`);
            if (import.meta.env.DEV) console.error(error);
            setLoadingStatusMessage(`⚠ Error applying config: ${error.message}`, true);
            configApplySuccess = false; redrawSuccess = false;
        } finally {
            applyConfigPromiseRef.current = null;
            if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current);
        }

        if (isMountedRef.current && renderState === 'applying_config') {
            if (configApplySuccess && tokenApplySuccess && redrawSuccess) {
                logAction(`APPLYING_CONFIG: Apply & Redraw SUCCESS (Nonce ${nonceForThisCycle}). -> RENDERED.`);
                // setMakeIncomingCanvasVisible(true); // Moved to 'rendered' state effect
                if (animationStateRef.current !== 'running') {
                    if (restartCanvasAnimations) restartCanvasAnimations();
                    animationStateRef.current = 'running';
                }
                logStateChange('rendered', 'Apply Success'); 
                lastAppliedNonceRef.current = nonceForThisCycle;
            } else {
                logAction(`APPLYING_CONFIG: Apply or Redraw FAILED. -> ERROR.`);
                logStateChange('error', 'Apply/Redraw Failed');
                setIsTransitioningInternal(false);
                setMakeIncomingCanvasVisible(false);
                animationStateRef.current = 'stopped';
                if (stopAllAnimations) stopAllAnimations();
            }
        }
    };
    applyConfigPromiseRef.current = applyAndDrawLogic();
    return () => { if (repaintDelayTimeoutRef.current) clearTimeout(repaintDelayTimeoutRef.current); };
  }, [
      renderState, configLoadNonce, targetLayerConfigsForPreset, targetTokenAssignmentsForPreset,
      applyConfigurationsToManagers, applyTokenAssignments, redrawAllCanvases, restartCanvasAnimations,
      setLoadingStatusMessage, logStateChange, logAction, stopAllAnimations, loadingStatusMessage
  ]);

  // Effect for 'rendered' state
  useEffect(() => {
    if (transitionEndTimeoutRef.current) clearTimeout(transitionEndTimeoutRef.current);

    if (renderState === "rendered") {
      setMakeIncomingCanvasVisible(true); // Make visuals appear as soon as 'rendered' state is hit
      
      setLoadingStatusMessage("Render complete"); 
      setIsStatusFadingOut(true); 

      if (isTransitioningInternal) {
        logAction(`RENDERED: Transition was active. Waiting ${CANVAS_FADE_DURATION}ms for incoming canvas fade-in to visually complete.`);
        transitionEndTimeoutRef.current = setTimeout(() => {
          if (isMountedRef.current && renderState === "rendered") {
            logAction(`RENDERED: Incoming canvas visual fade-in duration complete. Clearing isTransitioningInternal.`);
            setIsTransitioningInternal(false);
            
            if (statusDisplayFadeTimeoutRef.current) clearTimeout(statusDisplayFadeTimeoutRef.current);
            statusDisplayFadeTimeoutRef.current = setTimeout(() => {
              if (isMountedRef.current) setIsStatusFadingOut(false);
            }, LOADING_FADE_DURATION);

            outgoingLayerIdsOnTransitionStartRef.current.forEach(layerId => {
                const newConfigForThisLayer = targetLayerConfigsForPreset?.[layerId];
                if (!newConfigForThisLayer || !newConfigForThisLayer.enabled) {
                    const manager = managerInstancesRef?.current?.[layerId];
                    if (manager && typeof manager.applyFullConfig === 'function') {
                        manager.applyFullConfig({ ...(manager.getDefaultConfig?.() || {}), enabled: false });
                    }
                }
            });
            outgoingLayerIdsOnTransitionStartRef.current.clear();
          }
        }, CANVAS_FADE_DURATION);
      } else { // Not transitioning, e.g., initial load completion
        if (statusDisplayFadeTimeoutRef.current) clearTimeout(statusDisplayFadeTimeoutRef.current);
        statusDisplayFadeTimeoutRef.current = setTimeout(() => {
          if (isMountedRef.current) setIsStatusFadingOut(false);
        }, LOADING_FADE_DURATION);
      }
      if (animationStateRef.current !== 'running' && isContainerObservedVisible) {
        logAction("RENDERED: Ensuring animations are running.");
        if (restartCanvasAnimations) restartCanvasAnimations();
        animationStateRef.current = 'running';
      }
    } else { 
      // If we move away from 'rendered', ensure makeIncomingCanvasVisible is false
      // unless we are in a state that explicitly manages it (like applying_config or fading_out)
      if (renderState !== 'applying_config' && renderState !== 'fading_out') {
        if (makeIncomingCanvasVisible) setMakeIncomingCanvasVisible(false);
      }

      if (renderState !== 'fading_out' && renderState !== 'applying_config') {
        if (isTransitioningInternal) setIsTransitioningInternal(false);
        if (animationStateRef.current === 'running') {
          logAction(`State changed from RENDERED to ${renderState}. Stopping animations.`);
          if (stopAllAnimations) stopAllAnimations();
          animationStateRef.current = 'stopped';
        }
      }
    }
    return () => {
      if (transitionEndTimeoutRef.current) clearTimeout(transitionEndTimeoutRef.current);
      if (statusDisplayFadeTimeoutRef.current) clearTimeout(statusDisplayFadeTimeoutRef.current);
    };
  }, [
      renderState, isTransitioningInternal, makeIncomingCanvasVisible, isContainerObservedVisible,
      setLoadingStatusMessage, restartCanvasAnimations, stopAllAnimations, logAction,
      managerInstancesRef, targetLayerConfigsForPreset, isStatusFadingOut, 
      setMakeIncomingCanvasVisible // Added setMakeIncomingCanvasVisible as a dependency
    ]);

  const showStatusDisplay = useMemo(() => {
    return renderState !== 'rendered' || isTransitioningInternal || isStatusFadingOut;
  }, [renderState, isTransitioningInternal, isStatusFadingOut]);

  const showRetryButton = useMemo(() => {
    return renderState === 'error' && !upInitializationError && !upFetchStateError && !(loadError && !isInitiallyResolved);
  }, [renderState, upInitializationError, upFetchStateError, loadError, isInitiallyResolved]);

  return useMemo(() => ({
    renderState,
    loadingStatusMessage,
    isStatusFadingOut,
    showStatusDisplay,
    showRetryButton,
    isTransitioning: isTransitioningInternal,
    outgoingLayerIdsOnTransitionStart: outgoingLayerIdsOnTransitionStartRef.current,
    makeIncomingCanvasVisible,
    isAnimating: animationStateRef.current === 'running' || animationStateRef.current === 'running_during_transition',
    handleManualRetry,
    resetLifecycle,
  }), [
    renderState, loadingStatusMessage, isStatusFadingOut, showStatusDisplay, showRetryButton,
    isTransitioningInternal, makeIncomingCanvasVisible, handleManualRetry, resetLifecycle
  ]);
}
```

---
### `src\hooks\useUIState.js`
```js
// src/hooks/useUIState.js
import { useState, useCallback, useMemo } from 'react';

import { usePanelManager } from './usePanelManager'; // Local hook

/**
 * @typedef {object} UIState
 * @property {boolean} isUiVisible - Whether the main UI elements (toolbars, panels) are visible.
 * @property {boolean} infoOverlayOpen - Whether the informational overlay is currently open.
 * @property {boolean} whitelistPanelOpen - Whether the whitelist management panel is currently open.
 * @property {string|null} activePanel - The identifier of the currently open side panel (e.g., 'controls', 'notifications'), or null if none are open. Managed by the integrated `usePanelManager`.
 * @property {string|null} animatingPanel - The identifier of the panel currently undergoing an open/close animation (e.g., 'controls', 'closing'), or null. Managed by the integrated `usePanelManager`.
 * @property {string} activeLayerTab - The identifier of the active layer control tab (e.g., 'tab1').
 * @property {() => void} toggleUiVisibility - Function to toggle the visibility of the main UI elements.
 * @property {() => void} toggleInfoOverlay - Function to toggle the visibility of the informational overlay.
 * @property {() => void} toggleWhitelistPanel - Function to toggle the visibility of the whitelist panel.
 * @property {(panelName: string) => void} openPanel - Function to open a specific side panel by its identifier. This is sourced from `usePanelManager`.
 * @property {() => void} closePanel - Function to close the currently active side panel. This is sourced from `usePanelManager`.
 * @property {(panelName: string) => void} toggleSidePanel - Function to toggle a specific side panel's visibility. This is sourced from `usePanelManager`.
 * @property {React.Dispatch<React.SetStateAction<string>>} setActiveLayerTab - Function to directly set the active layer control tab identifier.
 */

/**
 * Consolidates management of various UI states including overall UI visibility,
 * modal-like overlays (Info, Whitelist), side panel visibility and animations
 * (by integrating `usePanelManager`), and the currently selected layer tab for controls.
 *
 * @param {string} [initialLayerTab='tab1'] - The identifier for the layer tab that should be active initially.
 * @returns {UIState} An object containing the current UI state values and functions to modify them.
 */
export function useUIState(initialLayerTab = 'tab1') {
  const [isUiVisible, setIsUiVisible] = useState(true);
  const [infoOverlayOpen, setInfoOverlayOpen] = useState(false);
  const [whitelistPanelOpen, setWhitelistPanelOpen] = useState(false);
  const [activeLayerTab, setActiveLayerTab] = useState(initialLayerTab);

  // Integrate usePanelManager for side panel state and animations
  const {
    activePanel,
    animatingPanel,
    openPanel,    // Renamed from openPanelInternal for clarity
    closePanel,   // Renamed from closePanelInternal for clarity
    togglePanel: toggleSidePanel // Renamed to avoid conflict if a general togglePanel was added here
  } = usePanelManager(null); // Start with no active panel

  /** Toggles the visibility of the main UI elements. */
  const toggleUiVisibility = useCallback(() => {
    setIsUiVisible((prev) => !prev);
  }, []); // setIsUiVisible is stable

  /** Toggles the visibility of the informational overlay. */
  const toggleInfoOverlay = useCallback(() => {
    setInfoOverlayOpen((prev) => !prev);
  }, []); // setInfoOverlayOpen is stable

  /** Toggles the visibility of the whitelist panel. */
  const toggleWhitelistPanel = useCallback(() => {
    setWhitelistPanelOpen((prev) => !prev);
  }, []); // setWhitelistPanelOpen is stable

  return useMemo(() => ({
    isUiVisible,
    infoOverlayOpen,
    whitelistPanelOpen,
    activePanel,
    animatingPanel,
    activeLayerTab,
    toggleUiVisibility,
    toggleInfoOverlay,
    toggleWhitelistPanel,
    openPanel,
    closePanel,
    toggleSidePanel,
    setActiveLayerTab, // Direct state setter from useState
  }), [
    isUiVisible, infoOverlayOpen, whitelistPanelOpen,
    activePanel, animatingPanel, activeLayerTab,
    toggleUiVisibility, toggleInfoOverlay, toggleWhitelistPanel,
    openPanel, closePanel, toggleSidePanel, setActiveLayerTab
  ]);
}
```

---
### `src\hooks\useVisualEffects.js`
```js
// src/hooks/useVisualEffects.js
import { useRef, useCallback, useEffect, useState, useMemo } from "react";

import VisualEffectsProcessor from "../utils/VisualEffectsProcessor"; // Local utility

/**
 * @typedef {object} EffectConfig Base structure for defining a visual effect.
 * @property {string} type - The type identifier of the effect (e.g., 'color_overlay').
 * @property {string | number} layer - The target layer ID ('global', 1, 2, or 3).
 * @property {object} [config] - Effect-specific configuration options (e.g., color, duration).
 * @property {string} [effectId] - Optional unique ID; one will be generated by the processor if not provided.
 * @property {boolean} [isPersistent=false] - Flag indicating if the effect should persist (currently a placeholder, as persistence logic is primarily managed by the consumer of this hook or a higher-level state).
 * @property {boolean} [preserveAnimation=false] - Hint for whether background animations should be preserved when this effect is active.
 */

/**
 * @typedef {object} EffectControlObject Object returned by the VisualEffectsProcessor after applying an effect.
 * @property {string} effectId - The unique ID of the applied effect instance.
 * @property {string | number} layer - The target layer of the effect.
 * @property {() => void} clear - Function to manually stop and clean up this specific effect instance.
 */

/**
 * @typedef {object} VisualEffectsAPI Interface provided by the useVisualEffects hook.
 * @property {(effectConfig: EffectConfig) => Promise<string | null>} processEffect - Processes and applies a given effect configuration using the internal `VisualEffectsProcessor`. Returns the effect ID on success, null on failure.
 * @property {(eventType: string) => Promise<string | null>} createDefaultEffect - Creates and applies a default visual effect based on an event type string, using the internal `VisualEffectsProcessor`. Returns the effect ID on success, null on failure.
 * @property {(effectId: string) => void} clearPersistentEffect - Clears a specific effect by its ID using the internal `VisualEffectsProcessor`. Also removes it from the local `persistentEffects` state if present.
 * @property {() => void} clearAllTimedEffects - Clears all currently active effects managed by the internal `VisualEffectsProcessor`.
 * @property {Object.<string, EffectConfig>} persistentEffects - State holding configurations of effects that were marked as persistent when processed. This state is primarily for informational purposes or for consumers to manage re-application if needed, as the hook itself doesn't automatically re-apply them.
 */

/**
 * Initializes and manages a `VisualEffectsProcessor` instance to handle the
 * creation, application, and cleanup of visual effects (like color overlays)
 * triggered by events or actions within the application. It provides functions
 * to process specific effect configurations or generate default effects based on event types.
 *
 * @param {(layerId: string | number, key: string, value: any) => void} [updateLayerConfig] - Optional: A function passed down from a configuration context, potentially used by some effects to modify layer properties directly. Current effects may not heavily rely on this.
 * @returns {VisualEffectsAPI} An object containing functions to manage visual effects.
 */
export function useVisualEffects(updateLayerConfig) {
  /** @type {React.RefObject<VisualEffectsProcessor | null>} */
  const processorRef = useRef(null);
  // State to potentially track persistent effects in the future
  /** @type {[Object.<string, EffectConfig>, React.Dispatch<React.SetStateAction<Object.<string, EffectConfig>>>]} */
  const [persistentEffects, setPersistentEffects] = useState({});
  /** @type {React.RefObject<(layerId: string | number, key: string, value: any) => void | undefined>} */
  const updateLayerConfigRef = useRef(updateLayerConfig);

  // Keep the updateLayerConfig function reference up-to-date
  useEffect(() => {
    updateLayerConfigRef.current = updateLayerConfig;
  }, [updateLayerConfig]);

  // Initialize and clean up the VisualEffectsProcessor instance
  useEffect(() => {
    processorRef.current = new VisualEffectsProcessor();
    if (import.meta.env.DEV) {
      // console.log("[useVisualEffects] VisualEffectsProcessor Initialized.");
    }

    const processorInstance = processorRef.current; // Capture instance for cleanup closure

    return () => {
      if (import.meta.env.DEV) {
        // console.log("[useVisualEffects] Cleaning up VisualEffectsProcessor...");
      }
      // Ensure we use the instance captured at the time of effect setup for cleanup,
      // as processorRef.current might be nulled by another effect run if deps change rapidly.
      const processorToClean = processorInstance;
      if (processorToClean && typeof processorToClean.cancelAllEffects === "function") {
        if (import.meta.env.DEV) {
          // console.log("[useVisualEffects] Calling cancelAllEffects on processor.");
        }
        processorToClean.cancelAllEffects();
      } else if (import.meta.env.DEV) {
        // Keep warning for potential cleanup issues
        console.warn("[useVisualEffects] VisualEffectsProcessor instance or cancelAllEffects method not available during cleanup.");
      }
      processorRef.current = null; // Explicitly nullify on unmount
    };
  }, []);

  /** Processes and applies a specific visual effect configuration. */
  const processEffect = useCallback(async (effectConfig) => {
    const currentProcessor = processorRef.current;
    const currentUpdateFn = updateLayerConfigRef.current;

    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects processEffect] Processor not ready.");
      }
      return null;
    }

    if (!effectConfig || (!effectConfig.type && !effectConfig.effect) || !effectConfig.layer) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects processEffect] Invalid effect object:", effectConfig);
      }
      return null;
    }

    const type = effectConfig.type || effectConfig.effect; // 'effect' for backward compatibility
    const layerId = String(effectConfig.layer);
    const isPersistent = effectConfig.isPersistent === true;
    // Processor now generates ID internally if not provided
    const fullConfig = { ...effectConfig, type: type, layer: layerId, isPersistent };


    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects processEffect] Processing effect:`, fullConfig);
    }
    try {
      const controlObject = await currentProcessor.processEffect(fullConfig, currentUpdateFn);
      if (controlObject?.effectId && isPersistent) {
        if (import.meta.env.DEV) {
          // console.log(`[useVisualEffects processEffect] Registered persistent effect placeholder: ${controlObject.effectId}`);
        }
        // Update local state for persistent effects
        setPersistentEffects((prev) => ({ ...prev, [controlObject.effectId]: fullConfig }));
      }
      return controlObject?.effectId || null;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects processEffect] Error processing effect ${fullConfig.effectId || '(new)'}:`, error);
      }
      return null;
    }
  }, []); // updateLayerConfigRef is a ref, processorRef is a ref. Their .current changing doesn't re-memoize.

  /** Creates and applies a default visual effect based on an event type string. */
  const createDefaultEffect = useCallback(async (eventType) => {
    const currentProcessor = processorRef.current;
    const currentUpdateFn = updateLayerConfigRef.current;

    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects createDefaultEffect] Processor not ready.");
      }
      return null;
    }


    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects createDefaultEffect] Creating default effect for event: ${eventType}`);
    }
    try {
      // Assuming createDefaultEffect might also return a control object with an effectId
      const controlObject = await currentProcessor.createDefaultEffect(eventType, currentUpdateFn);
      // If default effects can be persistent, handle similar to processEffect
      // For now, assuming they are not typically marked persistent this way.
      return controlObject?.effectId || null;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects createDefaultEffect] Error creating default effect for ${eventType}:`, error);
        if (error instanceof TypeError && error.message.includes("is not a function")) {
          console.error(`[useVisualEffects createDefaultEffect] DETECTED 'is not a function' error. Processor state:`, currentProcessor);
        }
      }
      return null;
    }
  }, []); // updateLayerConfigRef is a ref, processorRef is a ref.

  /** Manually stops and cleans up a specific effect instance by its ID. */
  const clearPersistentEffect = useCallback((effectId) => {
    const currentProcessor = processorRef.current;
    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects clearPersistentEffect] Processor not ready.");
      }
      return;
    }
    if (!effectId) return;

    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects clearPersistentEffect] Clearing effect: ${effectId}`);
    }
    try {
      currentProcessor.cancelEffect(effectId);
      setPersistentEffects((prev) => {
        if (!prev[effectId]) return prev; // No change if effectId not in state
        const newState = { ...prev };
        delete newState[effectId];
        if (import.meta.env.DEV) {
          // console.log(`[useVisualEffects clearPersistentEffect] Persistent effect ${effectId} removed from state.`);
        }
        return newState;
      });
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects clearPersistentEffect] Error cancelling effect ${effectId}:`, error);
      }
    }
  }, []); // processorRef is a ref.

  /** Stops and cleans up ALL currently active effects managed by the processor. */
  const clearAllTimedEffects = useCallback(() => {
    const currentProcessor = processorRef.current;
    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects clearAllTimedEffects] Processor not ready.");
      }
      return;
    }

    if (import.meta.env.DEV) {
      // console.log("[useVisualEffects clearAllTimedEffects] Clearing ALL processor-managed effects.");
    }
    try {
      currentProcessor.cancelAllEffects();
      // Optionally clear the local persistentEffects state if all effects are being cleared
      // setPersistentEffects({});
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects clearAllTimedEffects] Error cancelling all effects:`, error);
      }
    }
  }, []); // processorRef is a ref.

  return useMemo(() => ({
    processEffect,
    createDefaultEffect,
    clearPersistentEffect,
    clearAllTimedEffects,
    persistentEffects,
  }), [
    processEffect, createDefaultEffect, clearPersistentEffect, clearAllTimedEffects,
    persistentEffects
  ]);
}
```

---
### `src\index.css`
```css
@import "./styles/variables.css";
@import "./styles/base.css";
@import "./styles/layout.css"; 
@import "./styles/components.css"; 
@import "./components/Toolbars/ToolbarStyles/TopRightControls.css";
@import "./components/MIDI/MIDIStyles/GlobalMIDIStatus.css";


#root {
  width: 100%;
  height: 100%;
}
```

---
### `src\main.jsx`
```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import { UpProvider } from "./context/UpProvider.jsx";
import { UserSessionProvider } from "./context/UserSessionContext.jsx";
import { ConfigProvider } from "./context/ConfigContext.jsx";
import { PresetManagementProvider } from "./context/PresetManagementContext.jsx"; // Import PresetManagementProvider
import { VisualConfigProvider } from "./context/VisualConfigContext.jsx";
import { MIDIProvider } from "./context/MIDIContext.jsx";
import { ToastProvider } from "./context/ToastContext.jsx";
import ErrorBoundary from "./components/ErrorBoundary.jsx";
import "./index.css";
import { initializeHostUPConnector } from "./context/UpServerProvider.js";

const isRunningInIframe = () => {
  try {
    return window.self !== window.top;
  } catch (_e) {
    return true;
  }
};

const inIframe = isRunningInIframe();

if (!inIframe) {
  console.log("[main.jsx] Running as host/top window, initializing Host UP Connector.");
  initializeHostUPConnector();
} else {
  console.log("[main.jsx] Running inside an iframe, skipping Host UP Connector initialization.");
}

// Updated Provider Tree Structure:
// 1. ErrorBoundary
// 2. UpProvider
// 3. UserSessionProvider
// 4. ConfigProvider (Provides ConfigService, global settings, hasPendingChanges)
// 5. PresetManagementProvider (Uses ConfigService. Manages preset state. Consumes ConfigContext)
// 6. VisualConfigProvider (Uses PresetManagementContext for loaded data, ConfigContext for pending changes. Consumes PresetManagementContext & ConfigContext)
// 7. MIDIProvider (Uses ConfigContext for saving global MIDI map)
// 8. ToastProvider
// 9. App
const AppTree = (
  <ErrorBoundary>
    <UpProvider>
      <UserSessionProvider>
        <ConfigProvider>
          <PresetManagementProvider>
            <VisualConfigProvider>
              <MIDIProvider>
                <ToastProvider>
                  <App />
                </ToastProvider>
              </MIDIProvider>
            </VisualConfigProvider>
          </PresetManagementProvider>
        </ConfigProvider>
      </UserSessionProvider>
    </UpProvider>
  </ErrorBoundary>
);

ReactDOM.createRoot(document.getElementById("root")).render(AppTree);

console.log("[main.jsx] React application rendered successfully.");
```

---
### `src\services\ConfigurationService.js`
```js
// src/services/ConfigurationService.js
import {
  hexToString, stringToHex, numberToHex,
  getAddress, slice, isAddress,
} from "viem";

import {
  RADAR_SAVED_CONFIG_LIST_KEY, RADAR_DEFAULT_CONFIG_NAME_KEY,
  RADAR_MIDI_MAP_KEY, RADAR_EVENT_REACTIONS_KEY,
  getNamedConfigMapKey, getRadarConfigListElementKey, IPFS_GATEWAY,
} from "../config/global-config";
import { resolveLsp4Metadata } from '../utils/erc725.js'; // Assuming this utility expects a ConfigurationService-like instance

import { ERC725YDataKeys } from '@lukso/lsp-smart-contracts';
import { Buffer } from 'buffer'; // Node.js Buffer for environments where it's not global

// Polyfill window.Buffer if it's not available (e.g., in some browser environments)
if (typeof window !== 'undefined' && typeof window.Buffer === 'undefined') {
  window.Buffer = Buffer;
}

const ERC725Y_ABI = [
  { inputs: [{ type: "bytes32", name: "dataKey" }], name: "getData", outputs: [{ type: "bytes", name: "dataValue" }], stateMutability: "view", type: "function" },
  { inputs: [{ type: "bytes32[]", name: "dataKeys" }], name: "getDataBatch", outputs: [{ type: "bytes[]", name: "dataValues" }], stateMutability: "view", type: "function" },
  { inputs: [{ type: "bytes32", name: "dataKey" }, { type: "bytes", name: "dataValue" }], name: "setData", outputs: [], stateMutability: "payable", type: "function" },
  { inputs: [{ type: "bytes32[]", name: "dataKeys" }, { type: "bytes[]", name: "dataValues" }], name: "setDataBatch", outputs: [], stateMutability: "payable", type: "function" },
  { name: "supportsInterface", inputs: [{ type: "bytes4", name: "interfaceId" }], outputs: [{ type: "bool" }], stateMutability: "view", type: "function" },
];

/**
 * Safely converts a hex string to a UTF-8 string.
 * Returns null if the hex is invalid, empty, or decoding fails.
 * @param {string | null | undefined} hex - The hex string to convert (e.g., "0x...").
 * @returns {string | null} The decoded UTF-8 string, or null on failure.
 */
export function hexToUtf8Safe(hex) {
  if (!hex || typeof hex !== "string" || !hex.startsWith("0x") || hex === "0x") return null;
  try { return hexToString(hex); }
  catch { return null; }
}

/**
 * Safely converts a hex string (bytes) to an integer.
 * Handles potential BigInt overflow by capping at Number.MAX_SAFE_INTEGER.
 * Returns 0 if the hex is invalid, empty, or conversion fails.
 * @param {string | null | undefined} hex - The hex string to convert (e.g., "0x...").
 * @returns {number} The converted integer, or 0 on failure/empty.
 */
export function hexBytesToIntegerSafe(hex) {
  if (!hex || typeof hex !== "string" || !hex.startsWith("0x") || hex === "0x") return 0;
  try {
    const bigIntValue = BigInt(hex);
    if (bigIntValue > BigInt(Number.MAX_SAFE_INTEGER)) {
      if (import.meta.env.DEV) {
        console.warn(`[hexBytesToIntegerSafe] Value ${hex} exceeds MAX_SAFE_INTEGER. Capping.`);
      }
      return Number.MAX_SAFE_INTEGER;
    }
    return Number(bigIntValue);
  } catch { return 0; }
}

/**
 * Safely gets a checksummed address.
 * Returns null if the address is not a string or invalid.
 * @param {string | null | undefined} address - The address string.
 * @returns {string | null} The checksummed address or null.
 */
function getChecksumAddressSafe(address) {
  if (typeof address !== 'string') return null;
  try { return getAddress(address.trim()); }
  catch { return null; }
}

/**
 * @typedef {object} ParsedVisualConfig
 * @property {string} name - Name of the configuration.
 * @property {number} ts - Timestamp of when the configuration was saved.
 * @property {object} layers - Layer configurations, keyed by layer ID. (Mapped from 'l')
 * @property {object} tokenAssignments - Token assignments, keyed by layer ID. (Mapped from 'tA')
 */

/**
 * @typedef {object} LoadedConfigurationData
 * @property {ParsedVisualConfig|null} config - The main visual configuration object. Null if not found or error.
 * @property {object} reactions - Global event reactions. Empty object if not found or error.
 * @property {object} midi - Global MIDI map. Empty object if not found or error.
 * @property {string|null} error - Error message if loading failed, null otherwise.
 */

/**
 * @typedef {object} SaveOperationResult
 * @property {boolean} success - True if the save operation (transaction submission) was successful.
 * @property {string|null} hash - The transaction hash if successful, null otherwise.
 */


/**
 * Service class for interacting with ERC725Y compatible smart contracts
 * to load and save application configurations (visual presets, reactions, MIDI maps)
 * stored on a Universal Profile.
 */
class ConfigurationService {
  /** @type {import('viem').WalletClient | null} */
  walletClient = null;
  /** @type {import('viem').PublicClient | null} */
  publicClient = null;
  /** @type {boolean} */
  readReady = false;
  /** @type {boolean} */
  writeReady = false;

  /**
   * Creates an instance of ConfigurationService.
   * @param {any} _provider - The underlying provider (e.g., from Ethers.js or Web3.js, currently unused directly but kept for historical reasons or future use).
   * @param {import('viem').WalletClient | null} walletClient - The Viem WalletClient for write operations.
   * @param {import('viem').PublicClient | null} publicClient - The Viem PublicClient for read operations.
   */
  constructor(_provider, walletClient, publicClient) {
    this.walletClient = walletClient;
    this.publicClient = publicClient;
    this.readReady = !!publicClient;
    this.writeReady = !!publicClient && !!walletClient?.account;
  }

  /**
   * Initializes or re-checks the readiness of the service.
   * @async
   * @returns {Promise<boolean>} True if the service is ready for read operations.
   */
  async initialize() {
    this.readReady = !!this.publicClient;
    this.writeReady = this.readReady && !!this.walletClient?.account;
    return this.readReady;
  }

  /**
   * Gets the address of the currently connected user via WalletClient.
   * @returns {string | null} The user's address, or null if not connected.
   */
  getUserAddress() {
    return this.walletClient?.account?.address ?? null;
  }

  /**
   * Checks and updates the service's readiness for read operations.
   * @returns {boolean} True if ready for reads, false otherwise.
   */
  checkReadyForRead() {
    this.readReady = !!this.publicClient;
    return this.readReady;
  }

  /**
   * Checks and updates the service's readiness for write operations.
   * @returns {boolean} True if ready for writes, false otherwise.
   */
  checkReadyForWrite() {
    this.readReady = !!this.publicClient; // Write readiness depends on read readiness
    this.writeReady = this.readReady && !!this.walletClient?.account;
    return this.writeReady;
  }

  /**
   * Loads a complete configuration set (visual preset, reactions, MIDI map) for a profile.
   * If `configNameToLoad` is null, it attempts to load the default configuration.
   * If `customKey` is provided, it loads the visual config from that specific key.
   * Always attempts to load global reactions and MIDI map.
   * @param {string | null} profileAddress - The address of the Universal Profile.
   * @param {string | null} [configNameToLoad=null] - The name of the visual preset to load.
   * @param {string | null} [customKey=null] - A specific ERC725Y data key to load the visual config from, bypassing name resolution.
   * @returns {Promise<LoadedConfigurationData>} The loaded configuration data.
   */
  async loadConfiguration(profileAddress = null, configNameToLoad = null, customKey = null) {
    const defaultResult = { config: null, reactions: {}, midi: {}, error: null };

    if (!this.checkReadyForRead()) {
      return { ...defaultResult, error: "Public client not ready for reading." };
    }

    const checksummedProfileAddr = getChecksumAddressSafe(profileAddress);
    if (!checksummedProfileAddr) {
      return { ...defaultResult, error: "Invalid profile address format" };
    }

    const logPrefix = `[CS loadConfiguration Addr:${checksummedProfileAddr.slice(0, 6)}]`;
    if (import.meta.env.DEV) {
        console.log(`${logPrefix} Starting load for Name:${configNameToLoad || (customKey ? 'CUSTOM KEY' : 'DEFAULT (or fallback)')}`);
    }

    try {
        let targetConfigKey = customKey;
        let configNameUsed = customKey ? "Custom Key" : configNameToLoad;
        let nameReadFromDefaultPointer = null;

        if (!targetConfigKey && !configNameToLoad) { // Attempt to load default
            let defaultNameBytes = null;
            try {
                defaultNameBytes = await this.loadDataFromKey(checksummedProfileAddr, RADAR_DEFAULT_CONFIG_NAME_KEY);
            } catch (e) {
                if (import.meta.env.DEV) {
                    console.warn(`${logPrefix} Error reading default pointer key: ${e.message}`);
                }
            }
            const nameFromPointer = hexToUtf8Safe(defaultNameBytes);
            if (nameFromPointer) {
                nameReadFromDefaultPointer = nameFromPointer;
                configNameUsed = nameFromPointer;
                targetConfigKey = getNamedConfigMapKey(nameFromPointer);
                if (import.meta.env.DEV) {
                    console.log(`${logPrefix} Found default pointer: '${nameFromPointer}', Target Key: ${targetConfigKey}`);
                }
            } else {
                if (import.meta.env.DEV) {
                    console.log(`${logPrefix} No default pointer found. Will attempt to load globals and return null for config.`);
                }
                configNameUsed = null;
                targetConfigKey = null;
            }
        } else if (!targetConfigKey && configNameToLoad) { // Load by specific name
            configNameUsed = configNameToLoad;
            targetConfigKey = getNamedConfigMapKey(configNameToLoad);
            if (import.meta.env.DEV) {
                console.log(`${logPrefix} Using provided name: '${configNameToLoad}', Target Key: ${targetConfigKey}`);
            }
        } else if (targetConfigKey && import.meta.env.DEV) { // Load by custom key
             console.log(`${logPrefix} Using custom key: ${targetConfigKey}`);
        }

        const dataKeysToFetch = [];
        const keyIndexMap = { config: -1, reactions: -1, midi: -1 };

        if (targetConfigKey) {
            keyIndexMap.config = dataKeysToFetch.push(targetConfigKey) - 1;
        }
        keyIndexMap.reactions = dataKeysToFetch.push(RADAR_EVENT_REACTIONS_KEY) - 1;
        keyIndexMap.midi = dataKeysToFetch.push(RADAR_MIDI_MAP_KEY) - 1;

        let dataValues = [];
        if (dataKeysToFetch.length > 0) {
            try {
                const batchResults = await this.loadData(checksummedProfileAddr, dataKeysToFetch);
                dataValues = dataKeysToFetch.map(key => batchResults[key]);
            } catch (batchReadError) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Error during batch read via loadData:`, batchReadError);
                }
                return { ...defaultResult, error: `Batch read failed: ${batchReadError.message}` };
            }
        } else {
             if (import.meta.env.DEV) {
                console.warn(`${logPrefix} No keys prepared for fetching (this is unexpected).`);
             }
             return defaultResult;
        }

        let parsedConfig = null;
        let parsedReactions = {};
        let parsedMidi = {};

        if (keyIndexMap.config !== -1) {
            const configHex = dataValues[keyIndexMap.config];
            if (configHex && configHex !== "0x") {
                const configJson = hexToUtf8Safe(configHex);
                if (configJson) {
                    try {
                        const tempParsed = JSON.parse(configJson);
                        if (import.meta.env.DEV) {
                            console.log(`${logPrefix} Raw parsed JSON for config:`, JSON.stringify(tempParsed).substring(0, 500) + "...");
                        }
                        if (tempParsed && typeof tempParsed === "object" && typeof tempParsed.l === 'object' && typeof tempParsed.tA === 'object') {
                            const finalConfigName = nameReadFromDefaultPointer || tempParsed.name || configNameUsed || "Unnamed Config";
                            // ** CRITICAL: Map 'l' to 'layers' and 'tA' to 'tokenAssignments' **
                            // This matches the structure your "old correct log" implies the rest of the app expects.
                            parsedConfig = {
                                name: String(finalConfigName),
                                ts: tempParsed.ts || 0,
                                layers: tempParsed.l,          // Map 'l' to 'layers'
                                tokenAssignments: tempParsed.tA // Map 'tA' to 'tokenAssignments'
                            };
                            if (import.meta.env.DEV) {
                                console.log(`${logPrefix} Successfully parsed and structured config: '${parsedConfig.name}'`);
                            }
                        } else if (import.meta.env.DEV) {
                            console.warn(`${logPrefix} Parsed config JSON missing 'l' or 'tA' keys, or not an object. Structure:`, tempParsed);
                        }
                    } catch (parseError) {
                        if (import.meta.env.DEV) {
                            console.error(`${logPrefix} Error parsing config JSON:`, parseError);
                        }
                    }
                } else if (import.meta.env.DEV) {
                    console.warn(`${logPrefix} Failed to decode config hex to string.`);
                }
            } else if (import.meta.env.DEV) {
                 console.log(`${logPrefix} No data found for config key ${targetConfigKey}. Config will be null.`);
            }
        } else if (import.meta.env.DEV) {
             console.log(`${logPrefix} No targetConfigKey was determined. Config will be null.`);
        }

        if (keyIndexMap.reactions !== -1) {
            const reactionsHex = dataValues[keyIndexMap.reactions];
             if (reactionsHex && reactionsHex !== "0x") {
                 const reactionsJson = hexToUtf8Safe(reactionsHex);
                 if (reactionsJson) {
                    try {
                        const tempParsed = JSON.parse(reactionsJson);
                        if (tempParsed && typeof tempParsed === "object") {
                            parsedReactions = tempParsed;
                        } else if (import.meta.env.DEV) { console.warn(`${logPrefix} Parsed reactions JSON is not an object.`); }
                    } catch (parseError) { if (import.meta.env.DEV) console.error(`${logPrefix} Error parsing reactions JSON:`, parseError); }
                } else if (import.meta.env.DEV) { console.warn(`${logPrefix} Failed to decode reactions hex.`); }
            }
        }

        if (keyIndexMap.midi !== -1) {
            const midiHex = dataValues[keyIndexMap.midi];
             if (midiHex && midiHex !== "0x") {
                 const midiJson = hexToUtf8Safe(midiHex);
                 if (midiJson) {
                    try {
                        const tempParsed = JSON.parse(midiJson);
                        if (tempParsed && typeof tempParsed === "object") {
                            parsedMidi = tempParsed;
                        } else if (import.meta.env.DEV) { console.warn(`${logPrefix} Parsed MIDI JSON is not an object.`); }
                    } catch (parseError) { if (import.meta.env.DEV) console.error(`${logPrefix} Error parsing MIDI JSON:`, parseError); }
                } else if (import.meta.env.DEV) { console.warn(`${logPrefix} Failed to decode MIDI hex.`); }
            }
        }

        if (import.meta.env.DEV) {
            console.log(`${logPrefix} Load complete. Returning: config name: ${parsedConfig?.name || 'null'}, reactions keys: ${Object.keys(parsedReactions).length}, midi keys: ${Object.keys(parsedMidi).length}`);
        }
        return { config: parsedConfig, reactions: parsedReactions, midi: parsedMidi, error: null };

    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Unexpected error in loadConfiguration:`, error);
        }
        return { ...defaultResult, error: error.message || "Unknown loading error" };
    }
  }

  /**
   * Saves configuration data to a profile.
   * Can save visual preset, reactions, and/or MIDI map based on flags.
   * @param {string} targetProfileAddress - The address of the Universal Profile to save to.
   * @param {object} saveData - Object containing the data to save. Expected to have `saveData.layers` and `saveData.tokenAssignments` if `includeVisuals` is true.
   * @param {string} configName - Name of the visual preset (required if `includeVisuals` is true and no `customKey`).
   * @param {boolean} [setAsDefault=false] - If true, sets this visual preset as the default.
   * @param {boolean} [includeVisuals=false] - If true, saves visual preset data.
   * @param {boolean} [includeReactions=false] - If true, saves event reactions data.
   * @param {boolean} [includeMidi=false] - If true, saves MIDI map data.
   * @param {string | null} [customKey=null] - A specific ERC725Y data key to save the visual config to, bypassing name-based list management.
   * @returns {Promise<SaveOperationResult>} Result of the save operation.
   * @throws {Error} If client not ready, invalid input, or transaction fails.
   */
  async saveConfiguration(targetProfileAddress, saveData, configName, setAsDefault = false, includeVisuals = false, includeReactions = false, includeMidi = false, customKey = null) {
    const logPrefix = `[CS saveConfiguration Addr:${targetProfileAddress?.slice(0, 6)}]`;

    if (!this.checkReadyForWrite()) throw new Error("Client not ready for writing.");
    const checksummedTargetAddr = getChecksumAddressSafe(targetProfileAddress);
    if (!checksummedTargetAddr) throw new Error("Invalid target profile address format.");
    if (!saveData || typeof saveData !== "object") throw new Error("Invalid saveData object.");
    if (includeVisuals && !configName?.trim() && !customKey) throw new Error("Configuration name required for visual presets.");
    if (!includeVisuals && !includeReactions && !includeMidi) {
      return { success: true, hash: null };
    }

    const userAddress = this.walletClient.account.address;
    if (userAddress?.toLowerCase() !== checksummedTargetAddr?.toLowerCase()) {
      throw new Error("Permission denied: Signer does not own the target profile.");
    }

    try {
        const dataKeys = [];
        const dataValues = [];
        const trimmedName = configName?.trim();

        if (includeVisuals) {
            if (!saveData.layers) throw new Error("'layers' data missing for visual save.");
            const configStorageKey = customKey || getNamedConfigMapKey(trimmedName);
            if (!configStorageKey) throw new Error("Could not determine storage key for visual config.");

            // Structure for on-chain storage uses 'l' and 'tA'
            const visualConfigToStore = {
                name: String(trimmedName),
                ts: Date.now(),
                l: saveData.layers, // Assumes saveData.layers is the correct structure
                tA: saveData.tokenAssignments || {} // Assumes saveData.tokenAssignments is correct
            };
            let visualConfigHex;
            try { visualConfigHex = stringToHex(JSON.stringify(visualConfigToStore)); }
            catch (stringifyError) { throw new Error(`Failed to prepare visual config data: ${stringifyError.message}`); }
            dataKeys.push(configStorageKey); dataValues.push(visualConfigHex);

            if (!customKey) {
                const currentList = await this.loadSavedConfigurations(checksummedTargetAddr);
                if (!currentList.includes(trimmedName)) {
                    const currentIndex = currentList.length;
                    dataKeys.push(getRadarConfigListElementKey(currentIndex)); dataValues.push(stringToHex(trimmedName));
                    dataKeys.push(RADAR_SAVED_CONFIG_LIST_KEY); dataValues.push(numberToHex(BigInt(currentIndex + 1), { size: 16 }));
                }
                if (setAsDefault) {
                    dataKeys.push(RADAR_DEFAULT_CONFIG_NAME_KEY); dataValues.push(stringToHex(trimmedName));
                }
            }
        }

        if (includeReactions) {
            if (saveData.reactions === undefined) throw new Error("'reactions' data missing for save.");
            let reactionsHex;
            try { reactionsHex = stringToHex(JSON.stringify(saveData.reactions || {})); }
            catch (stringifyError) { throw new Error(`Failed to prepare reactions data: ${stringifyError.message}`); }
            dataKeys.push(RADAR_EVENT_REACTIONS_KEY); dataValues.push(reactionsHex);
        }

        if (includeMidi) {
            if (saveData.midi === undefined) throw new Error("'midi' data missing for save.");
            let midiHex;
            try { midiHex = stringToHex(JSON.stringify(saveData.midi || {})); }
            catch (stringifyError) { throw new Error(`Failed to prepare MIDI map data: ${stringifyError.message}`); }
            dataKeys.push(RADAR_MIDI_MAP_KEY); dataValues.push(midiHex);
        }

        if (dataKeys.length === 0) return { success: true, hash: null };

        const isBatch = dataKeys.length > 1;
        const functionName = isBatch ? "setDataBatch" : "setData";
        const args = isBatch ? [dataKeys, dataValues] : [dataKeys[0], dataValues[0]];

        try {
            const hash = await this.walletClient.writeContract({
                address: checksummedTargetAddr, abi: ERC725Y_ABI, functionName, args, account: this.walletClient.account,
            });
            return { success: true, hash };
        } catch (writeError) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} ${functionName} FAILED:`, writeError);
            }
            const baseError = writeError.cause || writeError;
            const message = baseError?.shortMessage || writeError.message || "Unknown write error";
            throw new Error(`Transaction failed: ${message}`);
        }
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Error during saveConfiguration processing:`, error);
        }
        throw new Error(error.message || "Unexpected error during save process.");
    }
  }

  /**
   * Loads the list of saved visual preset names from a profile.
   * @param {string} profileAddress - The address of the Universal Profile.
   * @returns {Promise<string[]>} A list of saved configuration names. Returns empty array on error or if none found.
   */
  async loadSavedConfigurations(profileAddress) {
    const checksummedProfileAddr = getChecksumAddressSafe(profileAddress);
    if (!this.checkReadyForRead() || !checksummedProfileAddr) {
      if (import.meta.env.DEV) {
        console.warn("[CS loadSavedList] Aborted: Client not ready or invalid address.");
      }
      return [];
    }
    const logPrefix = `[CS loadSavedList Addr:${checksummedProfileAddr.slice(0, 6)}]`;
    try {
        let lengthBytes;
        try {
            lengthBytes = await this.loadDataFromKey(checksummedProfileAddr, RADAR_SAVED_CONFIG_LIST_KEY);
        } catch (readError) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Error reading list length:`, readError.message);
            }
            return [];
        }

        if (lengthBytes === null) {
            return [];
        }

        const count = hexBytesToIntegerSafe(lengthBytes);
        if (count <= 0) return [];

        const elementKeys = Array.from({ length: count }, (_, i) => getRadarConfigListElementKey(i));
        let nameValuesBytes = [];
        try {
            const batchResults = await this.loadData(checksummedProfileAddr, elementKeys);
            nameValuesBytes = elementKeys.map(key => batchResults[key]);
        } catch (batchReadError) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Error reading list elements:`, batchReadError);
            }
            return [];
        }

        const names = nameValuesBytes
            .map((hex, i) => {
                const name = hexToUtf8Safe(hex);
                if ((name === null || name.trim() === "") && import.meta.env.DEV) {
                    console.warn(`${logPrefix} Found null or empty name at index ${i}. Key: ${elementKeys[i]}`);
                }
                return name;
            })
            .filter(name => name !== null && name.trim() !== "");
        return names;
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Unexpected error loading list:`, error);
        }
        return [];
    }
  }

  /**
   * Deletes a named visual preset from a profile.
   * @param {string} targetProfileAddress - The address of the Universal Profile.
   * @param {string} configNameToDelete - The name of the configuration to delete.
   * @returns {Promise<SaveOperationResult>} Result of the delete operation.
   * @throws {Error} If client not ready, invalid input, or transaction fails.
   */
  async deleteConfiguration(targetProfileAddress, configNameToDelete) {
    const logPrefix = `[CS deleteConfiguration Addr:${targetProfileAddress?.slice(0, 6)} Name:${configNameToDelete}]`;
    if (!this.checkReadyForWrite()) throw new Error("Client not ready for writing.");
    const checksummedTargetAddr = getChecksumAddressSafe(targetProfileAddress);
    if (!checksummedTargetAddr) throw new Error("Invalid target profile address format.");
    if (!configNameToDelete?.trim()) throw new Error("Valid config name to delete is required.");
    const trimmedNameToDelete = configNameToDelete.trim();

    const userAddress = this.walletClient.account.address;
    if (userAddress?.toLowerCase() !== checksummedTargetAddr?.toLowerCase()) {
      throw new Error("Permission denied: Signer does not own the target profile.");
    }

    try {
        const dataKeysToUpdate = [];
        const dataValuesToUpdate = [];

        dataKeysToUpdate.push(getNamedConfigMapKey(trimmedNameToDelete));
        dataValuesToUpdate.push("0x");

        const currentList = await this.loadSavedConfigurations(checksummedTargetAddr);
        const deleteIndex = currentList.findIndex((name) => name === trimmedNameToDelete);

        if (deleteIndex !== -1) {
            const lastIndex = currentList.length - 1;
            if (deleteIndex < lastIndex) {
                dataKeysToUpdate.push(getRadarConfigListElementKey(deleteIndex));
                dataValuesToUpdate.push(stringToHex(currentList[lastIndex]));
            }
            dataKeysToUpdate.push(getRadarConfigListElementKey(lastIndex)); dataValuesToUpdate.push("0x");
            const newLength = BigInt(currentList.length - 1);
            dataKeysToUpdate.push(RADAR_SAVED_CONFIG_LIST_KEY);
            dataValuesToUpdate.push(numberToHex(newLength >= 0 ? newLength : 0, { size: 16 }));
        }

        let defaultNameBytes = null;
        try { defaultNameBytes = await this.loadDataFromKey(checksummedTargetAddr, RADAR_DEFAULT_CONFIG_NAME_KEY); } catch { /* Ignore */ }
        if (defaultNameBytes && hexToUtf8Safe(defaultNameBytes) === trimmedNameToDelete) {
            dataKeysToUpdate.push(RADAR_DEFAULT_CONFIG_NAME_KEY); dataValuesToUpdate.push("0x");
        }

        if (dataKeysToUpdate.length === 0) return { success: true, hash: null };

        try {
            const hash = await this.walletClient.writeContract({ address: checksummedTargetAddr, abi: ERC725Y_ABI, functionName: "setDataBatch", args: [dataKeysToUpdate, dataValuesToUpdate], account: this.walletClient.account });
            return { success: true, hash };
        } catch (writeError) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Delete (setDataBatch) FAILED:`, writeError);
            }
            const baseError = writeError.cause || writeError;
            const message = baseError?.shortMessage || writeError.message || "Unknown delete error";
            throw new Error(`Deletion transaction failed: ${message}`);
        }
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Error deleting configuration:`, error);
        }
        throw new Error(error.message || `Unexpected error during deletion.`);
    }
  }

  /**
   * Saves a single hex value to a specific data key on a profile.
   * @param {string} targetAddress - The address of the Universal Profile.
   * @param {string} key - The ERC725Y data key (bytes32 hex string).
   * @param {string} valueHex - The hex string value to save. Use "0x" to clear.
   * @returns {Promise<SaveOperationResult>} Result of the save operation.
   * @throws {Error} If client not ready, invalid input, or transaction fails.
   */
  async saveDataToKey(targetAddress, key, valueHex) {
    const logPrefix = `[CS saveDataToKey Addr:${targetAddress?.slice(0, 6) ?? 'N/A'} Key:${key?.slice(0, 15) ?? 'N/A'}...]`;
    if (!this.checkReadyForWrite()) throw new Error("Client not ready for writing.");
    const checksummedTargetAddr = getChecksumAddressSafe(targetAddress);
    if (!checksummedTargetAddr) throw new Error("Invalid target address format.");

    const userAddress = this.walletClient.account.address;
    if (userAddress?.toLowerCase() !== checksummedTargetAddr?.toLowerCase()) {
       throw new Error("Permission denied: Signer does not own the target profile.");
    }

    if (!key || typeof key !== "string" || !key.startsWith("0x") || key.length !== 66) { throw new Error("Data key must be a valid bytes32 hex string."); }
    const finalValueHex = (valueHex === undefined || valueHex === null) ? "0x" : valueHex;
    if (typeof finalValueHex !== "string" || !finalValueHex.startsWith("0x")) { throw new Error("Value must be a valid hex string (0x...)."); }

    try {
        const hash = await this.walletClient.writeContract({ address: checksummedTargetAddr, abi: ERC725Y_ABI, functionName: "setData", args: [key, finalValueHex], account: this.walletClient.account });
        return { success: true, hash };
    } catch (writeError) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} setData FAILED:`, writeError);
        }
        const baseError = writeError.cause || writeError;
        const message = baseError?.shortMessage || writeError.message || "Unknown setData error";
        throw new Error(`Set data transaction failed: ${message}`);
    }
  }

  /**
   * Loads a single hex value from a specific data key on a profile.
   * @param {string} address - The address of the Universal Profile.
   * @param {string} key - The ERC725Y data key (bytes32 hex string).
   * @returns {Promise<string | null>} The hex string value (could be "0x" for empty), or null if key not found, error, or invalid input.
   */
  async loadDataFromKey(address, key) {
    if (!this.checkReadyForRead()) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadDataFromKey] Public client not ready for read operations, returning null`);
      }
      return null;
    }

    const checksummedAddress = getChecksumAddressSafe(address);
    if (!checksummedAddress) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadDataFromKey] Invalid address format: ${address}`);
      }
      return null;
    }

    const isKeyValid = typeof key === "string" && key.startsWith("0x") && key.length === 66;
    if (!isKeyValid) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadDataFromKey] Invalid key format: ${key}`);
      }
      return null;
    }

    try {
        const dataValueBytes = await this.publicClient.readContract({
          address: checksummedAddress,
          abi: ERC725Y_ABI,
          functionName: "getData",
          args: [key]
        });
        if (dataValueBytes === undefined || dataValueBytes === null) {
            return null;
        }
        return dataValueBytes;
    } catch (e) {
        if (import.meta.env.DEV) {
            console.warn(`[CS loadDataFromKey] Error reading key ${key} for ${address.slice(0,6)}...: ${e.message}`);
        }
        return null;
    }
  }

  /**
   * Loads multiple hex values from a batch of data keys on a profile.
   * @param {string} profileAddress - The address of the Universal Profile.
   * @param {string[]} [dataKeys=[]] - An array of ERC725Y data keys (bytes32 hex strings).
   * @returns {Promise<Object.<string, string | null>>} An object mapping keys to their hex string values. Value is null if not found or error for that key. "0x" is a valid empty value.
   */
  async loadData(profileAddress, dataKeys = []) {
    const checksummedProfileAddr = getChecksumAddressSafe(profileAddress);
    if (!this.checkReadyForRead()) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadData] Public client not ready for read operations`);
      }
      return {};
    }

    if (!checksummedProfileAddr) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadData] Invalid address format: ${profileAddress}`);
      }
      return {};
    }

    if (!Array.isArray(dataKeys) || dataKeys.length === 0) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadData] No valid data keys provided`);
      }
      return {};
    }

    const validKeys = dataKeys.filter(key => typeof key === "string" && key.startsWith("0x") && key.length === 66);
    if (validKeys.length === 0) {
      if (import.meta.env.DEV) {
        console.warn(`[CS loadData] No valid keys in provided array`);
      }
      return {};
    }

    try {
      const dataValuesBytes = await this.publicClient.readContract({
        address: checksummedProfileAddr,
        abi: ERC725Y_ABI,
        functionName: "getDataBatch",
        args: [validKeys]
      });

      const results = {};
      validKeys.forEach((key, i) => {
        results[key] = (dataValuesBytes[i] === undefined || dataValuesBytes[i] === null) ? null : dataValuesBytes[i];
      });
      return results;
    } catch (e) {
      if (import.meta.env.DEV) {
        console.error(`[CS loadData] readContract (getDataBatch) FAILED for ${checksummedProfileAddr}:`, e.message);
      }
      const results = {};
      validKeys.forEach((key) => { results[key] = null; });
      return results;
    }
  }

  /**
   * Checks if a contract at a given address supports the ERC725Y interface.
   * @param {string} address - The contract address.
   * @returns {Promise<boolean>} True if ERC725Y is supported, false otherwise or on error.
   */
  async checkSupportsERC725Y(address) {
    const checksummedAddr = getChecksumAddressSafe(address);
    if (!this.checkReadyForRead() || !checksummedAddr) return false;
    try {
        return await this.publicClient.readContract({
            address: checksummedAddr,
            abi: ERC725Y_ABI,
            functionName: "supportsInterface",
            args: ["0x5a988c0f"]
        });
    }
    catch { return false; }
  }

  /**
   * Retrieves a list of owned asset addresses (LSP5ReceivedAssets) from a profile.
   * @param {string} profileAddress - The address of the Universal Profile.
   * @returns {Promise<string[]>} A list of checksummed asset addresses. Returns empty array on error or if none found.
   */
  async getOwnedAssetAddresses(profileAddress) {
    const logPrefix = `[CS getOwnedAssetAddresses Addr:${profileAddress?.slice(0, 6) ?? 'N/A'}]`;
    const checksummedProfileAddr = getChecksumAddressSafe(profileAddress);
    if (!this.checkReadyForRead() || !checksummedProfileAddr) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Client not ready or invalid address.`);
        }
        return [];
    }
    const lsp5ArrayLengthKey = ERC725YDataKeys.LSP5['LSP5ReceivedAssets[]'].length;
    const lsp5BaseIndexKey = ERC725YDataKeys.LSP5['LSP5ReceivedAssets[]'].index;
    try {
        const lengthDataMap = await this.loadData(checksummedProfileAddr, [lsp5ArrayLengthKey]);
        const arrayLengthHex = lengthDataMap?.[lsp5ArrayLengthKey];
        const arrayLength = hexBytesToIntegerSafe(arrayLengthHex);

        if (arrayLength === 0) return [];

        const elementKeys = Array.from({ length: arrayLength }, (_, i) => {
            return lsp5BaseIndexKey + numberToHex(BigInt(i), { size: 16 }).slice(2);
        });

        const elementDataMap = await this.loadData(checksummedProfileAddr, elementKeys);
        const addresses = elementKeys
            .map(key => elementDataMap[key])
            .filter(data => data && data !== '0x')
            .map(data => {
                try {
                    return getAddress(slice(data, 0, 20));
                } catch { return null; }
            })
            .filter(address => address !== null);
        return addresses;
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Error fetching owned assets:`, error);
        }
        return [];
    }
  }

  /**
   * Applies token assignments to a set of canvas managers.
   * @param {Object.<string, any>} assignments - An object mapping layer IDs to assignment values.
   * @param {Object.<string, {setImage: (src: string) => Promise<void>}>} managers - Canvas managers, keyed by layer ID.
   * @param {Object.<string, string>} defaultLayerAssets - Default asset URLs for layers, keyed by layer ID.
   * @param {Object.<string, string>} demoAssetMap - A map of demo asset keys to their URLs.
   * @returns {Promise<void>} A promise that resolves when all image setting attempts are settled.
   */
  async applyTokenAssignmentsToManagers(assignments, managers, defaultLayerAssets, demoAssetMap) {
    const logPrefix = "[CS applyTokenAssignmentsToManagers]";
    if (!this.checkReadyForRead()) {
      if (import.meta.env.DEV) {
        console.warn(`${logPrefix} Aborted: Client not ready.`);
      }
      return;
    }
    if (!managers || !assignments || !defaultLayerAssets || !demoAssetMap) {
      if (import.meta.env.DEV) {
        console.warn(`${logPrefix} Aborted: Missing required arguments.`);
      }
      return;
    }

    const layerIdsToProcess = ['1', '2', '3'];
    const promises = layerIdsToProcess.map(async (layerId) => {
        const manager = managers[layerId];
        if (!manager) {
            if (import.meta.env.DEV) {
                console.warn(`${logPrefix} L${layerId}: No manager found.`);
            }
            return;
        }

        const assignmentValue = assignments[layerId];
        const defaultAssetSrc = defaultLayerAssets[layerId];
        let imageSourceToApply = defaultAssetSrc;

        try {
            if (typeof assignmentValue === 'string' && assignmentValue.startsWith("DEMO_LAYER_")) {
                const demoAssetSource = demoAssetMap[assignmentValue];
                if (demoAssetSource) { imageSourceToApply = demoAssetSource; }
                else if (import.meta.env.DEV) { console.warn(`${logPrefix} L${layerId}: Demo key '${assignmentValue}' not found in map.`); }
            } else if (typeof assignmentValue === 'object' && assignmentValue?.type === 'owned' && assignmentValue.iconUrl) {
                imageSourceToApply = assignmentValue.iconUrl;
            } else if (typeof assignmentValue === 'string' && isAddress(assignmentValue)) {
                try {
                    const metadata = await resolveLsp4Metadata(this, assignmentValue);
                    let resolvedImageUrl = null;
                    if (metadata?.LSP4Metadata) {
                        const meta = metadata.LSP4Metadata;
                        const url = meta.assets?.[0]?.url || meta.icon?.[0]?.url || meta.images?.[0]?.[0]?.url || null;
                        if (url && typeof url === 'string') {
                            const trimmedUrl = url.trim();
                            if (trimmedUrl.startsWith('ipfs://')) resolvedImageUrl = `${IPFS_GATEWAY}${trimmedUrl.slice(7)}`;
                            else if (trimmedUrl.startsWith('http') || trimmedUrl.startsWith('data:')) resolvedImageUrl = trimmedUrl;
                        }
                    }
                    if (resolvedImageUrl) { imageSourceToApply = resolvedImageUrl; }
                    else if (import.meta.env.DEV) { console.warn(`${logPrefix} L${layerId}: Could not resolve image URL from LSP4 metadata for ${assignmentValue}`); }
                } catch (error) {
                    if (import.meta.env.DEV) {
                        console.error(`${logPrefix} L${layerId}: Error resolving LSP4 for ${assignmentValue}:`, error);
                    }
                }
            } else if (typeof assignmentValue === 'string' && (assignmentValue.includes('/') || assignmentValue.startsWith('data:'))) {
                 imageSourceToApply = assignmentValue;
            } else if (assignmentValue === null || assignmentValue === undefined) {
                imageSourceToApply = defaultAssetSrc;
            } else if (assignmentValue && import.meta.env.DEV) {
                 console.warn(`${logPrefix} L${layerId}: Unhandled assignment type or value:`, assignmentValue);
            }

            if (manager.setImage && typeof manager.setImage === 'function') {
                if (imageSourceToApply) {
                    await manager.setImage(imageSourceToApply);
                } else if (import.meta.env.DEV) {
                    console.warn(`${logPrefix} L${layerId}: No image source to apply (neither from assignment nor default).`);
                }
            } else if (import.meta.env.DEV) {
                 console.warn(`${logPrefix} L${layerId}: manager.setImage is not available or not a function.`);
            }

        } catch (error) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} L${layerId}: ERROR processing assignment '${JSON.stringify(assignmentValue)}': `, error);
            }
            try {
                if (defaultAssetSrc && manager.setImage && typeof manager.setImage === 'function') {
                    if (import.meta.env.DEV) {
                        console.warn(`${logPrefix} L${layerId}: Reverting to default image due to error.`);
                    }
                    await manager.setImage(defaultAssetSrc);
                }
            }
            catch (revertError) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Failed to revert L${layerId} to default after error:`, revertError);
                }
            }
        }
    });
    await Promise.allSettled(promises);
  }
}

export default ConfigurationService;
```

---
### `src\services\LSP1EventService.jsx`
```jsx
// src/services/LSP1EventService.js
import {
  createPublicClient,
  webSocket,
  isAddress,
  decodeEventLog,
  // slice, // Intentionally removed as unused
  getAddress,
  decodeAbiParameters,
  parseAbiParameters,
} from "viem";
import { lukso } from "viem/chains";

import { EVENT_TYPE_MAP, TYPE_ID_TO_EVENT_MAP } from "../config/global-config";

// LSP1 ABI definition for UniversalReceiver event
const LSP1_ABI = [
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "uint256", name: "value", type: "uint256" },
      { indexed: true, internalType: "bytes32", name: "typeId", type: "bytes32" },
      { internalType: "bytes", name: "receivedData", type: "bytes" },
      { internalType: "bytes", name: "returnedValue", type: "bytes" },
    ],
    name: "UniversalReceiver",
    type: "event",
  },
];

// ABI parameter definitions for decoding specific event data payloads
const LSP7_RECEIVED_DATA_ABI = parseAbiParameters('address caller, address from, address to, uint256 amount, bytes data');
const LSP8_RECEIVED_DATA_ABI = parseAbiParameters('address caller, address from, address to, bytes32 tokenId, bytes data');

const DEFAULT_LUKSO_WSS_RPC_URL = "wss://ws-rpc.mainnet.lukso.network";
const WSS_RPC_URL = import.meta.env.VITE_LUKSO_WSS_RPC_URL || DEFAULT_LUKSO_WSS_RPC_URL;
const MAX_RECENT_EVENTS = 10; // For duplicate detection

/**
 * @typedef {object} DecodedLsp1EventArgs
 * @property {string} from - Address of the sender of the transaction.
 * @property {bigint} value - Value sent with the transaction (in Wei).
 * @property {string} typeId - Bytes32 type identifier of the received data.
 * @property {string} receivedData - Bytes data received by the Universal Profile.
 * @property {string} returnedValue - Bytes data returned by the Universal Profile.
 */

/**
 * @typedef {object} ProcessedLsp1Event
 * @property {string} id - Unique identifier for the processed event.
 * @property {number} timestamp - Timestamp when the event was processed.
 * @property {string} type - Human-readable event type name (e.g., 'lsp7_received', 'follower_gained').
 * @property {string} typeId - The original bytes32 typeId of the event.
 * @property {string} data - The raw `receivedData` from the event.
 * @property {string} sender - The actual sender address, potentially decoded from `receivedData`.
 * @property {string} value - The value from the event, converted to a string.
 * @property {boolean} read - Read status, defaults to false.
 * @property {object} decodedPayload - Additional decoded data, e.g., `followerAddress`.
 */


/**
 * Service class responsible for connecting to the LUKSO network via WebSocket,
 * listening for `UniversalReceiver` events on a specific profile address using
 * Viem's `watchContractEvent`, decoding the event arguments, and notifying
 * registered callbacks. Includes logic to decode sender addresses from LSP7/LSP8
 * `receivedData` and follower addresses from custom follower event data.
 * Also provides basic duplicate event detection and event simulation.
 */
class LSP1EventService {
  /** @type {Array<(event: ProcessedLsp1Event) => void>} */
  eventCallbacks = [];
  /** @type {import('viem').PublicClient | null} */
  viemClient = null;
  /** @type {(() => void) | null} Function returned by watchContractEvent to stop watching */
  unwatchEvent = null;
  /** @type {string | null} The address currently being listened to */
  listeningAddress = null;
  /** @type {boolean} */
  initialized = false;
  /** @type {boolean} Indicates if setupEventListeners is currently running */
  isSettingUp = false;
  /** @type {boolean} Flag indicating if the service *should* be connected (based on valid address) */
  shouldBeConnected = false;
  /** @type {string[]} Stores identifiers of recent events to prevent duplicates */
  recentEvents = [];

  constructor() {
    this.eventCallbacks = [];
    this.viemClient = null;
    this.unwatchEvent = null;
    this.listeningAddress = null;
    this.initialized = false;
    this.isSettingUp = false;
    this.shouldBeConnected = false;
    this.recentEvents = [];
  }

  /**
   * Initializes the service (currently just sets a flag).
   * @async
   * @returns {Promise<boolean>} True if initialized.
   */
  async initialize() {
    if (this.initialized) return true;
    this.initialized = true;
    return true;
  }

  /**
   * Sets up the Viem WebSocket client and starts watching for UniversalReceiver events
   * on the specified address. Cleans up any previous listeners first.
   * @param {string} address - The Universal Profile address to listen on.
   * @returns {Promise<boolean>} True if setup was successful, false otherwise.
   */
  async setupEventListeners(address) {
    const logPrefix = `[LSP1 viem setup Addr:${address?.slice(0, 6)}]`;
    if (this.isSettingUp) {
      if (import.meta.env.DEV) {
        console.warn(`${logPrefix} Setup already in progress. Aborting.`);
      }
      return false;
    }
    if (!address || !isAddress(address)) {
      if (import.meta.env.DEV) {
        console.warn(`${logPrefix} Invalid address provided. Aborting setup.`);
      }
      this.shouldBeConnected = false;
      return false;
    }

    // If already listening to the same address and watcher exists, consider it setup.
    if (this.listeningAddress?.toLowerCase() === address.toLowerCase() && this.unwatchEvent) {
      this.shouldBeConnected = true;
      return true;
    }

    this.isSettingUp = true;
    this.shouldBeConnected = true; // Assume connection will be successful until proven otherwise
    this.cleanupListeners(); // Clean up previous before setting up new
    this.listeningAddress = address;

    try {
      const client = createPublicClient({
        chain: lukso,
        transport: webSocket(WSS_RPC_URL, {
            // Optional: Add retry logic or other WebSocket options here if needed
            // e.g., retryCount: 5, retryDelay: 2000
        }),
      });
      this.viemClient = client;

      this.unwatchEvent = this.viemClient.watchContractEvent({
        address: this.listeningAddress, // Viem expects checksummed address or will checksum it
        abi: LSP1_ABI,
        eventName: "UniversalReceiver",
        onLogs: (logs) => {
          if (import.meta.env.DEV) {
            console.log(`%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%`);
            console.log(`%%% VIEM watchContractEvent RECEIVED ${logs.length} LOG(S)! %%%`);
            console.log(`%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%`);
          }
          logs.forEach((log) => {
            if (import.meta.env.DEV) {
                console.log(`--- Processing Log ---`);
                console.log(`  TX Hash: ${log.transactionHash}`);
                console.log(`  Block: ${log.blockNumber}`);
                console.log(`  Removed: ${log.removed}`);
                // console.log(`  Raw Data: ${log.data}`); // Usually very long
                // console.log(`  Raw Topics:`, log.topics);
            }

            if (log.removed) {
              if (import.meta.env.DEV) {
                console.warn(`${logPrefix} Log marked as removed (reorg), skipping processing.`);
              }
              return;
            }

            try {
              const decodedLog = decodeEventLog({ abi: LSP1_ABI, data: log.data, topics: log.topics });
              if (import.meta.env.DEV) {
                console.log(`  Decoded Event Name: ${decodedLog.eventName}`);
                // console.log(`  Decoded Args Object:`, decodedLog.args);
              }

              if (decodedLog.eventName === "UniversalReceiver" && decodedLog.args) {
                this.handleUniversalReceiver(/** @type {DecodedLsp1EventArgs} */ (decodedLog.args));
              } else if (import.meta.env.DEV) {
                console.warn(`${logPrefix} Decoded log name mismatch or args missing.`);
              }
            } catch (e) {
              if (import.meta.env.DEV) {
                console.error(`%%% Error decoding filter log:`, e);
              }
            }
            if (import.meta.env.DEV) {
                console.log(`--- End Log ---`);
            }
          });
        },
        onError: (error) => {
          if (import.meta.env.DEV) {
            console.error(`❌ [LSP1 viem watchContractEvent] Error on address ${this.listeningAddress}:`, error);
          }
          this.shouldBeConnected = false;
          // Consider attempting to re-establish listener after a delay, or notify higher level
        },
      });
      if (import.meta.env.DEV) {
        console.log(`${logPrefix} Successfully started watching events.`);
      }
      this.isSettingUp = false;
      return true;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`${logPrefix} Error during viem client creation or watch setup:`, error);
      }
      this.cleanupListeners(); // Ensure cleanup on error
      this.isSettingUp = false;
      this.shouldBeConnected = false;
      return false;
    }
  }

  /** Cleans up the Viem client and event listener. */
  cleanupListeners() {
    const logPrefix = "[LSP1 viem cleanup]";
    this.shouldBeConnected = false; // Mark as not intended to be connected
    this.isSettingUp = false; // Reset setup flag

    if (this.unwatchEvent) {
      try {
        this.unwatchEvent();
        if (import.meta.env.DEV) {
            // console.log(`${logPrefix} Called unwatch function.`);
        }
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Error calling unwatch function:`, e);
        }
      }
      this.unwatchEvent = null;
    }
    // Note: Viem's public client does not have an explicit close/disconnect for WebSocket transport.
    // It should be garbage collected when no longer referenced.
    this.viemClient = null;
    this.listeningAddress = null;
    this.recentEvents = []; // Clear recent events on cleanup
    if (import.meta.env.DEV) {
        // console.log(`${logPrefix} Listeners cleaned up.`);
    }
  }

  /**
   * Handles decoded UniversalReceiver event arguments, decodes additional data if necessary,
   * checks for duplicates, and notifies listeners.
   * @param {DecodedLsp1EventArgs} eventArgs - The decoded arguments from the UniversalReceiver event.
   */
  handleUniversalReceiver(eventArgs) {
    if (!eventArgs || typeof eventArgs !== "object" || !eventArgs.typeId) {
      if (import.meta.env.DEV) {
        console.warn("‼️ [LSP1 handleUniversalReceiver - viem] Invalid or incomplete args received:", eventArgs);
      }
      return;
    }
    const { from, value, typeId, receivedData, returnedValue } = eventArgs;
    const lowerCaseTypeId = typeId?.toLowerCase();

    if (!lowerCaseTypeId) {
      if (import.meta.env.DEV) {
        console.warn("‼️ [LSP1 handleUniversalReceiver - viem] Missing typeId in args:", eventArgs);
      }
      return;
    }

    const stringValue = value?.toString() ?? "0";
    const eventTypeName = TYPE_ID_TO_EVENT_MAP[lowerCaseTypeId] || "unknown_event";

    // --- ADD DEBUG LOGGING FOR FOLLOWER_GAINED ---
    if (eventTypeName === "follower_gained" && import.meta.env.DEV) {
        console.log("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
        console.log("DEBUG: Follower Gained Event Received by LSP1EventService");
        console.log("  eventArgs.from (caller of universalReceiver):", from);
        console.log("  eventArgs.value:", stringValue);
        console.log("  eventArgs.typeId:", typeId);
        console.log("  eventArgs.receivedData:", receivedData);
        console.log("  eventArgs.returnedValue:", returnedValue);
        console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
    }
    // --- END DEBUG LOGGING ---


    if (this.isDuplicateEvent(typeId, from, stringValue, receivedData)) {
      if (import.meta.env.DEV) {
        console.warn(`[LSP1 handleUniversalReceiver - viem] Duplicate event detected, ignoring: Type=${eventTypeName}`);
      }
      return;
    }
    if (import.meta.env.DEV) {
        console.log(`✅ [LSP1 handleUniversalReceiver - viem] Processing Unique Event: Type=${eventTypeName}, From=${from?.slice(0, 6)}, Value=${stringValue}, TypeId=${lowerCaseTypeId.slice(0, 8)}...`);
    }

    let actualSender = from || "0xUNKNOWN"; 
    let decodedPayload = {};

    if ((eventTypeName === "lsp7_received" || eventTypeName === "lsp8_received") && typeof receivedData === "string" && receivedData !== "0x") {
        const abiToUse = eventTypeName === "lsp7_received" ? LSP7_RECEIVED_DATA_ABI : LSP8_RECEIVED_DATA_ABI;
        try {
            const decodedDataArray = decodeAbiParameters(abiToUse, receivedData);
            if (decodedDataArray && decodedDataArray.length > 1 && typeof decodedDataArray[1] === 'string' && isAddress(decodedDataArray[1])) {
                actualSender = getAddress(decodedDataArray[1]); 
                if (import.meta.env.DEV) {
                    console.log(`   Decoded actual sender from receivedData (${eventTypeName}): ${actualSender}`);
                }
            } else if (import.meta.env.DEV) {
                console.warn(`[LSP1 viem] Failed to decode sender from receivedData or decoded data invalid for ${eventTypeName}. Data: ${receivedData}`);
            }
        } catch (decodeError) {
            if (import.meta.env.DEV) {
                console.error(`[LSP1 viem] Error decoding receivedData for ${eventTypeName}:`, decodeError, `Data: ${receivedData}`);
            }
        }
    }

    // --- REVISED FOLLOWER ADDRESS EXTRACTION for LSP26 ---
    if ((eventTypeName === "follower_gained" || eventTypeName === "follower_lost")) {
        let potentialFollowerAddr = null;
        const logCtx = `[LSP1 ${eventTypeName}]`;

        if (import.meta.env.DEV) {
            console.log(`${logCtx} Initial 'from' (UR caller): ${from}, receivedData: ${receivedData}`);
        }

        // Priority 1: Check if receivedData is the follower address (as per LSP26 spec)
        if (typeof receivedData === "string" && receivedData.startsWith("0x")) {
            try {
                if (isAddress(receivedData)) { // isAddress checks length and format
                    potentialFollowerAddr = getAddress(receivedData);
                    if (import.meta.env.DEV) {
                        console.log(`${logCtx} Attempt 1: Follower address from receivedData: ${potentialFollowerAddr}`);
                    }
                }
            } catch { /* isAddress failed or getAddress failed - error ignored by ESLint due to _e */ }
        }

        // Priority 2 (Fallback): Check if 'from' (UR caller) is the follower address
        if (!potentialFollowerAddr && from && isAddress(from)) {
            const followerRegistryAddress = "0xf01103E5a9909Fc0DBe8166dA7085e0285daDDcA"; // From LSP26 spec
            if (from.toLowerCase() !== followerRegistryAddress.toLowerCase()) {
                potentialFollowerAddr = getAddress(from);
                if (import.meta.env.DEV) {
                    console.log(`${logCtx} Attempt 2: Follower address from 'from' field (UR caller): ${potentialFollowerAddr}`);
                }
            } else if (import.meta.env.DEV) {
                 console.log(`${logCtx} 'from' field is the Follower Registry. Not using it as follower address.`);
            }
        }
        
        if (potentialFollowerAddr) {
            decodedPayload.followerAddress = potentialFollowerAddr;
        } else if (import.meta.env.DEV) {
            console.warn(`${logCtx} Could not determine follower address from receivedData or 'from' field.`);
        }
    }
    // --- END REVISED FOLLOWER ADDRESS EXTRACTION for LSP26 ---


    const eventObj = {
      id: `event_${Date.now()}_${Math.random().toString(16).slice(2)}`,
      timestamp: Date.now(),
      type: eventTypeName, // Human-readable name from TYPE_ID_TO_EVENT_MAP
      typeId: lowerCaseTypeId, // The actual on-chain typeId, lowercased
      data: receivedData || "0x",
      sender: actualSender, 
      value: stringValue,
      read: false,
      decodedPayload: decodedPayload, 
    };
    this.notifyEventListeners(eventObj);
  }

  /**
   * Basic duplicate event detection based on recent event identifiers.
   * @param {string} typeId - The typeId of the event.
   * @param {string} from - The 'from' address of the event.
   * @param {string} value - The 'value' of the event.
   * @param {string} data - The 'receivedData' of the event.
   * @returns {boolean} True if the event is considered a duplicate, false otherwise.
   */
  isDuplicateEvent(typeId, from, value, data) {
    const eventIdentifier = `${typeId}-${from}-${value}-${data || "0x"}`;
    if (this.recentEvents.includes(eventIdentifier)) {
      return true;
    }
    this.recentEvents.push(eventIdentifier);
    if (this.recentEvents.length > MAX_RECENT_EVENTS) {
      this.recentEvents.shift(); // Keep the list bounded
    }
    return false;
  }

  /**
   * Registers a callback function to be executed when an event is received.
   * @param {(event: ProcessedLsp1Event) => void} callback - The function to register.
   * @returns {() => void} An unsubscribe function.
   */
  onEvent(callback) {
    if (typeof callback === "function") {
      if (!this.eventCallbacks.includes(callback)) {
        this.eventCallbacks.push(callback);
      } else if (import.meta.env.DEV) {
        console.warn("[LSP1 viem] Attempted duplicate event callback registration.");
      }
    } else if (import.meta.env.DEV) {
      console.error("[LSP1 viem] Invalid callback type passed to onEvent:", typeof callback);
    }
    return () => {
      this.eventCallbacks = this.eventCallbacks.filter((cb) => cb !== callback);
    };
  }

  /**
   * Notifies all registered listeners about a new event.
   * @param {ProcessedLsp1Event} event - The processed event object.
   */
  notifyEventListeners(event) {
    if (!event || !event.type) {
      if (import.meta.env.DEV) {
        console.error("[LSP1 viem notifyEventListeners] Attempted to notify with invalid event object:", event);
      }
      return;
    }
    if (this.eventCallbacks.length === 0 && import.meta.env.DEV) {
      console.warn(`[LSP1 viem] No listeners registered to notify about event type '${event.type}'.`);
      // return; // Allow to proceed even if no listeners, for consistency
    }
    if (import.meta.env.DEV) {
        console.log(`[LSP1 viem] Notifying ${this.eventCallbacks.length} listeners about event type '${event.type}'. Event ID: ${event.id}, TypeId: ${event.typeId}`);
    }
    // Iterate over a copy in case a callback modifies the array (e.g., unsubscribes)
    this.eventCallbacks.slice().forEach((callback) => {
      try {
        callback(event);
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`[LSP1 viem] Error executing callback for event type ${event.type} (ID: ${event.id}):`, e);
        }
      }
    });
  }

  /**
   * Simulates receiving an event for testing purposes.
   * @async
   * @param {string} eventType - The human-readable event type or typeId to simulate.
   * @returns {Promise<boolean>} True if simulation was processed, false on error.
   */
  async simulateEvent(eventType) {
    if (!eventType || typeof eventType !== "string") {
      if (import.meta.env.DEV) {
        console.error("[LSP1 Sim - viem] Invalid eventType:", eventType);
      }
      return false;
    }
    const normalizedEventType = eventType.toLowerCase().replace(/[-_\s]/g, "");

    let typeId;
    let readableName;

    // Try to find by human-readable name first
    const typeIdEntryByName = Object.entries(EVENT_TYPE_MAP).find(
      ([key]) => key.toLowerCase().replace(/[-_\s]/g, "") === normalizedEventType
    );

    if (typeIdEntryByName) {
      readableName = typeIdEntryByName[0];
      typeId = typeIdEntryByName[1];
    } else {
      // Try to find by typeId
      const typeIdEntryById = Object.entries(TYPE_ID_TO_EVENT_MAP).find(
        ([id]) => id.toLowerCase() === normalizedEventType // Assuming normalizedEventType could be a typeId
      );
      if (typeIdEntryById) {
        typeId = typeIdEntryById[0];
        readableName = typeIdEntryById[1];
      } else {
        if (import.meta.env.DEV) {
            console.error("[LSP1 Sim - viem] Unknown event type/ID:", eventType);
        }
        return false;
      }
    }

    const mockValue = readableName.includes("lyx") ? 1000000000000000000n : 0n; // 1 LYX or 0
    // For simulating follower gained, the 'from' address should be the Follower Registry
    const mockFromField = (readableName === "follower_gained" || readableName === "follower_lost")
        ? "0xf01103E5a9909Fc0DBe8166dA7085e0285daDDcA" // LSP26 Follower Registry
        : "0xSimulationSender0000000000000000000000"; // Placeholder for other events
    
    let mockReceivedData = "0x";
    if (readableName === "follower_gained" || readableName === "follower_lost") {
      const mockFollowerAddress = "0xd8dA6Bf26964AF9D7eed9e03e53415D37aA96045"; // Actual follower/unfollower
      mockReceivedData = mockFollowerAddress.toLowerCase(); // LSP26: receivedData is the follower's address
    }

    const simulatedArgs = {
      from: mockFromField, 
      value: mockValue,
      typeId: typeId,
      receivedData: mockReceivedData, 
      returnedValue: "0x", 
    };

    try {
      this.handleUniversalReceiver(simulatedArgs);
      return true;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[LSP1 Sim - viem] Error during handleUniversalReceiver call:`, error);
      }
      return false;
    }
  }
}

export default LSP1EventService;
```

---
### `src\services\TokenService.js`
```js
// src/services/TokenService.js
import { isAddress, hexToString, getAddress } from "viem"; // Removed unused: slice, decodeAbiParameters, parseAbiParameters
import { ERC725YDataKeys } from "@lukso/lsp-smart-contracts";

// LSP8 minimal ABI needed for token interactions
const LSP8_MINIMAL_ABI = [
  { inputs: [{ name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ name: "", type: "bool" }], stateMutability: "view", type: "function" },
  { inputs: [{ name: "tokenId", type: "bytes32" }], name: "tokenOwnerOf", outputs: [{ name: "", type: "address" }], stateMutability: "view", type: "function" },
  { inputs: [{ name: "tokenOwner", type: "address" }], name: "tokenIdsOf", outputs: [{ name: "", type: "bytes32[]" }], stateMutability: "view", type: "function" },
  { inputs: [{ name: "dataKey", type: "bytes32" }], name: "getData", outputs: [{ name: "dataValue", type: "bytes" }], stateMutability: "view", type: "function" },
  { inputs: [{ name: "dataKeys", type: "bytes32[]" }], name: "getDataBatch", outputs: [{ name: "dataValues", type: "bytes[]" }], stateMutability: "view", type: "function" },
  { inputs: [{ name: "tokenId", type: "bytes32" }, { name: "dataKey", type: "bytes32" }], name: "getDataForTokenId", outputs: [{ name: "data", type: "bytes" }], stateMutability: "view", type: "function" },
];

/**
 * Safely decodes hex to UTF-8 string, returning null on error.
 * @param {string | null | undefined} hex - The hex string to decode.
 * @returns {string | null} The decoded string or null.
 */
function hexToUtf8Safe(hex) {
  if (!hex || typeof hex !== "string" || !hex.startsWith("0x") || hex === "0x") return null;
  try { return hexToString(hex); }
  catch (e) {
    if (import.meta.env.DEV) {
        console.warn("[TS] Failed hexToString:", hex, e);
    }
    return null;
  }
}

/**
 * Safely parses bytes32 hex string to a number, returning NaN on error.
 * @param {string | null | undefined} tokenIdBytes32 - The bytes32 token ID.
 * @returns {number} The parsed number or NaN.
 */
function parseTokenIdNum(tokenIdBytes32) {
  if (!tokenIdBytes32 || typeof tokenIdBytes32 !== "string" || !tokenIdBytes32.startsWith("0x")) return NaN;
  try { return Number(BigInt(tokenIdBytes32)); }
  catch (e) {
    if (import.meta.env.DEV) {
        console.warn(`[TS] Could not parse tokenId ${tokenIdBytes32} as number:`, e);
    }
    return NaN;
  }
}

/**
 * @typedef {object} DecodedVerifiableUri
 * @property {string} url - The decoded URL.
 * @property {string|null} hashFunction - The hash function identifier (e.g., 'keccak256(utf8)'), or null.
 * @property {string|null} hash - The hash value, or null.
 */

/**
 * @typedef {object} TokenMetadata
 * @property {string} name - The name of the token.
 * @property {string} [description] - The description of the token.
 * @property {string|null} image - The resolved image URL for the token.
 * @property {any} [attributes] - Other attributes from the metadata.
 */


/**
 * Service class for interacting with LSP8 NFT collections.
 * Handles fetching owned token IDs and resolving token metadata (including images)
 * using a Viem Public Client. Includes internal caching for metadata.
 */
class TokenService {
  /** @type {import('viem').PublicClient | null} */
  publicClient = null;
  /** @type {string | null} */
  collectionAddress = null;
  /** @type {Map<string, TokenMetadata>} */
  metadataCache = new Map();
  /** @type {boolean} */
  initialized = false;
  /** @type {string} */
  ipfsGateway = "https://api.universalprofile.cloud/ipfs/"; // Default, can be overridden by env var

  /**
   * Creates an instance of TokenService.
   * @param {import('viem').PublicClient | null} publicClient - The Viem Public Client instance.
   * @param {string | null} collectionAddress - The address of the LSP8 collection contract.
   */
  constructor(publicClient, collectionAddress) {
    this.publicClient = publicClient;
    this.collectionAddress = collectionAddress ? (isAddress(collectionAddress) ? getAddress(collectionAddress) : null) : null;
    this.metadataCache = new Map();
    this.initialized = !!publicClient && !!this.collectionAddress;
    if (import.meta.env.VITE_IPFS_GATEWAY) {
        this.ipfsGateway = import.meta.env.VITE_IPFS_GATEWAY;
    }
  }

  /**
   * Initializes the service, checking for client and valid collection address.
   * @async
   * @returns {Promise<boolean>} True if ready, false otherwise.
   */
  async initialize() {
    this.initialized = !!this.publicClient;
    if (!this.collectionAddress || !isAddress(this.collectionAddress)) {
      if (import.meta.env.DEV) {
        console.error("TokenService: Invalid or missing collection address during initialization.");
      }
      this.initialized = false;
    }
    return this.initialized;
  }

  /**
   * Checks if the Viem Public Client is available and connected.
   * @async
   * @returns {Promise<boolean>} True if client is ready, false otherwise.
   */
  async checkClientReady() {
    if (!this.publicClient) {
      if (import.meta.env.DEV) {
        console.warn("TokenService: Public Client not available.");
      }
      return false;
    }
    try {
      const chainId = await this.publicClient.getChainId();
      return !!chainId; // Basic check to see if client can communicate
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("[TokenService] Error checking public client:", error);
      }
      return false;
    }
  }

  /**
   * Retrieves the token IDs owned by a specific user within this collection.
   * @param {string} userAddress - The address of the user.
   * @returns {Promise<string[]>} An array of bytes32 token IDs. Returns empty array on error or if none found.
   */
  async getOwnedTokenIds(userAddress) {
    if (!userAddress || !isAddress(userAddress)) {
      if (import.meta.env.DEV) {
        console.warn("[TS] getOwnedTokenIds: Invalid userAddress.");
      }
      return [];
    }
    if (!this.collectionAddress) { // Already checked for isAddress in constructor/initialize
      if (import.meta.env.DEV) {
        console.warn("[TS] getOwnedTokenIds: Invalid or uninitialized collectionAddress.");
      }
      return [];
    }
    if (!(await this.checkClientReady())) {
      if (import.meta.env.DEV) {
        console.warn("[TS] getOwnedTokenIds: Client not ready.");
      }
      return [];
    }

    try {
      const tokenIds = await this.publicClient.readContract({
        address: this.collectionAddress,
        abi: LSP8_MINIMAL_ABI,
        functionName: "tokenIdsOf",
        args: [getAddress(userAddress)], // Ensure checksummed
      });
      return Array.isArray(tokenIds) ? tokenIds : [];
    } catch (error) {
      if (import.meta.env.DEV) {
        if (error?.message?.includes("InvalidArgumentsError") || error?.message?.includes("call exception")) {
          console.warn(`[TS] Contract ${this.collectionAddress} likely doesn't support tokenIdsOf or address ${userAddress} has no tokens.`);
        } else {
          console.error("[TS] Error calling tokenIdsOf:", error);
        }
      }
      return [];
    }
  }

  /**
   * Decodes VerifiableURI bytes according to LSP2 specification.
   * @param {string} verifiableUriBytes - The hex string (0x...) representing the VerifiableURI.
   * @returns {DecodedVerifiableUri | null} Decoded data or null on failure.
   */
  decodeVerifiableUri(verifiableUriBytes) {
    if (!verifiableUriBytes || typeof verifiableUriBytes !== "string" || !verifiableUriBytes.startsWith("0x")) return null;

    if (verifiableUriBytes.startsWith("0x0000") && verifiableUriBytes.length >= (2 + 4 + 2 + 0 + 0) * 2) {
      try {
        const hexString = verifiableUriBytes.substring(2);
        const methodId = `0x${hexString.substring(4, 12)}`;
        const lengthHex = `0x${hexString.substring(12, 16)}`;
        const hashLengthBytes = parseInt(lengthHex, 16);

        if (isNaN(hashLengthBytes)) throw new Error("Invalid hash length bytes in VerifiableURI");

        const hashLengthChars = hashLengthBytes * 2;
        const hashStartOffsetChars = 16;
        const hashEndOffsetChars = hashStartOffsetChars + hashLengthChars;

        if (hexString.length < hashEndOffsetChars) throw new Error("Byte string too short for declared hash length");

        const hash = `0x${hexString.substring(hashStartOffsetChars, hashEndOffsetChars)}`;
        const uriHex = `0x${hexString.substring(hashEndOffsetChars)}`;
        const url = hexToUtf8Safe(uriHex);

        if (!url) throw new Error("Failed to decode URL part of VerifiableURI");

        let hashFunction = null;
        if (methodId === "0x6f357c6a") hashFunction = "keccak256(utf8)";
        else if (methodId === "0x8019f9b1") hashFunction = "keccak256(bytes)";

        return { url, hashFunction, hash };
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error("[TS] Error decoding VerifiableURI:", verifiableUriBytes, e);
        }
      }
    }

    const plainUrl = hexToUtf8Safe(verifiableUriBytes);
    if (plainUrl) {
      return { url: plainUrl, hashFunction: null, hash: null };
    }

    if (import.meta.env.DEV) {
        console.warn("[TS] Could not decode URI bytes as VerifiableURI or plain URL:", verifiableUriBytes);
    }
    return null;
  }

  /**
   * Fetches JSON data from a given URI (resolving IPFS URIs).
   * @param {string} uri - The URI (http, https, or ipfs) to fetch from.
   * @returns {Promise<object|null>} The parsed JSON object or null on error.
   * @async
   */
  async fetchJsonFromUri(uri) {
    if (!uri || typeof uri !== "string") return null;
    let fetchUrl = uri;

    if (uri.startsWith("ipfs://")) {
      fetchUrl = `${this.ipfsGateway.endsWith('/') ? this.ipfsGateway : this.ipfsGateway + '/'}${uri.slice(7)}`;
    } else if (!uri.startsWith("http")) {
      if (import.meta.env.DEV) {
        console.warn(`[TS] Skipping fetch for unknown scheme: ${uri}`);
      }
      return null;
    }

    try {
      const response = await fetch(fetchUrl);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status} fetching ${fetchUrl}`);
      }
      return await response.json();
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[TS] Fetch/Parse JSON Error from ${fetchUrl}:`, error);
      }
      return null;
    }
  }

  /**
   * Resolves an IPFS or HTTP URL string to a fetchable URL.
   * @param {string | null | undefined} url - The URL to resolve.
   * @returns {string | null} The fetchable URL or null.
   */
  resolveImageUrl(url) {
    if (!url || typeof url !== "string") return null;
    if (url.startsWith("ipfs://")) {
        return `${this.ipfsGateway.endsWith('/') ? this.ipfsGateway : this.ipfsGateway + '/'}${url.slice(7)}`;
    }
    if (url.startsWith("http")) return url;
    return null;
  }

  /**
   * Extracts the primary image URL from potentially nested LSP3/LSP4 metadata.
   * @param {object | null} metadata - The metadata object.
   * @returns {string | null} The resolved image URL or null.
   */
  getImageUrlFromMetadata(metadata) {
    if (!metadata || typeof metadata !== "object") return null;
    let imageUrl = null;

    imageUrl = this.resolveImageUrl(metadata.image);
    if (imageUrl) return imageUrl;

    if (metadata.LSP4Metadata) {
        imageUrl = this.resolveImageUrl(metadata.LSP4Metadata.images?.[0]?.[0]?.url);
        if (imageUrl) return imageUrl;
        imageUrl = this.resolveImageUrl(metadata.LSP4Metadata.icon?.[0]?.url);
        if (imageUrl) return imageUrl;
        imageUrl = this.resolveImageUrl(metadata.LSP4Metadata.assets?.[0]?.url);
        if (imageUrl) return imageUrl;
    }

    if (metadata.LSP3Profile) {
        imageUrl = this.resolveImageUrl(metadata.LSP3Profile.profileImage?.[0]?.url);
        if (imageUrl) return imageUrl;
        imageUrl = this.resolveImageUrl(metadata.LSP3Profile.backgroundImage?.[0]?.url);
        if (imageUrl) return imageUrl;
    }
    return null;
  }

  /**
   * Fetches, processes, and caches metadata for a specific token ID within the collection.
   * @param {string} tokenId - The bytes32 token ID.
   * @returns {Promise<TokenMetadata|null>} Processed metadata or a fallback object on error. Returns null for invalid input.
   * @async
   */
  async fetchTokenMetadata(tokenId) {
    if (!tokenId || typeof tokenId !== "string" || !tokenId.startsWith("0x") || !this.collectionAddress) {
        if(import.meta.env.DEV) console.warn("[TS fetchTokenMetadata] Invalid tokenId or uninitialized collectionAddress.");
        return null;
    }

    const cacheKey = `metadata_${this.collectionAddress}_${tokenId}`;
    if (this.metadataCache.has(cacheKey)) {
      return this.metadataCache.get(cacheKey) || null;
    }

    if (!(await this.checkClientReady())) {
      if (import.meta.env.DEV) {
        console.warn("[TS fetchTokenMetadata] Client not ready.");
      }
      return null;
    }

    const displayId = parseTokenIdNum(tokenId);
    const fallbackMeta = { name: `Token #${displayId || tokenId.slice(0, 8)}...`, description: "Metadata loading failed", image: null };

    try {
      const lsp4MetadataKey = ERC725YDataKeys.LSP4.LSP4Metadata;
      let metadataUriBytes = await this.publicClient.readContract({
          address: this.collectionAddress, abi: LSP8_MINIMAL_ABI, functionName: "getDataForTokenId", args: [tokenId, lsp4MetadataKey],
        }).catch(() => null);

      if (!metadataUriBytes || metadataUriBytes === "0x") {
        const baseUriKey = ERC725YDataKeys.LSP8.LSP8TokenMetadataBaseURI;
        metadataUriBytes = await this.publicClient.readContract({
            address: this.collectionAddress, abi: LSP8_MINIMAL_ABI, functionName: "getData", args: [baseUriKey],
          }).catch(() => null);
      }

      if (metadataUriBytes && metadataUriBytes !== "0x") {
        const decodedUriData = this.decodeVerifiableUri(metadataUriBytes);
        if (decodedUriData?.url) {
          let finalUrl = decodedUriData.url;
          const baseUriCheckBytes = await this.publicClient.readContract({
              address: this.collectionAddress, abi: LSP8_MINIMAL_ABI, functionName: "getData", args: [ERC725YDataKeys.LSP8.LSP8TokenMetadataBaseURI],
            }).catch(() => null);

          if (metadataUriBytes === baseUriCheckBytes && baseUriCheckBytes !== null) {
            const formattedTokenIdPart = parseTokenIdNum(tokenId).toString();
            if (!isNaN(Number(formattedTokenIdPart))) {
                finalUrl = finalUrl.endsWith("/") ? `${finalUrl}${formattedTokenIdPart}` : `${finalUrl}/${formattedTokenIdPart}`;
            } else if (import.meta.env.DEV) {
                console.warn(`[TS] Token ID ${tokenId} could not be parsed to a number for base URI construction. Using raw base URI: ${finalUrl}`);
            }
          }

          const metadataJson = await this.fetchJsonFromUri(finalUrl);
          if (metadataJson) {
            const processedMetadata = {
                name: metadataJson.name || fallbackMeta.name,
                description: metadataJson.description,
                image: this.getImageUrlFromMetadata(metadataJson),
                attributes: metadataJson.attributes,
            };
            this.metadataCache.set(cacheKey, processedMetadata);
            return processedMetadata;
          }
        }
      }

      if (import.meta.env.DEV) {
        console.warn(`[TS] No metadata URI resolved or fetched for ${tokenId} in collection ${this.collectionAddress}. Using fallback.`);
      }
      this.metadataCache.set(cacheKey, fallbackMeta);
      return fallbackMeta;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[TS] Critical error fetching metadata for ${tokenId} in ${this.collectionAddress}:`, error);
      }
      this.metadataCache.set(cacheKey, fallbackMeta);
      return fallbackMeta;
    }
  }

  /**
   * Loads a token's image into a specific CanvasManager instance.
   * @param {string} tokenId - The bytes32 token ID.
   * @param {import('../utils/CanvasManager').default} canvasManager - The target CanvasManager instance.
   * @returns {Promise<boolean>} True if image was successfully set (or attempted with a valid URL), false otherwise.
   * @async
   */
  async loadTokenIntoCanvas(tokenId, canvasManager) {
    if (!tokenId || !canvasManager?.setImage || typeof canvasManager.setImage !== 'function') {
      if (import.meta.env.DEV) {
        console.error("TokenService: Invalid parameters for loadTokenIntoCanvas.");
      }
      return false;
    }

    const displayId = parseTokenIdNum(tokenId);
    const placeholderUrl = `https://via.placeholder.com/600x400/444444/cccccc.png?text=Loading...+(${displayId || tokenId.slice(0, 6)})`;
    const errorPlaceholder = `https://via.placeholder.com/600x400/cc3333/ffffff.png?text=Load+Error+(${displayId || tokenId.slice(0, 6)})`;

    try {
      await canvasManager.setImage(placeholderUrl);
      const metadata = await this.fetchTokenMetadata(tokenId);
      const imageUrl = metadata?.image;

      if (!imageUrl || typeof imageUrl !== "string") {
        if (import.meta.env.DEV) {
            console.warn(`[TS] No valid image URL found in metadata for token ${tokenId}. Using error placeholder.`);
        }
        await canvasManager.setImage(errorPlaceholder);
        return false;
      }

      await canvasManager.setImage(imageUrl);
      return true;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[TS] Error loading token ${tokenId} into canvas:`, error);
      }
      try {
        await canvasManager.setImage(errorPlaceholder);
      } catch (fallbackError) {
        if (import.meta.env.DEV) {
            console.error("[TS] Failed to load error placeholder into canvas:", fallbackError);
        }
      }
      return false;
    }
  }

  /**
   * Applies multiple token assignments to their respective CanvasManager instances.
   * @param {Object.<string, string>} tokenAssignments - An object mapping layerId to tokenId (bytes32).
   * @param {Object.<string, import('../utils/CanvasManager').default>} canvasManagers - An object mapping layerId to CanvasManager instances.
   * @returns {Promise<Object.<string, {success: boolean, tokenId: string | null, error?: string}>>} An object detailing success/failure per layer.
   * @async
   */
  async applyTokenAssignments(tokenAssignments, canvasManagers) {
    /** @type {Object.<string, {success: boolean, tokenId: string | null, error?: string}>} */
    const results = {};
    if (!tokenAssignments || !canvasManagers) {
        if(import.meta.env.DEV) console.warn("[TS applyTokenAssignments] Missing tokenAssignments or canvasManagers.");
        return results;
    }
    if (!(await this.checkClientReady())) {
      if (import.meta.env.DEV) {
        console.warn("[TS applyTokenAssignments] Client not ready.");
      }
      Object.keys(tokenAssignments).forEach(layerId => {
        results[layerId] = { success: false, tokenId: tokenAssignments[layerId], error: "Client not ready" };
      });
      return results;
    }

    const promises = Object.entries(tokenAssignments).map(
      async ([layerId, tokenId]) => {
        results[layerId] = { success: false, tokenId: tokenId || null };
        if (!tokenId) {
          results[layerId].error = "No token ID provided for layer";
          return;
        }
        const manager = canvasManagers[layerId];
        if (!manager) {
          if (import.meta.env.DEV) {
            console.warn(`[TS applyTokenAssignments] No manager found for layer ${layerId}`);
          }
          results[layerId].error = "Canvas manager not found for layer";
          return;
        }
        try {
          const success = await this.loadTokenIntoCanvas(tokenId, manager);
          results[layerId].success = success;
          if (!success) {
            results[layerId].error = results[layerId].error || "Image load into canvas failed";
          }
        } catch (error) {
          if (import.meta.env.DEV) {
            console.error(`[TS applyTokenAssignments] Error applying token ${tokenId} to layer ${layerId}:`, error);
          }
          results[layerId].error = error.message || "Unknown error during token application";
        }
      },
    );

    await Promise.allSettled(promises);
    return results;
  }
}

export default TokenService;
```

---
### `src\setupTests.js`
```js
// src/setupTests.js
import '@testing-library/jest-dom'; // Extends expect with jest-dom matchers
```

---
### `src\styles\base.css`
```css
@import "./variables.css";

@font-face {
  font-family: "RadarFont";
  src: url("/RADAR.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}

/* Reset */
*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Base HTML & Body */
html,
body {
  font-family: var(--font-family);
  font-size: 16px;
  color: var(--color-text);
  /* Base height/width/bg set inline */
}

/* Base App Wrapper */
.app {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

/* Typography */
h1,
h2,
h3,
h4,
h5,
h6 {
  color: var(--color-primary);
  margin-bottom: var(--space-sm);
  font-weight: 500;
}

p {
  line-height: 1.5;
  margin-bottom: var(--space-md);
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--transition-fast);
}

a:hover {
  color: var(--color-primary-a70);
}

/* Common utility classes */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* Animations */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideInFromLeft { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
@keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
@keyframes pulse-ring { 0% { transform: scale(0.95); opacity: 0.7; } 50% { transform: scale(1.05); opacity: 0.3; } 100% { transform: scale(0.95); opacity: 0.7; } }
@keyframes pulse-core { 0% { transform: scale(1); opacity: 0.5; } 50% { transform: scale(1.05); opacity: 0.2; } 100% { transform: scale(1); opacity: 0.5; } }
@keyframes highlight-new { 0% { background: var(--color-primary-a30); transform: translateY(-5px); } 100% { background: var(--color-primary-a05); transform: translateY(0); } }
@keyframes bell-pulse { 0% { transform: scale(1); } 10% { transform: scale(1.1); } 20% { transform: scale(1); } 100% { transform: scale(1); } }
```

---
### `src\styles\components.css`
```css
@import "./variables.css";

/*---------- Buttons ----------*/
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-xs) var(--space-md);
  background: var(--color-primary-a15);
  color: var(--color-primary);
  border: 1px solid var(--color-primary-a30);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-md);
  font-weight: 500;
  text-transform: uppercase;
  cursor: pointer;
  transition: all var(--transition-normal);
}
.btn:hover:not(:disabled) {
  background: var(--color-primary-a30);
  border-color: var(--color-primary-a50);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}
.btn:active:not(:disabled) {
  transform: translateY(0);
}
.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.btn-sm {
  font-size: var(--font-size-sm);
  padding: var(--space-xxs) var(--space-xs);
}
.btn-block {
  width: 100%;
  display: block;
}
.btn-icon {
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  padding: 0;
  border-radius: var(--radius-circle);
}

/* Generic Close Button Style */
.close-button {
  background: none;
  border: none;
  color: var(--color-primary);
  font-size: var(--font-size-xl);
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
  padding: 0;
  margin: 0;
}
.close-button:hover {
  opacity: 0.8;
  transform: scale(1.1);
}

/*---------- Forms ----------*/
.form-group {
  margin-bottom: var(--space-md);
}
.form-group label {
  display: block;
  margin-bottom: var(--space-xs);
  font-size: var(--font-size-sm);
  color: var(--color-primary-a90);
  text-transform: uppercase;
}
.form-control {
  width: 100%;
  padding: var(--space-xs) var(--space-sm);
  background: var(--color-glass-bg);
  border: 1px solid var(--color-border);
  color: var(--color-text);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-md);
  transition: border-color var(--transition-fast);
}
.form-control:focus {
  outline: none;
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-sm);
}

/* Custom Select Dropdown */
.custom-select {
  width: 100%;
  padding: var(--space-xs) var(--space-md) var(--space-xs) var(--space-sm);
  background: var(--color-glass-bg);
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='6' viewBox='0 0 12 6' fill='none'%3E%3Cpath d='M6 6L0 0H12L6 6Z' fill='%2300f3ff'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 10px center;
  border: 1px solid var(--color-border);
  color: var(--color-primary);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-sm);
  cursor: pointer;
  appearance: none;
  -webkit-appearance: none; /* For Safari */
  -moz-appearance: none;    /* For Firefox */
}
.custom-select:hover {
  border-color: var(--color-primary-a30);
  background-color: var(--color-primary-a05);
}
.custom-select:focus {
  outline: none;
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-sm);
}

/* Sliders */
.slider-container {
  margin-bottom: var(--space-md);
}
.slider-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: var(--space-xs);
}
.slider-label {
  text-transform: uppercase;
  font-size: var(--font-size-sm);
  color: var(--color-primary-a90);
}
.slider-value {
  font-size: var(--font-size-sm);
  color: var(--color-primary-a90);
}
input[type="range"] {
  appearance: none;
  -webkit-appearance: none;
  width: 100%;
  height: 4px;
  background: var(--color-primary-a15);
  border-radius: 2px;
  outline: none;
  transition: background var(--transition-fast);
}
input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}
input[type="range"]::-moz-range-thumb { /* Styles for Firefox */
  width: 16px;
  height: 16px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  border: none; /* Remove default border */
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}
input[type="range"]:hover::-webkit-slider-thumb {
  transform: scale(1.2);
  box-shadow: 0 0 10px var(--color-primary-a30);
}
input[type="range"]:hover::-moz-range-thumb {
  transform: scale(1.2);
  box-shadow: 0 0 10px var(--color-primary-a30);
}
input[type="range"]:hover {
  background: var(--color-primary-a30);
}

/* Checkbox */
.checkbox-group {
  display: flex;
  align-items: center;
  gap: var(--space-xs);
}
.checkbox-group input[type="checkbox"] {
  width: 16px;
  height: 16px;
  accent-color: var(--color-primary);
}

/*---------- Panels ----------*/
.panel {
  background: var(--color-glass-bg);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  color: var(--color-text);
  box-shadow: var(--shadow-lg);
  overflow: hidden;
  width: var(--panel-width);
  max-height: 80vh;
  display: flex;
  flex-direction: column;
}
.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-sm) var(--space-md);
  background: rgba(16, 16, 24, 0.4); /* Semi-transparent header */
  border-bottom: 1px solid var(--color-border);
  flex-shrink: 0; /* Prevent header from shrinking */
}
.panel-title {
  font-size: var(--font-size-lg);
  text-transform: uppercase;
  margin: 0;
  letter-spacing: 0.5px;
  font-weight: 500;
  color: var(--color-primary);
}
.panel-content {
  padding: var(--space-md);
  overflow-y: auto;
  /* Removed max-height rule - let flex handle sizing */
  flex-grow: 1; /* Allow content to take remaining space */
}
.panel-from-toolbar {
  position: fixed;
  top: var(--space-lg);
  left: var(--panel-left-position);
  z-index: var(--z-controls);
  animation: slideInFromLeft var(--transition-normal) var(--transition-elastic);
}

/*---------- Toolbar ----------*/
.toolbar-icon {
  width: var(--icon-size-lg);
  height: var(--icon-size-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--color-primary-a05);
  border: 1px solid var(--color-border);
  overflow: visible; /* Allow potential badges/effects */
  position: relative;
}
.toolbar-icon:hover {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a30);
  transform: translateY(-2px);
  box-shadow: var(--shadow-primary-sm);
}
.toolbar-icon.active {
  background: var(--color-primary-a15);
  border-color: var(--color-primary-a50);
  box-shadow: var(--shadow-primary-md);
}
.toolbar-icon .icon-image {
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  transition: all var(--transition-fast);
  opacity: 1; /* Keep default opacity */
}
.toolbar-icon:hover .icon-image,
.toolbar-icon.active .icon-image {
  opacity: 1;
  filter: drop-shadow(0 0 5px var(--color-primary-a30));
}

/*---------- Notifications ----------*/
.notification-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  min-width: 16px;
  height: 16px;
  background: var(--color-error);
  color: white;
  border-radius: 8px;
  font-size: 10px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 3px;
  box-shadow: 0 0 5px var(--color-error-a50, rgba(255, 85, 85, 0.5));
  z-index: var(--z-base); 
}
.notification-item {
  padding: var(--space-sm);
  background: var(--color-primary-a05);
  border-radius: var(--radius-md);
  border-left: 3px solid var(--color-primary-a30);
  transition: all var(--transition-fast);
  cursor: pointer;
  margin-bottom: var(--space-xs);
}
.notification-item:hover {
  background: var(--color-primary-a15);
  transform: translateY(-2px);
}
.notification-item.new {
  border-left-color: var(--color-error, #ff5555);
  background: var(--color-error-a05, rgba(255, 85, 85, 0.05));
  animation: highlight-new 2s ease-out;
}

/*---------- Overlays ----------*/
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-overlay);
  background-color: rgba(0, 0, 0, 0.75);
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color var(--transition-slow);
}
.overlay-content {
    width: 90%;
    max-width: 900px;
    height: 80vh;
    background: var(--color-glass-bg-dark);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-xl);
    overflow: hidden; 
    position: relative;
    box-shadow: var(--shadow-primary-lg);
    transition: opacity var(--transition-slow);
    display: flex; 
    flex-direction: column; 
}
.overlay-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-md) var(--space-lg);
  border-bottom: 1px solid var(--color-border);
  flex-shrink: 0; 
}
.overlay-title {
  color: var(--color-primary);
  font-size: var(--font-size-xxl);
  margin: 0;
}
.overlay-body {
  padding: var(--space-lg);
  overflow-y: auto; 
  flex-grow: 1; 
}

/*---------- Custom Scrollbar (for panel content, etc.) ----------*/
.panel-content::-webkit-scrollbar,
.overlay-body::-webkit-scrollbar 
 {
  width: 8px;
  height: 8px;
}
.panel-content::-webkit-scrollbar-track,
.overlay-body::-webkit-scrollbar-track
 {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
}
.panel-content::-webkit-scrollbar-thumb,
.overlay-body::-webkit-scrollbar-thumb
 {
  background: var(--color-primary-a30);
  border-radius: 4px;
}
.panel-content::-webkit-scrollbar-thumb:hover,
.overlay-body::-webkit-scrollbar-thumb:hover
 {
  background: var(--color-primary-a50);
}

/* Add Firefox scrollbar styles if needed */
.panel-content, .overlay-body {
  scrollbar-width: thin; 
  scrollbar-color: var(--color-primary-a30) rgba(0, 0, 0, 0.1); 
}
```

---
### `src\styles\layout.css`
```css
/* src/styles/layout.css */
@import "./variables.css";

/* Core App Layout */
.main-view {
  width: 100%;
  height: 100%;
  background: none; /* Background is on canvas-container now */
  position: relative;
  overflow: hidden;
  display: block;
}

/* Canvas Container Layout */
.canvas-container {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
  /* background, opacity, and transition for dimming are now in Mainview.css */
  z-index: var(--z-background);
}

/* REMOVED: .main-view.overlay-animating .canvas-container .canvas rule */
/* This is now handled by .main-view.overlay-animating .canvas-container in Mainview.css */

/* Background Grid */
.grid-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: radial-gradient( circle, rgba(var(--color-primary-rgb), 0.1) 1px, transparent 1px );
  background-size: 20px 20px;
  pointer-events: none;
  opacity: 1;
  z-index: 0; /* Behind canvases, but within canvas-container */
}

/* Centered Logo */
.entity-logo {
  position: absolute;
  bottom: var(--space-lg);
  left: 50%;
  transform: translateX(-50%);
  max-width: 200px;
  z-index: var(--z-ui); /* Above canvas container */
  opacity: 1;
  transition: all var(--transition-slow) ease;
}
.entity-logo:hover {
  opacity: 1;
  transform: translateX(-50%) scale(1.1);
  filter: drop-shadow(0 0 10px var(--color-primary-a30));
}

/* Preview Mode Indicator */
.preview-mode-indicator {
  position: fixed;
  top: calc(var(--space-lg) + var(--icon-size-lg) + 10px);
  right: var(--space-lg);
  z-index: var(--z-controls);
  display: flex;
  align-items: center;
  padding: var(--space-xs) var(--space-sm);
  border-radius: var(--radius-md);
  background: var(--color-warning-a10);
  border: 1px solid var(--color-warning-a30);
  animation: fadeIn var(--transition-normal);
}
.preview-icon {
  font-size: 18px;
  margin-right: var(--space-xs);
}
.preview-text {
  color: var(--color-warning-a90);
  font-size: var(--font-size-md);
  font-weight: bold;
  margin-right: var(--space-xs);
}
.exit-preview-button {
  background: var(--color-warning-a30);
  border: none;
  color: var(--color-text);
  padding: var(--space-xxs) var(--space-xs);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
}
.exit-preview-button:hover {
  background: var(--color-warning-a50, rgba(255, 165, 0, 0.5));
}

/* Main UI Container - for toolbars, panels etc. */
.ui-elements-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: var(--z-ui); /* Above canvas container */
  opacity: 1;
  visibility: visible;
  transition: opacity 0.5s ease-in-out, visibility 0s linear 0s;
}
.ui-elements-container.visible {
  opacity: 1;
  visibility: visible;
  transition-delay: 0s;
}
.ui-elements-container.visible > * {
  pointer-events: auto;
}
.ui-elements-container.hidden-by-opacity {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.5s ease-in-out 0s, visibility 0s linear 0.5s;
  pointer-events: none !important;
}
.ui-elements-container.hidden-by-opacity > * {
  pointer-events: none !important;
}
.ui-elements-container.visible .panel-wrapper,
.ui-elements-container.visible .vertical-toolbar-icon,
.ui-elements-container.visible .bottom-right-icons,
.ui-elements-container.visible .preset-selector-bar {
  pointer-events: auto;
}


/* Status Display (Loading/Error/Idle Messages) */
.status-display {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  z-index: var(--z-top);
  backdrop-filter: blur(var(--blur-amount, 3px));
  -webkit-backdrop-filter: blur(var(--blur-amount, 3px));
  box-shadow: var(--shadow-md);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--radius-md);
  font-size: var(--font-size-md);
  font-weight: 500;
  text-align: center;
  min-width: 250px;
  transition: opacity 500ms ease-in-out;
  opacity: 1;
  pointer-events: none;
}
.status-display.info-state {
  background: rgba(var(--color-warning-rgb), 0.25);
  border: 1px solid var(--color-warning-a50, rgba(255, 165, 0, 0.5));
  color: var(--color-warning, #ffa500);
  box-shadow: 0 0 12px rgba(var(--color-warning-rgb), 0.4);
}
.status-display.error-state {
  background: rgba(var(--color-error-rgb), 0.25);
  border: 1px solid var(--color-error-a50, rgba(255, 85, 85, 0.5));
  color: var(--color-error, #ff5555);
  box-shadow: 0 0 12px rgba(var(--color-error-rgb), 0.4);
}
.status-display.fade-out {
  opacity: 0;
}
.status-display .retry-render-button {
  display: block;
  margin: var(--space-sm) auto 0;
  padding: var(--space-xs) var(--space-md);
  background: var(--color-error-a30);
  color: var(--color-text);
  border: 1px solid var(--color-error-a50, rgba(255, 85, 85, 0.5));
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background var(--transition-fast);
  pointer-events: auto;
  font-size: var(--font-size-sm);
  font-family: var(--font-family);
  font-weight: bold;
  text-transform: uppercase;
}
.status-display .retry-render-button:hover:not(:disabled) {
  background: var(--color-error-a50, rgba(255, 165, 0, 0.5));
}
.status-display .retry-render-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* FPS Counter */
.fps-counter {
  position: fixed;
  bottom: var(--space-sm, 12px);
  left: var(--space-sm, 12px);
  z-index: 10001;
  pointer-events: none;
  background: rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(1px);
  -webkit-backdrop-filter: blur(1px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: none;
  color: var(--color-text-dim, rgba(255, 255, 255, 0.4));
  padding: var(--space-xxs) var(--space-xs);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-sm);
  font-family: monospace;
  text-align: center;
  opacity: 0.7;
}

/* Custom Cursor */
#fullscreen-root.radar-cursor {
  cursor: url('/assets/cursors/radar-dot.svg') 8 8, auto;
}

/* Click Ping Effect */
.click-ping-svg-container {
  position: absolute;
  width: 20px;
  height: 20px;
  transform: translate(-50%, -50%);
  transform-origin: center center;
  opacity: 1;
  pointer-events: none;
  z-index: var(--z-effects, 10);
}
.click-ping-svg {
  display: block;
  width: 100%;
  height: 100%;
  overflow: visible;
}
.click-ping-svg circle {
  stroke-opacity: 1;
  fill: none;
}
.ping-svg-animation .click-ping-svg circle {
  animation: ping-circle-anim 0.7s cubic-bezier(0.1, 0.7, 0.3, 1) forwards;
}
@keyframes ping-circle-anim {
  0% { r: 2; stroke-opacity: 1; transform: scale(0.5); }
  70% { r: 15; stroke-opacity: 0.7; transform: scale(1.2); }
  100% { r: 20; stroke-opacity: 0; transform: scale(1.5); }
}


/* Hidden Audio Analyzer Element */
.hidden-audio-analyzer {
  position: absolute;
  width: 0;
  height: 0;
  overflow: hidden;
  opacity: 0;
  pointer-events: none;
}

/* Maximize/Fullscreen Button */
.maximize-button {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
  backdrop-filter: blur(4px);
  transition: all 0.3s ease;
}
.maximize-button:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* Bottom Right Icons Container */
.bottom-right-icons {
  position: fixed;
  bottom: var(--space-lg);
  right: var(--space-lg);
  z-index: var(--z-controls);
  display: flex;
  flex-direction: row; /* Ensures horizontal layout */
  align-items: center;
  gap: var(--space-sm); /* Spacing between icons */
  pointer-events: auto; /* Container itself allows pointer events */
}

/* --- START: Styles for Sequencer/Randomizer Button --- */
.bottom-right-icons .toolbar-icon.sequencer-toggle-button { /* UPDATED CLASS NAME */
  order: -1;
  width: var(--icon-size-lg);
  height: var(--icon-size-lg);
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.bottom-right-icons .toolbar-icon.sequencer-toggle-button .icon-image { /* UPDATED CLASS NAME */
  width: var(--icon-size-md);
  height: var(--icon-size-md);
  object-fit: contain;
  color: var(--color-primary-a70);
  transition: color var(--transition-fast), filter var(--transition-fast);
}

.bottom-right-icons .toolbar-icon.sequencer-toggle-button:hover .icon-image { /* UPDATED CLASS NAME */
  color: var(--color-primary);
}

.bottom-right-icons .toolbar-icon.sequencer-toggle-button.active { /* UPDATED CLASS NAME */
  background: var(--color-primary-a30);
  border-color: var(--color-primary);
  box-shadow: var(--shadow-primary-md);
}

.bottom-right-icons .toolbar-icon.sequencer-toggle-button.active .icon-image { /* UPDATED CLASS NAME */
  color: var(--color-primary);
  filter: drop-shadow(0 0 5px var(--color-primary));
}

/* Disabled state for all toolbar icons in bottom-right */
.bottom-right-icons .toolbar-icon:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: var(--color-button-secondary-a80);
  border-color: var(--color-primary-a50);
}

.bottom-right-icons .toolbar-icon:disabled:hover {
  transform: none;
  background: var(--color-button-secondary-a80);
  border-color: var(--color-primary-a50);
}

.bottom-right-icons .toolbar-icon:disabled .icon-image {
  color: var(--color-text-muted);
  filter: none;
}
/* --- END: Styles for Sequencer/Randomizer Button --- */


/* General Connect Pill Style */
.general-connect-pill {
  position: fixed;
  /* --- MODIFIED: Increased bottom value --- */
  bottom: calc(var(--space-md) + 36px + var(--space-sm)); /* approx 16px + 36px (bar height) + 12px (gap) = 64px */
  /* --------------------------------------- */
  left: 50%;
  transform: translateX(-50%);
  background-color: var(--color-warning-a10);
  color: var(--color-warning-a90);
  padding: var(--space-xs) var(--space-md);
  border-radius: var(--radius-md);
  font-size: var(--font-size-sm);
  border: 1px solid var(--color-warning-a30);
  z-index: var(--z-top); /* Ensure it's above preset bar if z-indexes are close */
  box-shadow: var(--shadow-md);
  text-align: center;
  max-width: 80%;
  animation: fadeIn var(--transition-normal);
}
```

---
### `src\styles\variables.css`
```css
/* src/styles/variables.css */
:root {
  --font-family-radar: "RadarFont", var(--font-family);

  --color-primary: #00f3ff;
  --color-primary-rgb: 0, 243, 255;
  --color-primary-a90: rgba(0, 243, 255, 0.9);
  --color-primary-a70: rgba(0, 243, 255, 0.7);
  --color-primary-a50: rgba(0, 243, 255, 0.5);
  --color-primary-a30: rgba(0, 243, 255, 0.3);
  --color-primary-a15: rgba(0, 243, 255, 0.15);
  --color-primary-a05: rgba(0, 243, 255, 0.05);

  --color-bg-dark: #050f19;
  --color-bg: #101018;
  --color-bg-light: #1a1a2e;

  --color-glass-bg: rgba(16, 16, 24, 0.8);
  --color-glass-bg-light: rgba(26, 26, 46, 0.8);
  --color-glass-bg-dark: rgba(5, 15, 25, 0.85);

  --color-success: #00ff00;
  --color-success-rgb: 0, 255, 0;
  --color-warning: #ffa500;
  --color-warning-rgb: 255, 165, 0;
  --color-error: #ff5555;
  --color-error-rgb: 255, 85, 85;

  --color-success-a90: rgba(0, 255, 0, 0.9);
  --color-success-a30: rgba(0, 255, 0, 0.3);
  --color-success-a10: rgba(0, 255, 0, 0.1);

  --color-warning-a90: rgba(255, 165, 0, 0.9);
  --color-warning-a30: rgba(255, 165, 0, 0.3);
  --color-warning-a10: rgba(255, 165, 0, 0.1);

  --color-error-a90: rgba(255, 85, 85, 0.9);
  --color-error-a30: rgba(255, 85, 85, 0.3);
  --color-error-a10: rgba(255, 85, 85, 0.1);

  --color-lyx: #ff9000;
  --color-lyx-a20: rgba(255, 144, 0, 0.2);
  --color-token: #00ff80;
  --color-token-a20: rgba(0, 255, 128, 0.2);
  --color-contract: #0080ff;
  --color-contract-a20: rgba(0, 128, 255, 0.2);

  /* --- ADDED/UPDATED DEFINITIONS FOR METER FILL COLORS --- */
  --color-accent: #FFD700; /* Gold - for Level meter */
  --color-bass: #FF5733;   /* Reddish-Orange - for Bass meter */
  --color-mid: #FFC300;    /* Yellow-Orange - for Mid meter */
  --color-treble: #33FFBD; /* Cyan-Green - for Treble meter */
  /* --- END ADDED/UPDATED DEFINITIONS --- */


  --color-text: rgba(255, 255, 255, 0.9);
  --color-text-muted: rgba(255, 255, 255, 0.6);
  --color-text-dim: rgba(255, 255, 255, 0.4);

  --color-border: rgba(0, 243, 255, 0.2);
  --color-border-light: rgba(0, 243, 255, 0.3);
  --color-border-dark: rgba(0, 243, 255, 0.1);

  --space-xxs: 4px;
  --space-xs: 8px;
  --space-sm: 12px;
  --space-md: 16px;
  --space-lg: 20px;
  --space-xl: 24px;
  --space-xxl: 32px;

  --radius-sm: 4px;
  --radius-md: 6px;
  --radius-lg: 8px;
  --radius-xl: 12px;
  --radius-circle: 50%;

  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
  --shadow-md: 0 4px 10px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 5px 15px rgba(0, 0, 0, 0.3);

  --shadow-primary-sm: 0 0 5px rgba(0, 243, 255, 0.2);
  --shadow-primary-md: 0 0 10px rgba(0, 243, 255, 0.3);
  --shadow-primary-lg: 0 0 15px rgba(0, 243, 255, 0.3);

  --transition-fast: 0.2s ease;
  --transition-normal: 0.3s ease;
  --transition-slow: 0.5s ease;
  --transition-elastic: 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);

  --z-background: 1;
  --z-base: 10;
  --z-canvas: 100;
  --z-ui: 500;
  --z-controls: 1000;
  --z-overlay: 1500;
  --z-top: 2000;
  --z-tooltip: 2500;

  --icon-size-sm: 24px;
  --icon-size-md: 28px;
  --icon-size-lg: 35px;
  --panel-width: 400px;
  --control-panel-width: 400px;

  --blur-amount: 1px;

  --font-family: "Arial", sans-serif;
  --font-size-xs: 10px;
  --font-size-sm: 11px;
  --font-size-md: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-xxl: 24px;

  --header-height: 40px;
  --panel-left-position: 90px;
}
```

---
### `src\utils\CanvasManager.js`
```js
// src/utils/CanvasManager.js
import { BLEND_MODES } from '../config/global-config'; // Local config
import ValueInterpolator from './ValueInterpolator'; // Local utility

const SETUP_CANVAS_POLL_INTERVAL = 100; // ms, for polling parent dimensions if initially zero
const SETUP_CANVAS_POLL_TIMEOUT = 3000; // ms, max time to poll for dimensions
const MAX_TOTAL_OFFSET = 10000; // Max pixel offset for drift/positioning to prevent extreme values
const DELTA_TIME_BUFFER_SIZE = 5; // Number of frames to average for smoothedDeltaTime

const MIDI_XY_INTERPOLATION_DURATION = 80; // ms, duration for X/Y position interpolation
const MIDI_ANGLE_INTERPOLATION_DURATION = 60; // ms, duration for angle interpolation

/**
 * @file Manages an individual HTML5 Canvas for a visual layer.
 * Handles setup, image loading, configuration, animation, and drawing.
 * Renders with a 1:1 pixel ratio to CSS dimensions, letting the browser handle parent page zoom scaling.
 */

/**
 * @class CanvasManager
 * @description Orchestrates rendering and animation for a single canvas layer.
 * It encapsulates the canvas context, current image, configuration,
 * animation loop, and drawing logic for a specific visual layer.
 */
class CanvasManager {
    /** @type {HTMLCanvasElement | null} The HTML canvas element. */
    canvas = null;
    /** @type {CanvasRenderingContext2D | null} The 2D rendering context. */
    ctx = null;
    /** @type {string} Identifier for this layer (e.g., '1', '2', '3'). */
    layerId;
    /** @type {HTMLImageElement | null} The current image object being rendered. */
    image = null;
    /** @type {object} Current layer visual configuration. See `getDefaultConfig` for structure. */
    config;
    /** @type {number | null} ID of the animation frame request, null if not animating. */
    animationFrameId = null;
    /** @type {number} Timestamp of the last animation frame, used for delta time calculation. */
    lastTimestamp = 0;
    /** @type {boolean} Flag to prevent concurrent drawing operations, ensuring draw calls are serialized. */
    isDrawing = false;
    /** @type {boolean} Indicates if the manager instance has been destroyed and should not operate. */
    isDestroyed = false;
    /** @type {string | null} Source URL of the last successfully loaded image. */
    lastImageSrc = null;
    /** @type {number} Last known valid logical width of the canvas (CSS pixels). */
    lastValidWidth = 0;
    /** @type {number} Last known valid logical height of the canvas (CSS pixels). */
    lastValidHeight = 0;
    /** @type {number} Last Device Pixel Ratio used for setup (forced to 1 for 1:1 buffer). */
    lastDPR = 1;
    /** @type {number[]} Buffer for smoothing delta time values across recent frames. */
    deltaTimeBuffer = [];
    /** @type {number} Smoothed delta time in seconds, used for consistent animation speed. */
    smoothedDeltaTime = 1 / 60; // Default to 60 FPS
    /** @type {ValueInterpolator | null} Interpolator for x-axis position. */
    xInterpolator;
    /** @type {ValueInterpolator | null} Interpolator for y-axis position. */
    yInterpolator;
    /** @type {ValueInterpolator | null} Interpolator for angle. */
    angleInterpolator;
    /** @type {number} Continuously accumulating angle for rotation effects (degrees). */
    continuousRotationAngle = 0;
    /** @type {number} Size multiplier derived from audio frequency analysis. */
    audioFrequencyFactor = 1.0;
    /** @type {number} Temporary size multiplier for audio beat pulse effects. */
    beatPulseFactor = 1.0;
    /** @type {number} Timestamp (performance.now()) when the current audio beat pulse effect should end. */
    beatPulseEndTime = 0;

    /**
     * Creates an instance of CanvasManager.
     * @param {HTMLCanvasElement} canvas - The canvas element to manage.
     * @param {string} layerId - Identifier for this layer.
     * @throws {Error} If an invalid canvas element is provided or context cannot be obtained.
     */
    constructor(canvas, layerId) {
        if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
            throw new Error(`[CM L${layerId}] Invalid canvas element provided.`);
        }
        this.canvas = canvas;
        try {
            this.ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false }); // willReadFrequently false for potential perf gain
            if (!this.ctx) {
                throw new Error(`Failed to get 2D context for Layer ${layerId} (returned null)`);
            }
        } catch (e) {
            if (import.meta.env.DEV) {
                console.error(`[CM L${layerId}] Error getting context:`, e);
            }
            throw new Error(`Failed to get 2D context for Layer ${layerId}: ${e.message}`);
        }
        this.layerId = layerId;
        this.config = this.getDefaultConfig();
        this.lastDPR = 1; // Force DPR 1 for buffer to match CSS pixels

        this.xInterpolator = new ValueInterpolator(this.config.xaxis, MIDI_XY_INTERPOLATION_DURATION);
        this.yInterpolator = new ValueInterpolator(this.config.yaxis, MIDI_XY_INTERPOLATION_DURATION);
        this.angleInterpolator = new ValueInterpolator(this.config.angle, MIDI_ANGLE_INTERPOLATION_DURATION);

        this.animationLoop = this.animationLoop.bind(this); // Bind for requestAnimationFrame
    }

    /**
     * Returns the default configuration object for a layer.
     * @returns {object} The default configuration.
     */
    getDefaultConfig() {
        return {
            enabled: true,
            blendMode: 'normal',
            opacity: 1.0,
            size: 1.0,
            speed: 0.01, // Speed for continuous rotation
            drift: 0, // Magnitude of drift
            driftSpeed: 0.1, // Speed of drift oscillation
            angle: 0, // Base angle (degrees)
            xaxis: 0, // Base X offset
            yaxis: 0, // Base Y offset
            direction: 1, // Direction multiplier for speed (-1 or 1)
            driftState: { x: 0, y: 0, phase: Math.random() * Math.PI * 2, enabled: false },
            audioSource: 'level', // Example: 'level', 'frequency', 'beat' (for future audio reactivity)
        };
    }

    /**
     * Sets up canvas dimensions (1:1 with CSS pixels) and context transform.
     * This method is crucial for ensuring the canvas is correctly sized and scaled.
     * It polls briefly if initial dimensions are zero.
     * @async
     * @returns {Promise<boolean>} True if setup was successful or if no changes were needed.
     *                             False if setup failed (e.g., canvas parent not found, zero dimensions after poll).
     */
    async setupCanvas() {
        const logPrefix = `[CM L${this.layerId}] setupCanvas:`;
        if (!this.canvas || this.isDestroyed) {
            if (import.meta.env.DEV) {
                console.warn(`${logPrefix} Aborted - canvas null or destroyed.`);
            }
            this.lastValidWidth = 0; this.lastValidHeight = 0; this.lastDPR = 0; return false;
        }
        const parent = this.canvas.parentElement;
        if (!parent) {
            if (import.meta.env.DEV) {
                console.warn(`${logPrefix} Aborted - no parent element.`);
            }
            this.lastValidWidth = 0; this.lastValidHeight = 0; this.lastDPR = 0; return false;
        }

        const dprForBuffer = 1; // Force DPR 1 for buffer size calculation (1:1 with CSS pixels)

        const parentRectImmediate = parent.getBoundingClientRect();
        const currentLogicalWidth = Math.floor(parentRectImmediate.width);
        const currentLogicalHeight = Math.floor(parentRectImmediate.height);

        if (import.meta.env.DEV && (currentLogicalWidth !== this.lastValidWidth || currentLogicalHeight !== this.lastValidHeight || this.lastDPR !== dprForBuffer)) {
            console.log(`${logPrefix} Initial/Change Check - ParentRect: ${currentLogicalWidth}x${currentLogicalHeight}, DPR for Buffer (FORCED): ${dprForBuffer}`);
        }

        // Check if dimensions and DPR are already correct and valid
        if (
            currentLogicalWidth === this.lastValidWidth &&
            currentLogicalHeight === this.lastValidHeight &&
            this.canvas.width === currentLogicalWidth &&
            this.canvas.height === currentLogicalHeight &&
            currentLogicalWidth > 0 && currentLogicalHeight > 0 &&
            this.lastDPR === dprForBuffer
        ) {
            return true; // No changes needed
        }

        let logicalWidth = currentLogicalWidth;
        let logicalHeight = currentLogicalHeight;

        // Poll if dimensions are initially zero (e.g., due to layout shifts)
        if (logicalWidth <= 0 || logicalHeight <= 0) {
            if (import.meta.env.DEV) {
                console.log(`${logPrefix} Zero/Invalid initial dimensions. Starting poll...`);
            }
            let attempts = 0;
            const maxAttempts = SETUP_CANVAS_POLL_TIMEOUT / SETUP_CANVAS_POLL_INTERVAL;
            while (attempts < maxAttempts) {
                attempts++;
                if (!parent.isConnected) { // Check if parent is still in DOM
                    if (import.meta.env.DEV) {
                        console.warn(`${logPrefix} Parent disconnected during poll.`);
                    }
                    this.lastValidWidth = 0; this.lastValidHeight = 0; this.lastDPR = 0; return false;
                }
                const rect = parent.getBoundingClientRect();
                logicalWidth = Math.floor(rect.width);
                logicalHeight = Math.floor(rect.height);
                if (logicalWidth > 0 && logicalHeight > 0) break; // Valid dimensions found
                await new Promise(resolve => setTimeout(resolve, SETUP_CANVAS_POLL_INTERVAL));
            }
        }

        // Final check after potential polling
        if (logicalWidth <= 0 || logicalHeight <= 0) {
             if (import.meta.env.DEV) {
                 console.error(`${logPrefix} FAILED - Zero Dimensions after timeout/check (${logicalWidth}x${logicalHeight}).`);
             }
             this.lastValidWidth = 0; this.lastValidHeight = 0; this.lastDPR = 0;
             if (this.canvas && (this.canvas.width > 0 || this.canvas.height > 0)) { // Attempt to clear canvas if it had dimensions
                 try { this.canvas.width = 0; this.canvas.height = 0; } catch(e) {
                    if (import.meta.env.DEV) {
                        console.error(`${logPrefix} Error zeroing canvas w/h during failed setup:`, e);
                    }
                 }
             }
             return false;
        }

        const targetRenderWidth = logicalWidth; // Buffer width = logical width (DPR 1)
        const targetRenderHeight = logicalHeight; // Buffer height = logical height (DPR 1)

        if (!this.canvas) { // Should not happen if initial check passed, but defensive
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Canvas became null unexpectedly during setup.`);
            }
            this.lastValidWidth = 0; this.lastValidHeight = 0; this.lastDPR = 0; return false;
        }

        let resized = false;
        if (this.canvas.width !== targetRenderWidth || this.canvas.height !== targetRenderHeight) {
            try {
                this.canvas.width = targetRenderWidth;
                this.canvas.height = targetRenderHeight;
                resized = true;
                if (import.meta.env.DEV) {
                    console.log(`${logPrefix} Canvas buffer resized to: ${this.canvas.width}x${this.canvas.height}`);
                }
            } catch(e) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Error setting canvas buffer w/h:`, e);
                }
                return false; // Critical error if buffer cannot be set
            }
        }

        if (this.canvas.style.width !== `${logicalWidth}px` || this.canvas.style.height !== `${logicalHeight}px`) {
             try {
                 this.canvas.style.width = `${logicalWidth}px`;
                 this.canvas.style.height = `${logicalHeight}px`;
                 if (import.meta.env.DEV) {
                     console.log(`${logPrefix} Canvas style set to: ${this.canvas.style.width}x${this.canvas.style.height}`);
                 }
             } catch (e) {
                 if (import.meta.env.DEV) {
                     console.warn(`${logPrefix} Error setting canvas style w/h:`, e);
                 }
             }
        }

        if ((resized || this.ctx) && this.ctx) { // Ensure ctx exists
            try {
                this.ctx.setTransform(dprForBuffer, 0, 0, dprForBuffer, 0, 0); // Apply forced DPR
                if (import.meta.env.DEV) {
                    console.log(`${logPrefix} Context transform set with dprForBuffer (FORCED): ${dprForBuffer}`);
                }
            } catch (e) {
                 if (import.meta.env.DEV) {
                     console.error(`${logPrefix} Context transform error:`, e);
                 }
            }
        }

        this.lastValidWidth = logicalWidth;
        this.lastValidHeight = logicalHeight;
        this.lastDPR = dprForBuffer;

        this.xInterpolator?.snap(this.config.xaxis);
        this.yInterpolator?.snap(this.config.yaxis);
        this.angleInterpolator?.snap(this.config.angle);

        if (import.meta.env.DEV) {
            console.log(`${logPrefix} Setup successful. LastValid: ${this.lastValidWidth}x${this.lastValidHeight}, LastDPR (FORCED): ${this.lastDPR}`);
        }
        return true;
    }

    /**
     * Applies a full new configuration object to the layer, merging with defaults.
     * @param {object} newConfig - The new configuration object to apply. Missing properties will revert to default.
     */
    applyFullConfig(newConfig) {
        if (this.isDestroyed) return;
        const defaultConfig = this.getDefaultConfig();
        const mergedConfig = { ...defaultConfig };

        for (const key in defaultConfig) {
            if (Object.prototype.hasOwnProperty.call(defaultConfig, key)) {
                if (newConfig && Object.prototype.hasOwnProperty.call(newConfig, key) && newConfig[key] !== undefined && newConfig[key] !== null) {
                    if (key === 'driftState' && typeof newConfig[key] === 'object' && defaultConfig[key] && typeof defaultConfig[key] === 'object') {
                        mergedConfig.driftState = { ...(defaultConfig.driftState || {}), ...(newConfig[key] || {}), };
                        mergedConfig.driftState.x = typeof mergedConfig.driftState.x === 'number' ? mergedConfig.driftState.x : 0;
                        mergedConfig.driftState.y = typeof mergedConfig.driftState.y === 'number' ? mergedConfig.driftState.y : 0;
                        mergedConfig.driftState.phase = typeof mergedConfig.driftState.phase === 'number' ? mergedConfig.driftState.phase : Math.random() * Math.PI * 2;
                        mergedConfig.driftState.enabled = typeof mergedConfig.driftState.enabled === 'boolean' ? mergedConfig.driftState.enabled : false;
                    } else {
                        mergedConfig[key] = this.validateValue(key, newConfig[key], defaultConfig[key]);
                    }
                } else {
                    mergedConfig[key] = defaultConfig[key];
                }
            }
        }
        if (!BLEND_MODES.includes(mergedConfig.blendMode)) { mergedConfig.blendMode = 'normal'; }

        if (!mergedConfig.driftState || typeof mergedConfig.driftState !== 'object') {
            mergedConfig.driftState = { x:0,y:0,phase:Math.random()*Math.PI*2,enabled:false };
        }
        mergedConfig.driftState.enabled = (mergedConfig.drift || 0) > 0;
        if (!mergedConfig.driftState.enabled) {
            mergedConfig.driftState.x = 0;
            mergedConfig.driftState.y = 0;
        }

        this.config = mergedConfig;

        if (this.canvas?.style) {
            this.canvas.style.mixBlendMode = this.config.blendMode || "normal";
        }

        this.xInterpolator?.snap(this.config.xaxis);
        this.yInterpolator?.snap(this.config.yaxis);
        this.angleInterpolator?.snap(this.config.angle);
        this.continuousRotationAngle = 0;

        this.handleEnabledToggle(this.config.enabled);
    }

    /**
     * Validates a configuration value against its expected type and constraints.
     * @param {string} key - The configuration key.
     * @param {*} value - The value to validate.
     * @param {*} defaultValue - The default value to infer type and use as fallback.
     * @returns {*} The validated value, or the default value if validation fails.
     */
    validateValue(key, value, defaultValue) {
        let validated = value;
        const defaultValueType = typeof defaultValue;

        if (defaultValueType === 'number') {
            validated = Number(value);
            if (isNaN(validated)) validated = defaultValue;
            if (key === 'opacity') validated = Math.max(0, Math.min(1, validated));
            if (key === 'size') validated = Math.max(0.01, validated);
        } else if (defaultValueType === 'string') {
            validated = String(value);
            if (key === 'blendMode' && !BLEND_MODES.includes(validated)) {
                validated = defaultValue;
            }
        } else if (defaultValueType === 'boolean') {
            validated = Boolean(value);
        }
        return validated;
    }

    /**
     * Starts or stops the animation loop based on the enabled state.
     * Clears the canvas if disabling.
     * @param {boolean} isEnabled - Whether the layer should be enabled.
     */
    handleEnabledToggle(isEnabled) {
        if (isEnabled && !this.animationFrameId) {
            this.startAnimationLoop();
        } else if (!isEnabled && this.animationFrameId) {
            this.stopAnimationLoop();
            if (this.ctx && this.canvas?.width > 0 && this.canvas?.height > 0) {
                try { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); }
                catch (e) {
                    if (import.meta.env.DEV) {
                        console.error(`[CM L${this.layerId}] Error clearing canvas on disable:`, e);
                    }
                }
            }
        }
    }

    /**
     * Immediately sets a visual property's value in the config and snaps its interpolator.
     * @param {string} key - The configuration key (e.g., 'xaxis', 'opacity').
     * @param {*} value - The new value to set.
     */
    snapVisualProperty(key, value) {
        if (this.isDestroyed) return;
        const defaultConfig = this.getDefaultConfig();
        if (!Object.prototype.hasOwnProperty.call(defaultConfig, key)) {
            if (import.meta.env.DEV) {
                console.warn(`[CM L${this.layerId}] snapVisualProperty: Unknown property '${key}'.`);
            }
            return;
        }

        const validatedValue = this.validateValue(key, value, defaultConfig[key]);
        this.config[key] = validatedValue;

        if (key === 'xaxis' && this.xInterpolator) this.xInterpolator.snap(validatedValue);
        else if (key === 'yaxis' && this.yInterpolator) this.yInterpolator.snap(validatedValue);
        else if (key === 'angle' && this.angleInterpolator) this.angleInterpolator.snap(validatedValue);
        else if (key === 'blendMode' && this.canvas?.style) this.canvas.style.mixBlendMode = validatedValue || 'normal';
        else if (key === 'drift') {
            if (!this.config.driftState) this.config.driftState = { x:0,y:0,phase:Math.random()*Math.PI*2,enabled:false };
            this.config.driftState.enabled = validatedValue > 0;
            if (!this.config.driftState.enabled) { this.config.driftState.x = 0; this.config.driftState.y = 0; }
        } else if (key === 'enabled') this.handleEnabledToggle(validatedValue);
    }

    /**
     * Updates a non-interpolated configuration property directly.
     * For 'xaxis', 'yaxis', 'angle', this behaves like snapVisualProperty.
     * @param {string} key - The configuration key.
     * @param {*} value - The new value.
     */
    updateConfigProperty(key, value) {
        if (this.isDestroyed) return;
        const defaultConfig = this.getDefaultConfig();

        if (key === 'xaxis' || key === 'yaxis' || key === 'angle') {
            this.snapVisualProperty(key, value);
            return;
        }

        if (!Object.prototype.hasOwnProperty.call(defaultConfig, key)) {
            return; // Silently ignore unknown properties
        }
        const validatedValue = this.validateValue(key, value, defaultConfig[key]);
        this.config[key] = validatedValue;

        if (key === 'blendMode' && this.canvas?.style) this.canvas.style.mixBlendMode = validatedValue || 'normal';
        else if (key === 'drift') {
             if (!this.config.driftState) this.config.driftState = { x:0,y:0,phase:Math.random()*Math.PI*2,enabled:false };
             this.config.driftState.enabled = validatedValue > 0;
             if (!this.config.driftState.enabled) { this.config.driftState.x = 0; this.config.driftState.y = 0; }
        } else if (key === 'enabled') this.handleEnabledToggle(validatedValue);
    }

    /** Starts the animation loop if not already running and the layer is enabled. */
    startAnimationLoop() {
        if (this.isDestroyed || this.animationFrameId !== null || !this.config.enabled) return;
        this.lastTimestamp = performance.now();
        this.deltaTimeBuffer = [];
        this.smoothedDeltaTime = 1 / 60;
        this.animationFrameId = requestAnimationFrame(this.animationLoop);
    }

    /** Stops the animation loop. */
    stopAnimationLoop() {
        if (this.animationFrameId !== null) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        this.isDrawing = false;
    }

    /**
     * Performs a single static draw operation using the current or provided configuration.
     * @async
     * @param {object | null} [configToUse=null] - Optional config object. Defaults to current config.
     * @returns {Promise<boolean>} True if draw was successfully initiated.
     */
    async drawStaticFrame(configToUse = null) {
        if (this.isDestroyed || this.isDrawing) return false;
        const setupSuccess = await this.setupCanvas();
        if (!setupSuccess) return false;

        this.smoothedDeltaTime = 1 / 60;
        const currentConfig = configToUse || this.config;

        this.xInterpolator?.snap(currentConfig.xaxis);
        this.yInterpolator?.snap(currentConfig.yaxis);
        this.angleInterpolator?.snap(currentConfig.angle);
        this.continuousRotationAngle = 0;

        return this.draw(performance.now(), currentConfig);
    }

    /**
     * Loads an image from the given source URL.
     * @async
     * @param {string} src - The source URL of the image.
     * @returns {Promise<void>} Resolves when image is loaded, rejects on error.
     */
    async setImage(src) {
        if (this.isDestroyed) return Promise.reject(new Error("Manager destroyed"));
        return new Promise((resolve, reject) => {
            if (!src || typeof src !== 'string') {
                this.image = null; this.lastImageSrc = null;
                return reject(new Error("Invalid image source"));
            }
            if (src === this.lastImageSrc && this.image?.complete && this.image?.naturalWidth > 0) {
                return resolve();
            }

            const img = new Image();
            if (src.startsWith('http') && !src.startsWith(window.location.origin)) {
                img.crossOrigin = "anonymous";
            }
            img.onload = () => {
                if (this.isDestroyed) return resolve();
                if (img.naturalWidth === 0 || img.naturalHeight === 0) {
                    this.image = null; this.lastImageSrc = null;
                    reject(new Error(`Loaded image has zero dimensions: ${src.substring(0, 100)}`)); return;
                }
                this.image = img; this.lastImageSrc = src;
                resolve();
            };
            img.onerror = (errEvent) => { // errEvent is an Event, not Error directly
                if (this.isDestroyed) return reject(new Error("Manager destroyed during image load error"));
                this.image = null; this.lastImageSrc = null;
                const errorMsg = typeof errEvent === 'string' ? errEvent : (errEvent?.type || 'Unknown image load error');
                reject(new Error(`Failed to load image: ${src.substring(0, 50)}... Error: ${errorMsg}`));
            };
            img.src = src;
        });
    }

    /**
     * Sets the target value for an interpolated parameter (e.g., from MIDI input).
     * @param {string} param - The parameter key ('xaxis', 'yaxis', 'angle').
     * @param {number} targetValue - The new target value.
     */
    setTargetValue(param, targetValue) {
        if (this.isDestroyed) return;
        const validatedValue = Number(targetValue);
        if (isNaN(validatedValue)) {
            if (import.meta.env.DEV) {
                console.warn(`[CM L${this.layerId}] Invalid MIDI target value for ${param}: ${targetValue}`);
            }
            return;
        }
        if (Object.prototype.hasOwnProperty.call(this.config, param)) {
            this.config[param] = validatedValue;
        } else {
            if (import.meta.env.DEV) {
                console.warn(`[CM L${this.layerId}] Unknown MIDI parameter '${param}' for setTargetValue.`);
            }
            return;
        }

        if (param === 'xaxis' && this.xInterpolator) this.xInterpolator.setTarget(validatedValue);
        else if (param === 'yaxis' && this.yInterpolator) this.yInterpolator.setTarget(validatedValue);
        else if (param === 'angle' && this.angleInterpolator) this.angleInterpolator.setTarget(validatedValue);
    }

    /**
     * Sets the audio frequency factor used for size modification.
     * @param {number} factor - The size multiplier based on audio frequency. Defaults to 1.0.
     */
    setAudioFrequencyFactor(factor) { if (this.isDestroyed) return; this.audioFrequencyFactor = Number(factor) || 1.0; }

    /**
     * Triggers a temporary beat pulse effect on the layer's size.
     * @param {number} pulseFactor - The size multiplier during the pulse. Defaults to 1.0.
     * @param {number} duration - The duration of the pulse in milliseconds. Defaults to 0.
     */
    triggerBeatPulse(pulseFactor, duration) { if (this.isDestroyed) return; this.beatPulseFactor = Number(pulseFactor) || 1.0; this.beatPulseEndTime = performance.now() + (Number(duration) || 0); }

    /** Resets any active audio-driven modifications to their defaults. */
    resetAudioModifications() { if (this.isDestroyed) return; this.audioFrequencyFactor = 1.0; this.beatPulseFactor = 1.0; this.beatPulseEndTime = 0; }

    /**
     * Returns a deep copy of the current configuration object.
     * @returns {object} A deep copy of the layer's configuration.
     */
    getConfigData() { return JSON.parse(JSON.stringify(this.config)); }

    /**
     * The core drawing function, called within the animation loop or for static frames.
     * @param {number} timestamp - The current timestamp.
     * @param {object | null} [configToUse=null] - The configuration object to use. Defaults to current config.
     * @returns {boolean} True if drawing was performed.
     */
    draw(timestamp, configToUse = null) {
        const currentConfig = configToUse || this.config;
        const logPrefix = `[CM L${this.layerId}] draw:`;

        if (this.isDestroyed || !currentConfig?.enabled || this.isDrawing ||
            !this.canvas || !this.ctx || !this.image || !this.image.complete ||
            this.image.naturalWidth === 0 || this.lastValidWidth <= 0 || this.lastValidHeight <= 0) {
            this.isDrawing = false;
            return false;
        }
        this.isDrawing = true;

        try {
            const width = this.lastValidWidth; const height = this.lastValidHeight;
            const halfWidth = Math.floor(width / 2); const halfHeight = Math.floor(height / 2);
            const remainingWidth = width - halfWidth; const remainingHeight = height - halfHeight;

            const imgNaturalWidth = this.image.naturalWidth; const imgNaturalHeight = this.image.naturalHeight;
            const imgAspectRatio = (imgNaturalWidth > 0 && imgNaturalHeight > 0) ? imgNaturalWidth / imgNaturalHeight : 1;

            let currentBaseSize = currentConfig.size ?? 1.0;
            let finalDrawSize = currentBaseSize * this.audioFrequencyFactor;
            if (this.beatPulseEndTime && timestamp < this.beatPulseEndTime) {
                finalDrawSize *= this.beatPulseFactor;
            } else if (this.beatPulseEndTime && timestamp >= this.beatPulseEndTime) {
                this.beatPulseFactor = 1.0; this.beatPulseEndTime = 0;
            }
            finalDrawSize = Math.max(0.01, finalDrawSize);

            let imgDrawWidth = halfWidth * finalDrawSize;
            let imgDrawHeight = imgDrawWidth / imgAspectRatio;
            if (imgAspectRatio > 0 && imgDrawHeight > halfHeight * finalDrawSize) {
                imgDrawHeight = halfHeight * finalDrawSize; imgDrawWidth = imgDrawHeight * imgAspectRatio;
            } else if (isNaN(imgDrawHeight) || imgAspectRatio <= 0) {
                imgDrawWidth = halfWidth * finalDrawSize; imgDrawHeight = halfHeight * finalDrawSize;
            }
            imgDrawWidth = Math.max(1, Math.floor(imgDrawWidth));
            imgDrawHeight = Math.max(1, Math.floor(imgDrawHeight));

            this.updateDrift(currentConfig, this.smoothedDeltaTime);
            const driftX = currentConfig.driftState?.x ?? 0;
            const driftY = currentConfig.driftState?.y ?? 0;

            const currentX = this.xInterpolator?.isCurrentlyInterpolating() ? this.xInterpolator.getCurrentValue() : this.config.xaxis;
            const currentY = this.yInterpolator?.isCurrentlyInterpolating() ? this.yInterpolator.getCurrentValue() : this.config.yaxis;
            const baseAngle = this.angleInterpolator?.isCurrentlyInterpolating() ? this.angleInterpolator.getCurrentValue() : this.config.angle;

            const offsetX = currentX / 10;
            const offsetY = currentY / 10;
            const finalAngle = baseAngle + this.continuousRotationAngle;
            const angleRad = (finalAngle % 360) * Math.PI / 180;

            const finalCenterX_TL = Math.max(-MAX_TOTAL_OFFSET, Math.min(MAX_TOTAL_OFFSET, halfWidth / 2 + offsetX + driftX));
            const finalCenterY_TL = Math.max(-MAX_TOTAL_OFFSET, Math.min(MAX_TOTAL_OFFSET, halfHeight / 2 + offsetY + driftY));

            if (import.meta.env.DEV && (width < 100 || height < 100 || imgDrawWidth < 10 || imgDrawHeight < 10)) {
                // console.log(`${logPrefix} Draw Params - LogicalWH: ${width}x${height}, ImgDrawWH: ${imgDrawWidth}x${imgDrawHeight}, FinalCenterTL: ${finalCenterX_TL.toFixed(1)}x${finalCenterY_TL.toFixed(1)}, Angle: ${finalAngle.toFixed(1)}, Opacity: ${currentConfig.opacity}, ImageSrc: ${this.image.src.substring(0,50)}...`);
            }

            try { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); }
            catch (e) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Error clearing canvas:`, e);
                }
                this.isDrawing = false; return false;
            }

            this.ctx.globalAlpha = currentConfig.opacity ?? 1.0;

            const drawImageWithRotation = () => {
                 try {
                    this.ctx.save();
                    this.ctx.rotate(angleRad);
                    if (this.image?.complete && this.image?.naturalWidth > 0) {
                        this.ctx.drawImage(this.image, 0, 0, imgNaturalWidth, imgNaturalHeight, -imgDrawWidth / 2, -imgDrawHeight / 2, imgDrawWidth, imgDrawHeight);
                    }
                    this.ctx.restore();
                } catch (e) { if (import.meta.env.DEV) console.error(`${logPrefix} drawImage error:`, e); }
            };

            this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(0,0,halfWidth,halfHeight); this.ctx.clip();
            this.ctx.translate(finalCenterX_TL, finalCenterY_TL); drawImageWithRotation(); this.ctx.restore();

            this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(halfWidth,0,remainingWidth,halfHeight); this.ctx.clip();
            this.ctx.translate(width,0); this.ctx.scale(-1,1);
            this.ctx.translate(finalCenterX_TL, finalCenterY_TL); drawImageWithRotation(); this.ctx.restore();

            this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(0,halfHeight,halfWidth,remainingHeight); this.ctx.clip();
            this.ctx.translate(0,height); this.ctx.scale(1,-1);
            this.ctx.translate(finalCenterX_TL, finalCenterY_TL); drawImageWithRotation(); this.ctx.restore();

            this.ctx.save(); this.ctx.beginPath(); this.ctx.rect(halfWidth,halfHeight,remainingWidth,remainingHeight); this.ctx.clip();
            this.ctx.translate(width,height); this.ctx.scale(-1,-1);
            this.ctx.translate(finalCenterX_TL, finalCenterY_TL); drawImageWithRotation(); this.ctx.restore();

            this.ctx.globalAlpha = 1.0;
            this.isDrawing = false;
            return true;
        } catch (e) {
            if (import.meta.env.DEV) {
                console.error(`${logPrefix} Unexpected draw error:`, e);
            }
            this.isDrawing = false;
            return false;
        }
    }

    /**
     * Updates the drift state (position and phase) based on configuration and delta time.
     * @param {object} config - The current layer configuration containing drift settings.
     * @param {number} deltaTime - The smoothed time elapsed since the last frame in seconds.
     */
    updateDrift(config, deltaTime) {
        if (!config?.driftState) return;
        const {driftState} = config;
        const driftAmount = config.drift ?? 0;
        const driftSpeed = config.driftSpeed ?? 0.1;

        if(driftAmount > 0 && driftState.enabled){
            if(typeof driftState.phase !== "number" || isNaN(driftState.phase)) {
                driftState.phase = Math.random() * Math.PI * 2;
            }
            driftState.phase += deltaTime * driftSpeed * 1.0;
            const calculatedX = Math.sin(driftState.phase) * driftAmount * 1.5;
            const calculatedY = Math.cos(driftState.phase * 0.7 + Math.PI / 4) * driftAmount * 1.5;
            driftState.x = Math.max(-MAX_TOTAL_OFFSET / 2, Math.min(MAX_TOTAL_OFFSET / 2, calculatedX));
            driftState.y = Math.max(-MAX_TOTAL_OFFSET / 2, Math.min(MAX_TOTAL_OFFSET / 2, calculatedY));
        } else {
            driftState.x = 0;
            driftState.y = 0;
        }
    }

    /**
     * The main animation loop callback function.
     * @param {number} timestamp - The timestamp provided by requestAnimationFrame.
     */
    animationLoop(timestamp) {
        if (this.isDestroyed || this.animationFrameId === null) return;
        this.animationFrameId = requestAnimationFrame(this.animationLoop);

        if (!this.config.enabled) { return; }

        if (!this.lastTimestamp) this.lastTimestamp = timestamp;
        const elapsed = timestamp - this.lastTimestamp;
        this.lastTimestamp = timestamp;
        const rawDeltaTime = Math.max(0.001, elapsed / 1000.0);

        this.deltaTimeBuffer.push(rawDeltaTime);
        if (this.deltaTimeBuffer.length > DELTA_TIME_BUFFER_SIZE) { this.deltaTimeBuffer.shift(); }
        this.smoothedDeltaTime = this.deltaTimeBuffer.reduce((a,b) => a+b,0) / this.deltaTimeBuffer.length;

        if (this.lastValidWidth <= 0 || this.lastValidHeight <= 0 || !this.canvas || !this.ctx) {
            this.setupCanvas().then(setupOk => {
                if (setupOk && this.config.enabled) this.draw(timestamp, this.config);
            });
            return;
        }

        if (!this.image?.complete || this.image?.naturalWidth === 0) { return; }

        const now = performance.now();
        this.xInterpolator?.update(now);
        this.yInterpolator?.update(now);
        this.angleInterpolator?.update(now);

        const speed = this.config.speed ?? 0;
        const direction = this.config.direction ?? 1;
        const angleDelta = speed * direction * this.smoothedDeltaTime * 600;
        this.continuousRotationAngle = (this.continuousRotationAngle + angleDelta) % 360;

        this.draw(timestamp, this.config);
    }

    /**
     * Forces a single redraw of the canvas using the current or provided configuration.
     * @async
     * @param {object | null} [configToUse=null] - Optional config object. Defaults to current config.
     * @returns {Promise<boolean>} True if the redraw was successfully initiated.
     */
    async forceRedraw(configToUse = null) {
        if (this.isDestroyed || this.isDrawing) return false;
        return this.drawStaticFrame(configToUse || this.config);
    }

    /**
     * Cleans up resources: stops animation loop, releases references.
     */
    destroy() {
        this.isDestroyed = true;
        this.stopAnimationLoop();
        this.image = null;
        this.ctx = null;
        this.canvas = null;
        this.deltaTimeBuffer = [];
        this.xInterpolator = null;
        this.yInterpolator = null;
        this.angleInterpolator = null;
        this.lastDPR = 0;
        this.lastValidWidth = 0;
        this.lastValidHeight = 0;
        if (import.meta.env.DEV) {
            console.log(`[CM L${this.layerId}] Destroyed.`);
        }
    }
}
export default CanvasManager;
```

---
### `src\utils\debounce.js`
```js
// src/utils/debounce.js

/**
 * Creates a debounced function that delays invoking the provided function (`func`)
 * until `wait` milliseconds have elapsed since the last time the debounced function
 * was invoked. Useful for limiting the rate at which a function fires, e.g.,
 * on window resize or input events. The debounced function is invoked with the
 * arguments and `this` context of the last call.
 *
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay execution.
 * @returns {(...args: any[]) => void} The new debounced function.
 */
function debounce(func, wait) {
  /** @type {ReturnType<typeof setTimeout> | null} */
  let timeout = null;

  /**
   * The debounced version of the input function.
   * @param  {...any} args Arguments to pass to the original function.
   */
  return function executedFunction(...args) {
    // `this` context will be preserved from where `executedFunction` is called.
    const context = this;

    const later = () => {
      timeout = null; // Indicate debounce ended, allowing next call to set a new timeout
      func.apply(context, args); // Execute original function with preserved context and arguments
    };

    if (timeout !== null) {
      clearTimeout(timeout); // Clear previous timer if one was set
    }
    timeout = setTimeout(later, wait); // Set new timer
  };
}

export default debounce;
```

---
### `src\utils\erc725.js`
```js
// src/utils/erc725.js
import { getAddress, hexToString, decodeAbiParameters, parseAbiParameters } from 'viem';
import { ERC725YDataKeys } from '@lukso/lsp-smart-contracts';
import { Buffer } from 'buffer';

// Ensure Buffer is polyfilled in environments where it's not globally available (like browsers)
// This is often handled by build tools (like Vite/Webpack) based on configuration.
if (typeof window !== 'undefined' && typeof window.Buffer === 'undefined') {
  window.Buffer = Buffer;
}

const IPFS_GATEWAY = import.meta.env.VITE_IPFS_GATEWAY || 'https://api.universalprofile.cloud/ipfs/';

/**
 * @typedef {object} DecodedDataItem
 * @property {string} keyName - The original key name from the input.
 * @property {string} value - The original hex value from the input.
 */

/**
 * Decodes ERC725Y data items based on a schema hint.
 * Currently supports decoding the RadarWhitelist address array (both ABI-encoded and legacy JSON format).
 * Falls back to returning raw data items (keyName, value) for unknown schema hints or if decoding fails.
 *
 * @param {Array<{keyName: string, value: string}>} dataItems - Array of data items fetched from ERC725Y storage. Expected to contain the relevant key for the schemaHint.
 * @param {string} schemaHint - A hint indicating the expected schema (e.g., 'SupportedStandards:RadarWhitelist').
 * @returns {Array<string> | Array<DecodedDataItem>} Decoded data (e.g., array of addresses for RadarWhitelist) or the original items if decoding fails or hint is unknown. Returns an empty array if input is invalid or decoding yields no results.
 */
export function decodeData(dataItems, schemaHint) {
    if (!dataItems || !Array.isArray(dataItems) || dataItems.length === 0) return [];

    try {
        if (schemaHint === 'SupportedStandards:RadarWhitelist' && dataItems[0]?.value) {
            const rawData = dataItems[0].value;
            if (rawData && rawData !== '0x') {
                try {
                    // Try ABI decoding first (assuming address[])
                    const types = parseAbiParameters('address[]');
                    const decoded = decodeAbiParameters(types, /** @type {`0x${string}`} */ (rawData)); // Cast to satisfy viem
                    return decoded[0] || []; // Return the decoded array or empty if null/undefined
                } catch (abiError) {
                    if (import.meta.env.DEV) {
                        console.warn(`[decodeData] Failed ABI decode for ${schemaHint}. Trying JSON decode...`, abiError);
                    }
                    try {
                        // Fallback to JSON decoding for legacy format
                        const jsonString = hexToString(/** @type {`0x${string}`} */ (rawData)); // Cast to satisfy viem
                        const parsed = JSON.parse(jsonString);
                        if (Array.isArray(parsed)) {
                            // Assuming legacy format was [{address: '0x...'}, ...] or string array
                            return parsed.map(item => typeof item === 'string' ? item : item?.address).filter(Boolean);
                        } else {
                             if (import.meta.env.DEV) {
                                 console.warn(`[decodeData] Decoded JSON is not an array for ${schemaHint}.`);
                             }
                             return [];
                        }
                    } catch (jsonError) {
                        if (import.meta.env.DEV) {
                            console.error(`[decodeData] Failed both ABI and JSON decoding for ${schemaHint}:`, jsonError, 'Data:', rawData);
                        }
                        return []; // Return empty array on double failure
                    }
                }
            } else {
                return []; // Return empty array if rawData is empty or '0x'
            }
        }
        // If no specific logic for the schemaHint, return the raw items
        if (import.meta.env.DEV) {
            console.warn(`[decodeData] No specific decoding logic for schemaHint: ${schemaHint}. Returning raw items.`);
        }
        return dataItems.map(item => ({ keyName: item.keyName, value: item.value }));
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`[decodeData] Error decoding data for schema ${schemaHint}:`, error, 'Data:', dataItems);
        }
        return []; // Return empty array on general error
    }
}

/**
 * @typedef {object} ParsedDataUri
 * @property {string} mimeType - The MIME type of the data.
 * @property {boolean} isBase64 - True if the data is base64 encoded.
 * @property {string} data - The actual data payload.
 */

/**
 * Parses a Data URI string into its components: mime type, base64 encoding status, and data payload.
 * Follows the standard Data URI format (RFC 2397).
 *
 * @param {string} uri - The Data URI string (e.g., "data:application/json;base64,eyJ...").
 * @returns {ParsedDataUri} An object containing the parsed components.
 * @throws {Error} If the input string is not a valid Data URI format.
 */
function parseDataUri(uri) {
    if (typeof uri !== 'string' || !uri.startsWith('data:')) {
        throw new Error('Invalid Data URI: input is not a string or does not start with "data:"');
    }
    const commaIndex = uri.indexOf(',');
    if (commaIndex === -1) {
        throw new Error('Invalid Data URI: missing comma separator');
    }
    // Extract the part between "data:" and ","
    const metaPart = uri.substring(5, commaIndex).trim();
    // Extract the part after ","
    const dataPart = uri.substring(commaIndex + 1);

    const metaParts = metaPart.split(';');
    // The first part is the mime type, default if empty
    const mimeType = metaParts[0] || 'text/plain;charset=US-ASCII';
    // Check if "base64" is present in the other parts
    const isBase64 = metaParts.slice(1).includes('base64');

    return { mimeType, isBase64, data: dataPart };
}


/**
 * Fetches and resolves LSP4 Metadata for a given asset contract address.
 * Handles VerifiableURI decoding (including Data URIs and plain URLs), IPFS URL resolution via a gateway,
 * and extracts the primary metadata object. Uses the provided ConfigurationService
 * instance for blockchain reads. It attempts to handle both standard VerifiableURI format
 * and direct URL storage in the LSP4Metadata key.
 *
 * @async
 * @param {import('../services/ConfigurationService').default} configService - An initialized instance of ConfigurationService.
 * @param {string} contractAddress - The address of the LSP7/LSP8 asset.
 * @returns {Promise<object | null>} - The parsed LSP4Metadata object (potentially wrapped in an {LSP4Metadata: ...} object if fetched directly) or null if not found or an error occurred.
 */
export async function resolveLsp4Metadata(configService, contractAddress) {
    let checksummedAddress;
    try {
        checksummedAddress = getAddress(contractAddress);
    } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`[resolveLsp4Metadata Addr:${contractAddress}] Invalid address format. Error: ${e.message}`);
        }
        return null;
    }
    const logPrefix = `[resolveLsp4Metadata Addr:${checksummedAddress.slice(0, 6)}]`;

    if (!configService || typeof configService.loadDataFromKey !== 'function') {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} Invalid or missing configService.`);
        }
        return null;
    }

    try {
        const lsp4Key = ERC725YDataKeys.LSP4.LSP4Metadata;
        const rawValue = await configService.loadDataFromKey(checksummedAddress, lsp4Key);

        if (!rawValue || rawValue === '0x') {
            return null; // No metadata key set or empty
        }

        let potentialUrl = null;
        let extractedJsonDirectly = null;
        const VERIFIABLE_URI_PREFIX = "0x0000";
        const HASH_FUNCTION_ID_LENGTH_BYTES = 4;
        const HASH_LENGTH_BYTES_LENGTH = 2;

        // const DATA_URI_HEX_PREFIX_RAW = Buffer.from('data:').toString('hex'); // Not used in this revised logic

        if (rawValue.startsWith(VERIFIABLE_URI_PREFIX)) {
            const valueWithoutPrefix = rawValue.substring(VERIFIABLE_URI_PREFIX.length);
            // const hashFunctionIdHex = `0x${valueWithoutPrefix.substring(0, HASH_FUNCTION_ID_LENGTH_BYTES * 2)}`; // This was unused
            const hashLengthHex = `0x${valueWithoutPrefix.substring(HASH_FUNCTION_ID_LENGTH_BYTES * 2, (HASH_FUNCTION_ID_LENGTH_BYTES + HASH_LENGTH_BYTES_LENGTH) * 2)}`;
            const hashLength = parseInt(hashLengthHex, 16);

            if (!isNaN(hashLength)) {
                const hashStart = (HASH_FUNCTION_ID_LENGTH_BYTES + HASH_LENGTH_BYTES_LENGTH) * 2;
                const hashEnd = hashStart + hashLength * 2;
                const urlBytesHex = `0x${valueWithoutPrefix.substring(hashEnd)}`;

                try {
                    potentialUrl = hexToString(/** @type {`0x${string}`} */ (urlBytesHex));
                } catch (e) {
                    if (import.meta.env.DEV) {
                        console.warn(`${logPrefix} Failed to decode URL part of VerifiableURI: ${e.message}. Raw URL bytes: ${urlBytesHex}`);
                    }
                }
            } else if (import.meta.env.DEV) {
                console.warn(`${logPrefix} Invalid hash length in VerifiableURI.`);
            }
        } else {
            try {
                const decodedEntireValue = hexToString(/** @type {`0x${string}`} */ (rawValue));
                if (decodedEntireValue.startsWith('ipfs://') || decodedEntireValue.startsWith('http')) {
                    potentialUrl = decodedEntireValue;
                } else if (decodedEntireValue.startsWith('data:')) {
                    try {
                        const { mimeType, isBase64, data } = parseDataUri(decodedEntireValue);
                        if (mimeType.includes('json')) {
                            const jsonDataString = isBase64 ? Buffer.from(data, 'base64').toString('utf8') : decodeURIComponent(data);
                            extractedJsonDirectly = JSON.parse(jsonDataString);
                        } else if (import.meta.env.DEV) {
                            console.warn(`${logPrefix} Data URI has non-JSON mime type: ${mimeType}. Ignoring content.`);
                        }
                    } catch (e) {
                        if (import.meta.env.DEV) {
                            console.error(`${logPrefix} Failed to decode/parse Data URI content from direct value: ${e.message}`);
                        }
                    }
                } else if (import.meta.env.DEV) {
                    console.warn(`${logPrefix} Direct decode of raw value is not a standard URL or Data URI.`);
                }
            } catch (e) {
                if (import.meta.env.DEV) {
                    console.warn(`${logPrefix} Could not decode entire raw value as string. Raw: ${rawValue.substring(0, 50)}... Error: ${e.message}`);
                }
            }
        }


        if (extractedJsonDirectly) {
            if (extractedJsonDirectly.LSP4Metadata) {
                 return extractedJsonDirectly;
            } else if (extractedJsonDirectly.name || extractedJsonDirectly.icon || extractedJsonDirectly.images || extractedJsonDirectly.assets) {
                 if (import.meta.env.DEV) {
                     console.warn(`${logPrefix} JSON from Data URI lacks 'LSP4Metadata' key, wrapping content.`);
                 }
                 return { LSP4Metadata: extractedJsonDirectly };
            } else {
                 if (import.meta.env.DEV) {
                     console.error(`${logPrefix} JSON from Data URI has unexpected structure.`, extractedJsonDirectly);
                 }
                 return null;
            }
        }

        if (potentialUrl) {
            let fetchUrl = potentialUrl;
            if (fetchUrl.startsWith('ipfs://')) {
                fetchUrl = `${IPFS_GATEWAY.endsWith('/') ? IPFS_GATEWAY : IPFS_GATEWAY + '/'}${fetchUrl.substring(7)}`;
            }

            if (!fetchUrl.startsWith('http')) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Invalid fetch URL derived: ${fetchUrl}`);
                }
                return null;
            }

            try {
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    const errorText = await response.text().catch(() => 'Could not read error response body');
                    throw new Error(`HTTP error! status: ${response.status} for ${fetchUrl}. Body: ${errorText.substring(0, 200)}`);
                }
                const rawResponseText = await response.text();
                let metadata;
                try {
                    metadata = JSON.parse(rawResponseText);
                } catch (parseError) {
                    if (import.meta.env.DEV) {
                        console.error(`${logPrefix} Failed to parse JSON response from ${fetchUrl}. Error: ${parseError.message}. Response text (truncated): ${rawResponseText.substring(0, 200)}...`);
                    }
                    throw new Error(`JSON Parse Error: ${parseError.message}`);
                }

                if (metadata && metadata.LSP4Metadata) {
                    return metadata;
                } else if (metadata && (metadata.name || metadata.icon || metadata.images || metadata.assets)) {
                    if (import.meta.env.DEV) {
                        console.warn(`${logPrefix} Fetched JSON lacks 'LSP4Metadata' key, wrapping content.`);
                    }
                    return { LSP4Metadata: metadata };
                } else {
                    if (import.meta.env.DEV) {
                        console.warn(`${logPrefix} Fetched JSON from URL has unexpected structure.`, metadata);
                    }
                    return null;
                }
            } catch (fetchError) {
                if (import.meta.env.DEV) {
                    console.error(`${logPrefix} Failed to fetch or parse LSP4 JSON from ${fetchUrl}:`, fetchError.message);
                }
                return null;
            }
        }

        if (import.meta.env.DEV) {
            console.warn(`${logPrefix} Could not extract a valid JSON URL or parse JSON directly from LSP4Metadata value.`);
        }
        return null;

    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`${logPrefix} General error resolving LSP4 Metadata:`, error);
        }
        return null;
    }
}
```

---
### `src\utils\forceCanvasVisibility.js`
```js
// src/utils/forceCanvasVisibility.js

/**
 * Utility function primarily for debugging rendering issues. It attempts to force
 * all managed canvas elements to be visible by directly manipulating their styles
 * and triggering a redraw. It then checks a center pixel on each canvas to determine
 * if it likely has content rendered and logs the state.
 *
 * Note: This manipulates styles directly and performs synchronous checks,
 * which might not reflect the final state after asynchronous operations or CSS transitions.
 * Use primarily for diagnosing situations where canvases might be unexpectedly hidden or empty.
 *
 * @param {Object.<string, import('./CanvasManager').default>} managers - An object mapping layer IDs to their corresponding CanvasManager instances.
 * @returns {boolean} - True if all checked canvases appear to have content, false otherwise.
 */
export function forceCanvasVisibility(managers) {
  if (!managers || typeof managers !== 'object') {
    if (import.meta.env.DEV) {
        console.warn("[forceCanvasVisibility] No managers provided.");
    }
    return false;
  }

  const managerEntries = Object.entries(managers);
  if (managerEntries.length === 0) {
    if (import.meta.env.DEV) {
        console.warn("[forceCanvasVisibility] Empty managers object.");
    }
    return false;
  }

  let allHaveContent = true;

  managerEntries.forEach(([layerId, manager]) => {
    if (!manager) {
      if (import.meta.env.DEV) {
        console.warn(`[forceCanvasVisibility] Missing manager for layer ${layerId}`);
      }
      allHaveContent = false;
      return; // Skip to next manager
    }

    const canvas = manager.canvas;
    if (!canvas) {
      if (import.meta.env.DEV) {
        console.warn(`[forceCanvasVisibility] Missing canvas for layer ${layerId}`);
      }
      allHaveContent = false;
      return; // Skip to next manager
    }

    // Apply styles directly to attempt making canvas visible
    // This is a debugging aid and overrides normal styling.
    if (canvas.style) {
      canvas.style.opacity = "1";
      canvas.style.display = "block"; // Ensure it's not display:none
      canvas.style.visibility = "visible";
      // Forcing position might interfere with layout, use with caution or make conditional
      // canvas.style.position = "absolute";
      // canvas.style.top = "0";
      // canvas.style.left = "0";
      // canvas.style.width = "100%"; // Or specific debug dimensions
      // canvas.style.height = "100%"; // Or specific debug dimensions
      canvas.classList.remove('hidden'); // Assuming 'hidden' class controls display:none or visibility
      canvas.classList.add('visible');   // Assuming 'visible' class ensures visibility

      // Styling parent might be too intrusive for a generic debug utility
      // if (canvas.parentElement) {
      //   canvas.parentElement.style.position = "relative";
      //   canvas.parentElement.style.width = "100%";
      //   canvas.parentElement.style.height = "100%";
      //   canvas.parentElement.style.overflow = "visible";
      // }
    }

    // Trigger a redraw and check content
    if (manager.image && manager.image.complete && typeof manager.draw === "function") {
      // Use drawStaticFrame if available for better consistency, otherwise fallback to draw
      const drawFn = typeof manager.drawStaticFrame === 'function' ? manager.drawStaticFrame : manager.draw;
      // Ensure the draw function is called with the manager's context.
      // drawStaticFrame is async, but for this debug tool, we might not await it.
      // If drawStaticFrame needs to be awaited, this function should be async.
      drawFn.call(manager, manager.config || {}); // Pass current config or an empty object

      try {
        const ctx = canvas.getContext('2d');
        if (ctx) {
          const width = canvas.width;
          const height = canvas.height;
          if (width > 0 && height > 0) {
            const centerX = Math.floor(width / 2);
            const centerY = Math.floor(height / 2);
            const imageData = ctx.getImageData(centerX, centerY, 1, 1).data;
            // Check if pixel is not fully transparent black
            const hasContent = !(imageData[0] === 0 && imageData[1] === 0 && imageData[2] === 0 && imageData[3] === 0);

            if (import.meta.env.DEV) {
                // Keep the detailed log for debugging canvas state
                console.log(`[forceCanvasVisibility] Layer ${layerId}: Size: ${width}x${height}, CenterPixel: [${imageData.join(',')}], HasContent: ${hasContent}`);
            }

            if (!hasContent) {
              allHaveContent = false;
            }
          } else {
            if (import.meta.env.DEV) {
                console.warn(`[forceCanvasVisibility] Layer ${layerId} has zero dimensions: ${width}x${height}`);
            }
            allHaveContent = false;
          }
        } else {
           if (import.meta.env.DEV) {
               console.warn(`[forceCanvasVisibility] Could not get 2D context for layer ${layerId}`);
           }
           allHaveContent = false;
        }
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`[forceCanvasVisibility] Error checking canvas ${layerId}:`, e);
        }
        allHaveContent = false;
      }
    } else {
      if (import.meta.env.DEV) {
        console.warn(`[forceCanvasVisibility] Layer ${layerId} missing image, image not complete, or draw method not available.`);
      }
      allHaveContent = false;
    }
  });

  if (import.meta.env.DEV) {
    // Keep final summary log
    console.log(`[forceCanvasVisibility] Final result: allHaveContent=${allHaveContent}`);
  }
  return allHaveContent;
}
```

---
### `src\utils\globalAnimationFlags.js`
```js
// src/utils/globalAnimationFlags.js

/**
 * @file Holds global flags that can be imperatively set to influence animation decisions.
 * Use with extreme caution and only for critical and very hard-to-solve race conditions
 * that are caused, in this case, by an initial image loading burst or similar complex UI interactions
 * where declarative state flow is insufficient or overly complex to manage.
 *
 * These flags are intended as a last resort. Prefer managing animation states through
 * React's declarative state and props model whenever possible.
 */

/**
 * @typedef {object} GlobalAnimationFlags
 * @property {boolean} isTokenSelectorOpening - Set to `true` when the token selector UI component
 * is in the process of opening or is open. This can be used by animation managers
 * (e.g., `useAnimationLifecycleManager`) to ensure animations continue or restart
 * if they were paused due to other conditions (like visibility changes) that might
 * incorrectly stop animations needed for the token selector's presentation.
 * Should be reset to `false` when the token selector is closed or its opening animation completes.
 */

/**
 * Global animation flags.
 * @type {GlobalAnimationFlags}
 */
export const globalAnimationFlags = {
  isTokenSelectorOpening: false,
};
```

---
### `src\utils\helpers.js`
```js
// src/utils/helpers.js

/**
 * Scales a normalized value (expected to be between 0 and 1) to a specified
 * minimum and maximum range using linear interpolation.
 * Handles potential non-numeric inputs gracefully by attempting to convert them
 * to numbers and returning the minimum of the range if any input is invalid.
 * The normalized input value is clamped to the [0, 1] range before scaling.
 *
 * @param {number|string} normalizedValue - The input value, ideally between 0 and 1.
 * @param {number|string} min - The minimum value of the target range.
 * @param {number|string} max - The maximum value of the target range.
 * @returns {number} The scaled value, clamped to be within the [min, max] range.
 *                   Returns `min` (or 0 if `min` is also NaN) if any input is non-numeric.
 */
export const scaleNormalizedValue = (normalizedValue, min, max) => {
  const norm = Number(normalizedValue);
  const minimum = Number(min);
  const maximum = Number(max);

  // Check for invalid inputs
  if (isNaN(norm) || isNaN(minimum) || isNaN(maximum)) {
    if (import.meta.env.DEV) {
      console.warn(`[scaleNormalizedValue] Invalid input: normalizedValue=${normalizedValue}, min=${min}, max=${max}. Returning minimum.`);
    }
    // Return the numerical minimum if valid, otherwise 0 as a fallback.
    return isNaN(minimum) ? 0 : minimum;
  }

  // Clamp the normalized value to the 0-1 range to ensure correct scaling
  const clampedNorm = Math.max(0, Math.min(1, norm));

  // Perform the linear interpolation: result = min + (normalized_clamped * (max - min))
  const scaledValue = minimum + clampedNorm * (maximum - minimum);

  // Ensure the final result is also clamped within the min/max of the target range,
  // especially if min > max was provided (though logically incorrect, this handles it).
  if (minimum <= maximum) {
    return Math.max(minimum, Math.min(maximum, scaledValue));
  } else {
    // If min > max, the range is inverted. Clamp accordingly.
    return Math.max(maximum, Math.min(minimum, scaledValue));
  }
};
```

---
### `src\utils\helpers.test.js`
```js
// src/utils/helpers.test.js
import { describe, it, expect } from 'vitest';
import { scaleNormalizedValue } from './helpers';

describe('scaleNormalizedValue', () => {
  it('should correctly scale a value within the 0-1 range', () => {
    // Arrange
    const normalizedValue = 0.5;
    const min = 10;
    const max = 20;
    const expected = 15;

    // Act
    const result = scaleNormalizedValue(normalizedValue, min, max);

    // Assert
    expect(result).toBe(expected);
  });

  it('should clamp to min if normalizedValue is less than 0', () => {
    expect(scaleNormalizedValue(-0.5, 10, 20)).toBe(10);
  });

  it('should clamp to max if normalizedValue is greater than 1', () => {
    expect(scaleNormalizedValue(1.5, 10, 20)).toBe(20);
  });

  it('should handle min and max being the same', () => {
    expect(scaleNormalizedValue(0.5, 10, 10)).toBe(10);
  });

  it('should handle string inputs that are valid numbers', () => {
    expect(scaleNormalizedValue('0.25', '0', '100')).toBe(25);
  });

  it('should return min if inputs are NaN', () => {
    expect(scaleNormalizedValue('abc', 10, 20)).toBe(10);
    expect(scaleNormalizedValue(0.5, 'xyz', 20)).toBe(0); // min is NaN, defaults to 0
    expect(scaleNormalizedValue(0.5, 10, 'pqr')).toBe(10); // max is NaN, but min is valid
  });

  it('should handle inverted min/max range by clamping correctly', () => {
    expect(scaleNormalizedValue(0.5, 20, 10)).toBe(15); // Midpoint
    expect(scaleNormalizedValue(0, 20, 10)).toBe(20);   // Should be clamped to the "actual" min (which is 10 here)
    expect(scaleNormalizedValue(1, 20, 10)).toBe(10);   // Should be clamped to the "actual" max (which is 20 here)
  });
});
```

---
### `src\utils\performanceHelpers.js`
```js
// src/utils/performanceHelpers.js

/** @type {ReturnType<typeof setTimeout> | null} */
let dimmingTimerId = null; // Hold the timer ID for the dimming effect

/**
 * Adds/Removes a class to a target element to indicate an overlay is active,
 * typically used to dim or slightly de-emphasize background content.
 * This version is simplified to only manage class toggling and avoid
 * interfering with animation/transition properties of other elements.
 *
 * @param {number} [duration=300] - How long the class should be applied in milliseconds.
 * @param {object} [options={}] - Configuration options.
 * @param {string} [options.className='overlay-animating'] - The class to add/remove.
 * @param {string} [options.selector='.main-view'] - The selector for the target element.
 * @param {boolean} [options.debug=false] - Enable debug logging for this specific utility. General dev logs use `import.meta.env.DEV`.
 * @returns {() => void} - A function that can be called to cancel the dimming effect early and remove the class.
 */
export const manageOverlayDimmingEffect = (duration = 300, options = {}) => {
  const {
    className = 'overlay-animating',
    selector = '.main-view',
    debug = false // Note: This 'debug' flag is specific to this util.
  } = options;

  const target = document.querySelector(selector);

  if (!target) {
    if (debug && import.meta.env.DEV) { // Conditional logging
        console.warn(`[manageOverlayDimmingEffect] Could not find element matching selector "${selector}"`);
    }
    return () => {}; // Return a no-op function if target not found
  }

  // Clear any existing timer for this effect
  if (dimmingTimerId) {
    clearTimeout(dimmingTimerId);
    dimmingTimerId = null;
  }

  // Add class if not already present
  if (!target.classList.contains(className)) {
    if (debug && import.meta.env.DEV) { // Conditional logging
        console.log(`[manageOverlayDimmingEffect] Adding class '${className}' to element matching '${selector}'.`);
    }
    target.classList.add(className);
  }

  // Set timer to remove the class after the specified duration
  dimmingTimerId = setTimeout(() => {
    if (debug && import.meta.env.DEV) { // Conditional logging
        console.log(`[manageOverlayDimmingEffect] Duration elapsed. Removing class '${className}' from element matching '${selector}'.`);
    }
    if(target.classList.contains(className)) { // Check if class still exists before removing
        target.classList.remove(className);
    }
    dimmingTimerId = null; // Clear timer ID after execution
  }, duration);

  // Return a cleanup function to cancel the effect early
  return () => {
    if (debug && import.meta.env.DEV) { // Conditional logging
        console.log(`[manageOverlayDimmingEffect] Manually canceled. Removing class '${className}'.`);
    }
    if (dimmingTimerId) {
      clearTimeout(dimmingTimerId);
      dimmingTimerId = null;
    }
    // Ensure class is removed if the cancel function is called
    if (target.classList.contains(className)) {
        target.classList.remove(className);
    }
  };
};

/**
 * Creates a "rested" `requestAnimationFrame` (RAF) callback that waits for a specified
 * number of animation frames before executing the provided callback function.
 * This can be useful to allow the browser to complete other rendering tasks or "catch up"
 * before performing an animation or update.
 *
 * @param {() => void} callback - The function to execute after the specified frame count.
 * @param {number} [frameCount=2] - Number of animation frames to wait before executing the callback (1-3 recommended for responsiveness).
 * @returns {number | null} - The ID returned by `requestAnimationFrame`, which can be used with `cancelAnimationFrame` to cancel the "rested" RAF. Returns `null` if `requestAnimationFrame` is not supported (should not happen in modern browsers).
 */
export const restfulRAF = (callback, frameCount = 2) => {
  /** @type {number} */
  let currentFrame = 0;
  /** @type {number | null} */
  let rafId = null;

  const rafLoop = () => {
    currentFrame++;
    if (currentFrame >= frameCount) {
      callback();
      // rafId is implicitly null after callback if not re-assigned, or loop ends.
    } else {
      if (typeof requestAnimationFrame === 'function') {
        rafId = requestAnimationFrame(rafLoop);
      } else if (import.meta.env.DEV) {
        // This case should be extremely rare in modern environments.
        console.warn("[restfulRAF] requestAnimationFrame is not supported. Callback will not be executed.");
      }
    }
  };

  if (typeof requestAnimationFrame === 'function') {
    rafId = requestAnimationFrame(rafLoop);
  } else if (import.meta.env.DEV) {
    console.warn("[restfulRAF] requestAnimationFrame is not supported. Callback will not be scheduled.");
  }
  return rafId;
};
```

---
### `src\utils\ValueInterpolator.js`
```js
// src/utils/ValueInterpolator.js

/**
 * Performs linear interpolation between two values.
 * @param {number} start - The starting value.
 * @param {number} end - The ending value.
 * @param {number} t - The interpolation factor (0.0 to 1.0).
 * @returns {number} The interpolated value.
 */
const lerp = (start, end, t) => start * (1 - t) + end * t;

/**
 * Provides smooth linear interpolation between numerical values over a specified duration.
 * Useful for animating properties like position or angle towards a target value
 * instead of instantly snapping to it.
 */
class ValueInterpolator {
    /** @type {number} The current, possibly interpolated, value. */
    currentValue;
    /** @type {number} The target value towards which interpolation is occurring. */
    targetValue;
    /** @type {number} The value at the start of the current interpolation. */
    startValue;
    /** @type {number} The duration of the interpolation in milliseconds. */
    duration;
    /** @type {number} The timestamp (from `performance.now()`) when the current interpolation started. */
    startTime = 0;
    /** @type {boolean} Flag indicating if an interpolation is currently in progress. */
    isInterpolating = false;
    /** @type {number} A small tolerance value for floating-point comparisons to determine if values are "close enough". */
    epsilon;

    /**
     * Creates a new ValueInterpolator instance.
     * @param {number} initialValue - The starting value.
     * @param {number} [duration=150] - The duration of the interpolation in milliseconds. Must be non-negative.
     * @param {number} [epsilon=1e-5] - A small value for float comparison tolerance.
     */
    constructor(initialValue, duration = 150, epsilon = 1e-5) {
        this.currentValue = initialValue;
        this.targetValue = initialValue;
        this.startValue = initialValue;
        this.duration = Math.max(0, duration); // Ensure duration is not negative
        this.epsilon = epsilon;
    }

    /**
     * Starts or updates the interpolation towards a new target value.
     * If the new target is very close to the current value and no interpolation is active,
     * it will snap to the target. If already interpolating towards a very similar target,
     * the current interpolation continues.
     * @param {number} newTargetValue - The target value to interpolate towards.
     */
    setTarget(newTargetValue) {
        if (typeof newTargetValue !== 'number' || isNaN(newTargetValue)) {
            if (import.meta.env.DEV) {
                console.warn(`[ValueInterpolator] Invalid newTargetValue (${newTargetValue}). Snapping to current value or 0.`);
            }
            // Snap to current valid value or 0 if current is also invalid
            this.snap(typeof this.currentValue === 'number' && !isNaN(this.currentValue) ? this.currentValue : 0);
            return;
        }

        // If not currently interpolating and already effectively at the new target, snap for exactness and exit.
        if (!this.isInterpolating && Math.abs(this.currentValue - newTargetValue) < this.epsilon) {
            if (this.currentValue !== newTargetValue) { // Ensure exactness if within epsilon but not identical
                 this.snap(newTargetValue);
            }
            return;
        }

        // If already interpolating towards this exact (or very close) target, let it continue.
        // This prevents restarting the interpolation unnecessarily if setTarget is called multiple times with the same target.
        if (this.isInterpolating && Math.abs(this.targetValue - newTargetValue) < this.epsilon) {
            return;
        }

        // If current value is already effectively the new target (e.g., after a previous snap or completed interpolation),
        // but a new, slightly different target is set (or we weren't interpolating), snap to ensure exactness.
        if (Math.abs(this.currentValue - newTargetValue) < this.epsilon) {
            this.snap(newTargetValue); // Snap ensures isInterpolating is false and values are exact.
            return; // No new interpolation needed if already at the target.
        }

        // Start a new interpolation
        this.startValue = this.currentValue;
        this.targetValue = newTargetValue;
        this.startTime = performance.now();
        this.isInterpolating = true;
    }

    /**
     * Immediately sets the current and target value, stopping any ongoing interpolation.
     * @param {number} newValue - The value to snap to.
     */
    snap(newValue) {
        if (typeof newValue !== 'number' || isNaN(newValue)) {
            if (import.meta.env.DEV) {
                console.warn(`[ValueInterpolator] Invalid snap value (${newValue}). Current value or 0 will be used.`);
            }
            const fallbackValue = (typeof this.currentValue === 'number' && !isNaN(this.currentValue)) ? this.currentValue : 0;
            // Only update if necessary to avoid redundant operations
            if (this.isInterpolating || this.currentValue !== fallbackValue || this.targetValue !== fallbackValue) {
                this.currentValue = fallbackValue;
                this.targetValue = fallbackValue;
                this.startValue = fallbackValue; // Align startValue as well
                this.isInterpolating = false;
            }
            return;
        }

        // If not interpolating and already at the exact snap value (and target is aligned), do nothing.
        if (!this.isInterpolating && this.currentValue === newValue && this.targetValue === newValue) {
            return;
        }

        // Snap values and stop interpolation.
        this.currentValue = newValue;
        this.targetValue = newValue;
        this.startValue = newValue; // Align startValue for consistency
        this.isInterpolating = false;
    }

    /**
     * Updates the internal `currentValue` based on the elapsed time since interpolation started.
     * If interpolation is not active, it returns the current value without changes.
     * @param {number} currentTime - The current timestamp (e.g., from `performance.now()`).
     * @returns {number} The updated `currentValue`.
     */
    update(currentTime) {
        if (!this.isInterpolating) {
            return this.currentValue;
        }

        const elapsed = currentTime - this.startTime;
        // Calculate progress, ensuring it's between 0 and 1.
        // If duration is 0, progress is immediately 1 (snap to target).
        let progress = this.duration > 0 ? Math.min(1, Math.max(0, elapsed / this.duration)) : 1;

        // Easing function can be applied here if desired (e.g., ease-out, ease-in-out)
        // For now, using linear progress.
        const easedProgress = progress;

        this.currentValue = lerp(this.startValue, this.targetValue, easedProgress);

        // If interpolation is complete
        if (progress >= 1) {
            this.currentValue = this.targetValue; // Ensure exact target value is set
            this.isInterpolating = false;
        }
        return this.currentValue;
    }

    /**
     * Gets the current interpolated value without performing an update.
     * @returns {number} The current value.
     */
    getCurrentValue() {
        return this.currentValue;
    }

    /**
     * Checks if the value is currently undergoing interpolation.
     * @returns {boolean} True if interpolating, false otherwise.
     */
    isCurrentlyInterpolating() {
        return this.isInterpolating;
    }
}

export default ValueInterpolator;
```

---
### `src\utils\VisualEffectsProcessor.js`
```js
// src/utils/VisualEffectsProcessor.js
import EffectFactory from "../effects/EffectFactory"; // Local dependency

/**
 * @typedef {object} EffectConfigInput
 * @property {string} [type] - The type identifier of the effect (e.g., 'color_overlay'). If not provided and `effect` is, `effect` will be used. Defaults to 'color_overlay' if neither is present.
 * @property {string} [effect] - Alternative key for effect type, for backward compatibility.
 * @property {string | number} layer - The target layer ID ('global', 1, 2, or 3).
 * @property {object} [config] - Effect-specific configuration options (e.g., color, duration).
 * @property {string} [effectId] - Optional unique ID; one will be generated by the EffectFactory if not provided.
 * @property {boolean} [isPersistent=false] - Flag indicating if the effect should persist (currently placeholder for processor's internal state, actual persistence managed by consumer).
 * @property {boolean} [preserveAnimation=false] - Hint for whether background animations should be preserved when this effect is active.
 */

/**
 * @typedef {object} EffectControlAPI
 * @property {string} effectId - The unique ID of the applied effect instance.
 * @property {string | number} layer - The target layer of the effect.
 * @property {() => void} clear - Function to manually stop and clean up this specific effect instance.
 * @property {string} type - The type of the effect.
 * @property {object} [config] - The configuration used for this effect instance.
 */

/**
 * Manages the creation, application, and lifecycle of visual effects.
 * It uses an EffectFactory to instantiate specific effect classes and keeps track
 * of active effects, allowing them to be cancelled individually, by layer, or all at once.
 * It also provides a method to create default effects based on event types.
 */
class VisualEffectsProcessor {
  /** @type {Map<string, EffectControlAPI>} Stores active effect control objects, keyed by effectId. */
  activeEffects = new Map();

  constructor() {
    this.activeEffects = new Map();
  }

  /**
   * Creates, applies, and tracks a visual effect based on the provided configuration.
   * Automatically cancels any existing effects on the same target layer before applying the new one.
   * Sets a timeout to remove the effect from the active list after its duration (plus a buffer),
   * effectively making effects self-cleaning from this processor's perspective unless explicitly persistent.
   *
   * @param {EffectConfigInput} effectConfig - The configuration object for the effect.
   * @param {(layerId: string | number, key: string, value: any) => void | null} [updateLayerConfig] - Optional function potentially used by the effect to update layer configuration.
   * @returns {Promise<EffectControlAPI | null>} A promise resolving to the effect's control object or null if creation/application failed.
   */
  async processEffect(effectConfig, updateLayerConfig) {
    if (import.meta.env.DEV) {
        // console.log(`[VisualEffectsProcessor] ✅ Processing effect:`, effectConfig); // Keep this potentially useful log for debugging effects
    }

    // Handle potential variations in effect type key
    let type = effectConfig.type || effectConfig.effect; // 'effect' for backward compatibility
    if (!type) {
      if (import.meta.env.DEV) {
        console.warn("[VisualEffectsProcessor] No effect type specified, defaulting to color_overlay");
      }
      type = "color_overlay";
    }
    const finalEffectConfig = { ...effectConfig, type };


    // Cancel conflicting effects on the same layer before applying a new one
    // This ensures only one effect (of this processor's management) is active per layer at a time.
    const activeLayerEffects = Array.from(this.activeEffects.values()).filter(
      (e) => e.layer === finalEffectConfig.layer,
    );
    activeLayerEffects.forEach((activeEffect) => {
      if (activeEffect?.clear) {
        if (import.meta.env.DEV) {
            // console.log(`[VisualEffectsProcessor] Cancelling existing effect ${activeEffect.effectId} on layer ${finalEffectConfig.layer} due to new effect.`);
        }
        activeEffect.clear();
        this.activeEffects.delete(activeEffect.effectId);
      }
    });

    // Create and apply the new effect
    try {
        const effectInstance = EffectFactory.createEffect(finalEffectConfig.type, finalEffectConfig);
        const controlObject = effectInstance.apply(updateLayerConfig); // Pass update function

        if (controlObject?.effectId) {
            this.activeEffects.set(controlObject.effectId, controlObject);

            // Auto-cleanup entry from map after duration (+ buffer)
            // This makes effects "timed" by default from the processor's perspective.
            // Persistent effects would need to be managed/re-added by the consumer if they expire here.
            const duration = finalEffectConfig.config?.duration || 3000; // Default duration if not specified
            setTimeout(() => {
                // Only delete if it's still the same effect instance in the map.
                // This check is minor as clear() should handle its own state, but good for safety.
                if (this.activeEffects.get(controlObject.effectId) === controlObject) {
                    this.activeEffects.delete(controlObject.effectId);
                }
            }, duration + 1000); // Buffer allows for cleanup animations or effect finalization

            return controlObject;
        } else {
             if (import.meta.env.DEV) {
                console.warn("[VisualEffectsProcessor] Effect instance did not return a valid control object from apply().");
             }
             return null;
        }
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`[VisualEffectsProcessor] Error creating/applying effect type ${finalEffectConfig.type}:`, error);
        }
        return null;
    }
  }

  /**
   * Manually cancels and cleans up a specific active effect by its ID.
   * @param {string} effectId - The unique ID of the effect to cancel.
   * @returns {void}
   */
  cancelEffect(effectId) {
    const effectControl = this.activeEffects.get(effectId);
    if (effectControl?.clear) {
      try {
        effectControl.clear();
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`[VisualEffectsProcessor] Error during effectControl.clear() for ${effectId}:`, e);
        }
      }
    }
    // Always remove from map regardless of clear success to prevent stale entries
    this.activeEffects.delete(effectId);
  }

  /**
   * Manually cancels all active effects currently running on a specific layer.
   * @param {string|number} layer - The layer identifier ('global', 1, 2, or 3).
   * @returns {void}
   */
  cancelEffectsForLayer(layer) {
    const layerIdStr = String(layer); // Ensure comparison is consistent
    const effectsToCancelOnLayer = [];
    for (const [id, effectControl] of this.activeEffects.entries()) {
      if (effectControl?.layer?.toString() === layerIdStr) {
        effectsToCancelOnLayer.push(id);
      }
    }
    effectsToCancelOnLayer.forEach((id) => this.cancelEffect(id));
  }

  /**
   * Manually cancels and cleans up all currently active effects managed by this processor.
   * @returns {void}
   */
  cancelAllEffects() {
    // Iterate over a copy of keys because cancelEffect modifies the map
    const allEffectIds = Array.from(this.activeEffects.keys());
    allEffectIds.forEach((effectId) => {
      this.cancelEffect(effectId);
    });
    // Ensure the map is cleared, though cancelEffect should handle individual deletions.
    this.activeEffects.clear();
  }

  /**
   * Creates and processes a default visual effect based on a given event type string.
   * Maps common event types to predefined effect configurations (e.g., color overlays).
   * @param {string} eventType - The type of the event (e.g., 'lyx_received', 'token_sent').
   * @param {(layerId: string | number, key: string, value: any) => void | null} [updateLayerConfig] - Optional function potentially used by the effect.
   * @returns {Promise<EffectControlAPI | null>} A promise resolving to the effect's control object or null.
   */
  async createDefaultEffect(eventType, updateLayerConfig) {
    const eventLower = typeof eventType === "string" ? eventType.toLowerCase() : "";
    /** @type {EffectConfigInput | undefined} */
    let effectConfig;

    // Define default effect configurations based on event type
    if (eventLower.includes("lyx_received") || eventLower.includes("lyxreceived")) {
      effectConfig = { type: "color_overlay", layer: "1", preserveAnimation: true, config: { color: "rgba(255, 165, 0, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("lyx_sent") || eventLower.includes("lyxsent")) {
      effectConfig = { type: "color_overlay", layer: "2", preserveAnimation: true, config: { color: "rgba(0, 140, 255, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("token_received") || eventLower.includes("tokenreceived")) {
      effectConfig = { type: "color_overlay", layer: "1", preserveAnimation: true, config: { color: "rgba(0, 255, 140, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("token_sent") || eventLower.includes("tokensent")) {
      effectConfig = { type: "color_overlay", layer: "2", preserveAnimation: true, config: { color: "rgba(153, 51, 255, 0.3)", pulseCount: 3, duration: 3000 } };
    } else { // Default for unknown/other events
      effectConfig = { type: "color_overlay", layer: "3", preserveAnimation: true, config: { color: "rgba(255, 51, 153, 0.3)", pulseCount: 3, duration: 3000 } };
    }

    if (!effectConfig) { // Should not happen with the logic above, but as a safeguard
        if (import.meta.env.DEV) {
            console.warn(`[VisualEffectsProcessor] No default effect config determined for eventType: ${eventType}`);
        }
        return Promise.resolve(null);
    }
    return this.processEffect(effectConfig, updateLayerConfig);
  }

  /**
   * Gets the number of currently active effects being tracked by this processor.
   * @returns {number} The count of active effects.
   */
  getActiveEffectsCount() {
    return this.activeEffects.size;
  }

  /**
   * Gets an array containing the control objects of all currently active effects.
   * @returns {Array<EffectControlAPI>} An array of active effect control objects.
   */
  getActiveEffects() {
    return Array.from(this.activeEffects.values());
  }
}

export default VisualEffectsProcessor;
```

---
### `vite.config.js`
```js
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: { // Vitest configuration
    globals: true, // Allows using Vitest globals (describe, it, expect) without importing
    environment: 'jsdom', // Use JSDOM for testing React components
    setupFiles: './src/setupTests.js', // Your setup file
    css: true, // If you want to process CSS imports in tests
    env: { // Define environment variables for your tests
      DEV: 'true', // Makes import.meta.env.DEV available and true in tests
      // You can add other test-specific environment variables here
      // VITE_SOME_KEY: 'test_value' -> accessible as import.meta.env.VITE_SOME_KEY
    },
  },
});
```
