// src/hooks/useVisualEffects.js
import { useRef, useCallback, useEffect, useState, useMemo } from "react";

import VisualEffectsProcessor from "../utils/VisualEffectsProcessor"; // Local utility

/**
 * @typedef {object} EffectConfig Base structure for defining a visual effect.
 * @property {string} type - The type identifier of the effect (e.g., 'color_overlay').
 * @property {string | number} layer - The target layer ID ('global', 1, 2, or 3).
 * @property {object} [config] - Effect-specific configuration options (e.g., color, duration).
 * @property {string} [effectId] - Optional unique ID; one will be generated by the processor if not provided.
 * @property {boolean} [isPersistent=false] - Flag indicating if the effect should persist (currently a placeholder, as persistence logic is primarily managed by the consumer of this hook or a higher-level state).
 * @property {boolean} [preserveAnimation=false] - Hint for whether background animations should be preserved when this effect is active.
 */

/**
 * @typedef {object} EffectControlObject Object returned by the VisualEffectsProcessor after applying an effect.
 * @property {string} effectId - The unique ID of the applied effect instance.
 * @property {string | number} layer - The target layer of the effect.
 * @property {() => void} clear - Function to manually stop and clean up this specific effect instance.
 */

/**
 * @typedef {object} VisualEffectsAPI Interface provided by the useVisualEffects hook.
 * @property {(effectConfig: EffectConfig) => Promise<string | null>} processEffect - Processes and applies a given effect configuration using the internal `VisualEffectsProcessor`. Returns the effect ID on success, null on failure.
 * @property {(eventType: string) => Promise<string | null>} createDefaultEffect - Creates and applies a default visual effect based on an event type string, using the internal `VisualEffectsProcessor`. Returns the effect ID on success, null on failure.
 * @property {(effectId: string) => void} clearPersistentEffect - Clears a specific effect by its ID using the internal `VisualEffectsProcessor`. Also removes it from the local `persistentEffects` state if present.
 * @property {() => void} clearAllTimedEffects - Clears all currently active effects managed by the internal `VisualEffectsProcessor`.
 * @property {Object.<string, EffectConfig>} persistentEffects - State holding configurations of effects that were marked as persistent when processed. This state is primarily for informational purposes or for consumers to manage re-application if needed, as the hook itself doesn't automatically re-apply them.
 */

/**
 * Initializes and manages a `VisualEffectsProcessor` instance to handle the
 * creation, application, and cleanup of visual effects (like color overlays)
 * triggered by events or actions within the application. It provides functions
 * to process specific effect configurations or generate default effects based on event types.
 *
 * @param {(layerId: string | number, key: string, value: any) => void} [updateLayerConfig] - Optional: A function passed down from a configuration context, potentially used by some effects to modify layer properties directly. Current effects may not heavily rely on this.
 * @returns {VisualEffectsAPI} An object containing functions to manage visual effects.
 */
export function useVisualEffects(updateLayerConfig) {
  /** @type {React.RefObject<VisualEffectsProcessor | null>} */
  const processorRef = useRef(null);
  // State to potentially track persistent effects in the future
  /** @type {[Object.<string, EffectConfig>, React.Dispatch<React.SetStateAction<Object.<string, EffectConfig>>>]} */
  const [persistentEffects, setPersistentEffects] = useState({});
  /** @type {React.RefObject<(layerId: string | number, key: string, value: any) => void | undefined>} */
  const updateLayerConfigRef = useRef(updateLayerConfig);

  // Keep the updateLayerConfig function reference up-to-date
  useEffect(() => {
    updateLayerConfigRef.current = updateLayerConfig;
  }, [updateLayerConfig]);

  // Initialize and clean up the VisualEffectsProcessor instance
  useEffect(() => {
    processorRef.current = new VisualEffectsProcessor();
    if (import.meta.env.DEV) {
      // console.log("[useVisualEffects] VisualEffectsProcessor Initialized.");
    }

    const processorInstance = processorRef.current; // Capture instance for cleanup closure

    return () => {
      if (import.meta.env.DEV) {
        // console.log("[useVisualEffects] Cleaning up VisualEffectsProcessor...");
      }
      // Ensure we use the instance captured at the time of effect setup for cleanup,
      // as processorRef.current might be nulled by another effect run if deps change rapidly.
      const processorToClean = processorInstance;
      if (processorToClean && typeof processorToClean.cancelAllEffects === "function") {
        if (import.meta.env.DEV) {
          // console.log("[useVisualEffects] Calling cancelAllEffects on processor.");
        }
        processorToClean.cancelAllEffects();
      } else if (import.meta.env.DEV) {
        // Keep warning for potential cleanup issues
        console.warn("[useVisualEffects] VisualEffectsProcessor instance or cancelAllEffects method not available during cleanup.");
      }
      processorRef.current = null; // Explicitly nullify on unmount
    };
  }, []);

  /** Processes and applies a specific visual effect configuration. */
  const processEffect = useCallback(async (effectConfig) => {
    const currentProcessor = processorRef.current;
    const currentUpdateFn = updateLayerConfigRef.current;

    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects processEffect] Processor not ready.");
      }
      return null;
    }

    if (!effectConfig || (!effectConfig.type && !effectConfig.effect) || !effectConfig.layer) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects processEffect] Invalid effect object:", effectConfig);
      }
      return null;
    }

    const type = effectConfig.type || effectConfig.effect; // 'effect' for backward compatibility
    const layerId = String(effectConfig.layer);
    const isPersistent = effectConfig.isPersistent === true;
    // Processor now generates ID internally if not provided
    const fullConfig = { ...effectConfig, type: type, layer: layerId, isPersistent };


    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects processEffect] Processing effect:`, fullConfig);
    }
    try {
      const controlObject = await currentProcessor.processEffect(fullConfig, currentUpdateFn);
      if (controlObject?.effectId && isPersistent) {
        if (import.meta.env.DEV) {
          // console.log(`[useVisualEffects processEffect] Registered persistent effect placeholder: ${controlObject.effectId}`);
        }
        // Update local state for persistent effects
        setPersistentEffects((prev) => ({ ...prev, [controlObject.effectId]: fullConfig }));
      }
      return controlObject?.effectId || null;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects processEffect] Error processing effect ${fullConfig.effectId || '(new)'}:`, error);
      }
      return null;
    }
  }, []); // updateLayerConfigRef is a ref, processorRef is a ref. Their .current changing doesn't re-memoize.

  /** Creates and applies a default visual effect based on an event type string. */
  const createDefaultEffect = useCallback(async (eventType) => {
    const currentProcessor = processorRef.current;
    const currentUpdateFn = updateLayerConfigRef.current;

    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects createDefaultEffect] Processor not ready.");
      }
      return null;
    }


    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects createDefaultEffect] Creating default effect for event: ${eventType}`);
    }
    try {
      // Assuming createDefaultEffect might also return a control object with an effectId
      const controlObject = await currentProcessor.createDefaultEffect(eventType, currentUpdateFn);
      // If default effects can be persistent, handle similar to processEffect
      // For now, assuming they are not typically marked persistent this way.
      return controlObject?.effectId || null;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects createDefaultEffect] Error creating default effect for ${eventType}:`, error);
        if (error instanceof TypeError && error.message.includes("is not a function")) {
          console.error(`[useVisualEffects createDefaultEffect] DETECTED 'is not a function' error. Processor state:`, currentProcessor);
        }
      }
      return null;
    }
  }, []); // updateLayerConfigRef is a ref, processorRef is a ref.

  /** Manually stops and cleans up a specific effect instance by its ID. */
  const clearPersistentEffect = useCallback((effectId) => {
    const currentProcessor = processorRef.current;
    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects clearPersistentEffect] Processor not ready.");
      }
      return;
    }
    if (!effectId) return;

    if (import.meta.env.DEV) {
      // console.log(`[useVisualEffects clearPersistentEffect] Clearing effect: ${effectId}`);
    }
    try {
      currentProcessor.cancelEffect(effectId);
      setPersistentEffects((prev) => {
        if (!prev[effectId]) return prev; // No change if effectId not in state
        const newState = { ...prev };
        delete newState[effectId];
        if (import.meta.env.DEV) {
          // console.log(`[useVisualEffects clearPersistentEffect] Persistent effect ${effectId} removed from state.`);
        }
        return newState;
      });
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects clearPersistentEffect] Error cancelling effect ${effectId}:`, error);
      }
    }
  }, []); // processorRef is a ref.

  /** Stops and cleans up ALL currently active effects managed by the processor. */
  const clearAllTimedEffects = useCallback(() => {
    const currentProcessor = processorRef.current;
    if (!currentProcessor) {
      if (import.meta.env.DEV) {
        console.warn("[useVisualEffects clearAllTimedEffects] Processor not ready.");
      }
      return;
    }

    if (import.meta.env.DEV) {
      // console.log("[useVisualEffects clearAllTimedEffects] Clearing ALL processor-managed effects.");
    }
    try {
      currentProcessor.cancelAllEffects();
      // Optionally clear the local persistentEffects state if all effects are being cleared
      // setPersistentEffects({});
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error(`[useVisualEffects clearAllTimedEffects] Error cancelling all effects:`, error);
      }
    }
  }, []); // processorRef is a ref.

  return useMemo(() => ({
    processEffect,
    createDefaultEffect,
    clearPersistentEffect,
    clearAllTimedEffects,
    persistentEffects,
  }), [
    processEffect, createDefaultEffect, clearPersistentEffect, clearAllTimedEffects,
    persistentEffects
  ]);
}