// src/utils/VisualEffectsProcessor.js
import EffectFactory from "../effects/EffectFactory"; // Local dependency

/**
 * @typedef {object} EffectConfigInput
 * @property {string} [type] - The type identifier of the effect (e.g., 'color_overlay'). If not provided and `effect` is, `effect` will be used. Defaults to 'color_overlay' if neither is present.
 * @property {string} [effect] - Alternative key for effect type, for backward compatibility.
 * @property {string | number} layer - The target layer ID ('global', 1, 2, or 3).
 * @property {object} [config] - Effect-specific configuration options (e.g., color, duration).
 * @property {string} [effectId] - Optional unique ID; one will be generated by the EffectFactory if not provided.
 * @property {boolean} [isPersistent=false] - Flag indicating if the effect should persist (currently placeholder for processor's internal state, actual persistence managed by consumer).
 * @property {boolean} [preserveAnimation=false] - Hint for whether background animations should be preserved when this effect is active.
 */

/**
 * @typedef {object} EffectControlAPI
 * @property {string} effectId - The unique ID of the applied effect instance.
 * @property {string | number} layer - The target layer of the effect.
 * @property {() => void} clear - Function to manually stop and clean up this specific effect instance.
 * @property {string} type - The type of the effect.
 * @property {object} [config] - The configuration used for this effect instance.
 */

/**
 * Manages the creation, application, and lifecycle of visual effects.
 * It uses an EffectFactory to instantiate specific effect classes and keeps track
 * of active effects, allowing them to be cancelled individually, by layer, or all at once.
 * It also provides a method to create default effects based on event types.
 */
class VisualEffectsProcessor {
  /** @type {Map<string, EffectControlAPI>} Stores active effect control objects, keyed by effectId. */
  activeEffects = new Map();

  constructor() {
    this.activeEffects = new Map();
  }

  /**
   * Creates, applies, and tracks a visual effect based on the provided configuration.
   * Automatically cancels any existing effects on the same target layer before applying the new one.
   * Sets a timeout to remove the effect from the active list after its duration (plus a buffer),
   * effectively making effects self-cleaning from this processor's perspective unless explicitly persistent.
   *
   * @param {EffectConfigInput} effectConfig - The configuration object for the effect.
   * @param {(layerId: string | number, key: string, value: any) => void | null} [updateLayerConfig] - Optional function potentially used by the effect to update layer configuration.
   * @returns {Promise<EffectControlAPI | null>} A promise resolving to the effect's control object or null if creation/application failed.
   */
  async processEffect(effectConfig, updateLayerConfig) {
    if (import.meta.env.DEV) {
        // console.log(`[VisualEffectsProcessor] âœ… Processing effect:`, effectConfig); // Keep this potentially useful log for debugging effects
    }

    // Handle potential variations in effect type key
    let type = effectConfig.type || effectConfig.effect; // 'effect' for backward compatibility
    if (!type) {
      if (import.meta.env.DEV) {
        console.warn("[VisualEffectsProcessor] No effect type specified, defaulting to color_overlay");
      }
      type = "color_overlay";
    }
    const finalEffectConfig = { ...effectConfig, type };


    // Cancel conflicting effects on the same layer before applying a new one
    // This ensures only one effect (of this processor's management) is active per layer at a time.
    const activeLayerEffects = Array.from(this.activeEffects.values()).filter(
      (e) => e.layer === finalEffectConfig.layer,
    );
    activeLayerEffects.forEach((activeEffect) => {
      if (activeEffect?.clear) {
        if (import.meta.env.DEV) {
            // console.log(`[VisualEffectsProcessor] Cancelling existing effect ${activeEffect.effectId} on layer ${finalEffectConfig.layer} due to new effect.`);
        }
        activeEffect.clear();
        this.activeEffects.delete(activeEffect.effectId);
      }
    });

    // Create and apply the new effect
    try {
        const effectInstance = EffectFactory.createEffect(finalEffectConfig.type, finalEffectConfig);
        const controlObject = effectInstance.apply(updateLayerConfig); // Pass update function

        if (controlObject?.effectId) {
            this.activeEffects.set(controlObject.effectId, controlObject);

            // Auto-cleanup entry from map after duration (+ buffer)
            // This makes effects "timed" by default from the processor's perspective.
            // Persistent effects would need to be managed/re-added by the consumer if they expire here.
            const duration = finalEffectConfig.config?.duration || 3000; // Default duration if not specified
            setTimeout(() => {
                // Only delete if it's still the same effect instance in the map.
                // This check is minor as clear() should handle its own state, but good for safety.
                if (this.activeEffects.get(controlObject.effectId) === controlObject) {
                    this.activeEffects.delete(controlObject.effectId);
                }
            }, duration + 1000); // Buffer allows for cleanup animations or effect finalization

            return controlObject;
        } else {
             if (import.meta.env.DEV) {
                console.warn("[VisualEffectsProcessor] Effect instance did not return a valid control object from apply().");
             }
             return null;
        }
    } catch (error) {
        if (import.meta.env.DEV) {
            console.error(`[VisualEffectsProcessor] Error creating/applying effect type ${finalEffectConfig.type}:`, error);
        }
        return null;
    }
  }

  /**
   * Manually cancels and cleans up a specific active effect by its ID.
   * @param {string} effectId - The unique ID of the effect to cancel.
   * @returns {void}
   */
  cancelEffect(effectId) {
    const effectControl = this.activeEffects.get(effectId);
    if (effectControl?.clear) {
      try {
        effectControl.clear();
      } catch (e) {
        if (import.meta.env.DEV) {
            console.error(`[VisualEffectsProcessor] Error during effectControl.clear() for ${effectId}:`, e);
        }
      }
    }
    // Always remove from map regardless of clear success to prevent stale entries
    this.activeEffects.delete(effectId);
  }

  /**
   * Manually cancels all active effects currently running on a specific layer.
   * @param {string|number} layer - The layer identifier ('global', 1, 2, or 3).
   * @returns {void}
   */
  cancelEffectsForLayer(layer) {
    const layerIdStr = String(layer); // Ensure comparison is consistent
    const effectsToCancelOnLayer = [];
    for (const [id, effectControl] of this.activeEffects.entries()) {
      if (effectControl?.layer?.toString() === layerIdStr) {
        effectsToCancelOnLayer.push(id);
      }
    }
    effectsToCancelOnLayer.forEach((id) => this.cancelEffect(id));
  }

  /**
   * Manually cancels and cleans up all currently active effects managed by this processor.
   * @returns {void}
   */
  cancelAllEffects() {
    // Iterate over a copy of keys because cancelEffect modifies the map
    const allEffectIds = Array.from(this.activeEffects.keys());
    allEffectIds.forEach((effectId) => {
      this.cancelEffect(effectId);
    });
    // Ensure the map is cleared, though cancelEffect should handle individual deletions.
    this.activeEffects.clear();
  }

  /**
   * Creates and processes a default visual effect based on a given event type string.
   * Maps common event types to predefined effect configurations (e.g., color overlays).
   * @param {string} eventType - The type of the event (e.g., 'lyx_received', 'token_sent').
   * @param {(layerId: string | number, key: string, value: any) => void | null} [updateLayerConfig] - Optional function potentially used by the effect.
   * @returns {Promise<EffectControlAPI | null>} A promise resolving to the effect's control object or null.
   */
  async createDefaultEffect(eventType, updateLayerConfig) {
    const eventLower = typeof eventType === "string" ? eventType.toLowerCase() : "";
    /** @type {EffectConfigInput | undefined} */
    let effectConfig;

    // Define default effect configurations based on event type
    if (eventLower.includes("lyx_received") || eventLower.includes("lyxreceived")) {
      effectConfig = { type: "color_overlay", layer: "1", preserveAnimation: true, config: { color: "rgba(255, 165, 0, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("lyx_sent") || eventLower.includes("lyxsent")) {
      effectConfig = { type: "color_overlay", layer: "2", preserveAnimation: true, config: { color: "rgba(0, 140, 255, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("token_received") || eventLower.includes("tokenreceived")) {
      effectConfig = { type: "color_overlay", layer: "1", preserveAnimation: true, config: { color: "rgba(0, 255, 140, 0.3)", pulseCount: 3, duration: 3000 } };
    } else if (eventLower.includes("token_sent") || eventLower.includes("tokensent")) {
      effectConfig = { type: "color_overlay", layer: "2", preserveAnimation: true, config: { color: "rgba(153, 51, 255, 0.3)", pulseCount: 3, duration: 3000 } };
    } else { // Default for unknown/other events
      effectConfig = { type: "color_overlay", layer: "3", preserveAnimation: true, config: { color: "rgba(255, 51, 153, 0.3)", pulseCount: 3, duration: 3000 } };
    }

    if (!effectConfig) { // Should not happen with the logic above, but as a safeguard
        if (import.meta.env.DEV) {
            console.warn(`[VisualEffectsProcessor] No default effect config determined for eventType: ${eventType}`);
        }
        return Promise.resolve(null);
    }
    return this.processEffect(effectConfig, updateLayerConfig);
  }

  /**
   * Gets the number of currently active effects being tracked by this processor.
   * @returns {number} The count of active effects.
   */
  getActiveEffectsCount() {
    return this.activeEffects.size;
  }

  /**
   * Gets an array containing the control objects of all currently active effects.
   * @returns {Array<EffectControlAPI>} An array of active effect control objects.
   */
  getActiveEffects() {
    return Array.from(this.activeEffects.values());
  }
}

export default VisualEffectsProcessor;